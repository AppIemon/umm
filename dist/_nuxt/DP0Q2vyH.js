class it{calculateGap(t,n){let e;return t<=2?e=600-(t-1)*100:t<10?e=450-(t-3)*21.4:t<24?e=300-(t-10)*12.8:e=120-(t-24)*10.8,e=Math.max(55,e),n?e*1.5:e}generateFromPath(t,n,e,h=[]){if(!t||t.length<2)return[];const p=[],a=50,s=this.calculateGap(n,!1),i=Math.floor(t[0].x/a)*a,o=t[t.length-1].x;if(isNaN(i)||isNaN(o)||o<=i)return[];const r=10,c=["spike","piston_v","hammer","growing_spike","cannon","crusher_jaw"],f=["spike","falling_spike","hammer","swing_blade","piston_v","crusher_jaw"],x=["mine","rotor","spark_mine","laser_beam","planet","star"],d=(b,P,A)=>{let F=Array(P).fill([]).map(()=>[]),L=[...b];const X=P*A;for(;L.length<X;)L.push(b[Math.floor(Math.random()*b.length)]);for(let C=L.length-1;C>0;C--){const W=Math.floor(Math.random()*(C+1));[L[C],L[W]]=[L[W],L[C]]}for(let C=0;C<P;C++)F[C]=L.slice(C*A,(C+1)*A);return F},S=d(c,r,2),u=d(f,r,2),g=d(x,r,2);let m=Math.floor((t[0].y+s/2)/a)*a,l=Math.floor((t[0].y-s/2)/a)*a,w=0,M=0;e.sort((b,P)=>b-P);let T=0,H=!1,B=s*(1/1.4);for(let b=i;b<o;b+=a){const P=b+a/2;for(;w<t.length-1&&t[w+1].x<P;)w++;const A=t[w];if(!A)continue;const F=w<t.length-1?t[w+1]:A,L=A.time;for(;T<h.length&&h[T].time<=L;)H=h[T].isMini,T++;H?B=s*1.3:B=s;const X=B/2,C=b+a;let W=w;for(;W<t.length-1&&t[W+1].x<C;)W++;const O=t[W].y+X;let y=0;const v=O-m,Y=10;if(H?v<-a*1.5?y=-a*2:v<-Y?y=-a:v>a*1.5?y=a*2:v>Y&&(y=a):v<-Y?y=-a:v>Y&&(y=a),y<0){const _=y===-a*2?"steep_triangle":"triangle",q=Math.abs(y);m+=y;const R=m;p.push({type:_,x:b,y:R,width:a,height:q,rotation:0}),this.fillBelow(p,b,R+q,a)}else if(y>0){const _=y===a*2?"steep_triangle":"triangle",q=Math.abs(y),R=m;p.push({type:_,x:b,y:R,width:a,height:q,rotation:90}),this.fillBelow(p,b,R+q,a),m+=y}else{const k=m;p.push({type:"block",x:b,y:k,width:a,height:a}),this.fillBelow(p,b,k+a,a)}const D=y;if(D<0){const _=D===-a*2?"steep_triangle":"triangle",q=Math.abs(D);l+=D;const R=l;p.push({type:_,x:b,y:R,width:a,height:q,rotation:180}),this.fillAbove(p,b,R,a)}else if(D>0){const _=D===a*2?"steep_triangle":"triangle",q=Math.abs(D),R=l;p.push({type:_,x:b,y:R,width:a,height:q,rotation:-90}),this.fillAbove(p,b,R,a),l+=D}else{const k=l-a;p.push({type:"block",x:b,y:k,width:a,height:a}),this.fillAbove(p,b,k,a)}const z=Math.abs(Math.sin(b*.123+m*.456));if(!(n<=2)){if(y===0&&B>100&&z<.2){const k=n<=5?20:40,_=n<=5?"mini_spike":"spike",q=Math.min(Math.max((b-i)/(o-i),0),.999),R=Math.floor(q*r),K=S[R],I=u[R],E=K[Math.floor(Math.random()*K.length)]||"spike",j=I[Math.floor(Math.random()*I.length)]||"spike";if(z<.1){if(A.y<m-k-40&&m-k>l+40){const V=n>3?E:_;p.push({type:V,x:b,y:m-k,width:a,height:k})}}else if(A.y>l+k+40&&l+k<m-40){const V=n>3?j:_;p.push({type:V,x:b,y:l,width:a,height:k,rotation:180})}}}if(z>.95&&B>200&&n>4){const k=n>20||n<=10?20:30,_=(m+l)/2;let q=_;A.y<_&&(q=_+(m-_)*.5,q=_-(_-l)*.5);const R=Math.min(Math.max((b-i)/(o-i),0),.999),K=Math.floor(R*r),I=g[K],E=I[Math.floor(Math.random()*I.length)]||"mine",j=n>4?E:"mine";p.push({type:j,x:b+10,y:q-k/2,width:k,height:k,isHitbox:!0,rotation:j==="laser_beam"?90:0})}for(;M<e.length&&e[M]<A.time;)M++;for(;M<e.length&&e[M]<=F.time;){const k=(m+l)/2-40;k>=l&&k+80<=m&&p.push({type:"orb",x:b+25,y:k,width:80,height:80,isHitbox:!1}),M++}}return p.filter(b=>(["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green"].includes(b.type)||b.isHitbox===!0,!0))}fillBelow(t,n,e,h){const a=1e3-e;a>0&&t.push({type:"block",x:n,y:e,width:h,height:a,isHitbox:!0})}fillAbove(t,n,e,h){const s=e- -500;s>0&&t.push({type:"block",x:n,y:-500,width:h,height:s,isHitbox:!0})}}class st{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiStateTimer=0;aiPredictedPath=[];beatTimes=[];boss={active:!1,x:0,y:0,health:100,maxHealth:100,state:"idle",attackTimer:0,projectiles:[]};lastStateEvents=[];lastBeatActions=[];lastMeasureIndex=-1;isMeasureHighlight=!1;constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.reset(),this.reset()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,n=this.mapConfig.difficulty,e=this.basePlayerSize*4;let h=1;n<8?h=2.5-(n-1)/7*.7:n<16?h=1.3-(n-8)/8*.5:n<24?h=.8-(n-16)/8*.35:h=.45-(n-24)/7*.3;let p=1;n<8?p=4:n<16?p=1.5:n<24?p=1.2:p=1;const a=40;for(let s=0;s<10;s++){const i=80+s*12,o=Math.min(i,a),r=i-o,c=[];r>0&&c.push({dx:0,dy:t-r,w:50,h:r,type:"block"}),c.push({dx:0,dy:t-i,w:50,h:o,type:"spike"}),this.patterns.push({obstacles:c,requiredY:"top",width:60})}for(let s=0;s<10;s++){const i=80+s*12,o=Math.min(i,a),r=i-o,c=[];c.push({dx:0,dy:0,w:50,h:o,type:"spike"}),r>0&&c.push({dx:0,dy:o,w:50,h:r,type:"block"}),this.patterns.push({obstacles:c,requiredY:"bottom",width:60})}for(let s=0;s<10;s++){const i=120+s*15,o=t/2-i/2;this.patterns.push({obstacles:[{dx:0,dy:o,w:i,h:i,type:"block"}],requiredY:s%2===0?"top":"bottom",width:i+20,type:"square_block"})}for(let s=0;s<10;s++){const i=(160-s*8)*p,o=Math.max(e,i*h),r=(t-o)/2,c=r+o,f=t-c,x=Math.min(r,a),d=Math.min(f,a),S=[{dx:0,dy:Math.max(0,r-x),w:40,h:Math.max(0,x),type:"spike"},{dx:0,dy:c,w:40,h:Math.max(0,d),type:"spike"}];r>x&&S.push({dx:0,dy:0,w:40,h:r-x,type:"block"}),f>d&&S.push({dx:0,dy:c+d,w:40,h:f-d,type:"block"}),this.patterns.push({obstacles:S,requiredY:"middle",width:50})}for(let s=0;s<10;s++){const i=80+s*10,r=["top","middle","bottom"][s%3];let c=t/2-i/2;r==="top"&&(c=i/2+20),r==="bottom"&&(c=t-i-20),this.patterns.push({obstacles:[{dx:0,dy:c,w:i,h:i,type:"saw"}],requiredY:r==="top"?"bottom":r==="bottom"||s%2===0?"top":"bottom",width:i+30})}for(let s=0;s<10;s++){const i=2+Math.floor(s/3),o=[],r=50,c=Math.min(r,a),f=r-c;for(let x=0;x<i;x++)f>0&&o.push({dx:x*40,dy:t-f,w:35,h:f,type:"block"}),o.push({dx:x*40,dy:t-r,w:35,h:c,type:"spike"});this.patterns.push({obstacles:o,requiredY:"top",width:i*40+20})}for(let s=0;s<10;s++){const i=2+Math.floor(s/3),o=[],r=50,c=Math.min(r,a),f=r-c;for(let x=0;x<i;x++)o.push({dx:x*40,dy:0,w:35,h:c,type:"spike"}),f>0&&o.push({dx:x*40,dy:c,w:35,h:f,type:"block"});this.patterns.push({obstacles:o,requiredY:"bottom",width:i*40+20})}for(let s=0;s<10;s++){const i=[],o=100+s*12,r=Math.min(o,a),c=o-r;i.push({dx:0,dy:t-o,w:45,h:r,type:"spike"}),c>0&&i.push({dx:0,dy:t-c,w:45,h:c,type:"block"}),i.push({dx:60,dy:0,w:45,h:r,type:"spike"}),c>0&&i.push({dx:60,dy:r,w:45,h:c,type:"block"}),s>=5&&(i.push({dx:120,dy:t-o,w:45,h:r,type:"spike"}),c>0&&i.push({dx:120,dy:t-c,w:45,h:c,type:"block"})),this.patterns.push({obstacles:i,requiredY:"middle",width:s>=5?180:120})}for(let s=0;s<10;s++){const i=40+s*35,o=(100-s*4)*p,r=Math.max(e,o*h);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:i,type:"block"},{dx:0,dy:i+r,w:40,h:Math.max(0,t-i-r),type:"block"}],requiredY:i<t/3?"top":i>t*2/3-r?"bottom":"middle",width:50,type:"corridor"})}for(let s=0;s<10;s++){const i=[],r=Math.min(70,a),c=70-r;s%2===0?(i.push({dx:0,dy:t-70,w:50,h:r,type:"spike"}),c>0&&i.push({dx:0,dy:t-c,w:50,h:c,type:"block"}),i.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),i.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(i.push({dx:0,dy:0,w:50,h:r,type:"spike"}),c>0&&i.push({dx:0,dy:r,w:50,h:c,type:"block"}),i.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),i.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:i,requiredY:s%2===0?"top":"bottom",width:80})}for(let s=0;s<10;s++){const c=["top","middle","bottom"][s%3];let f=t/2-15/2;c==="top"&&(f=60),c==="bottom"&&(f=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:f,w:200,h:15,type:"laser"}],requiredY:c==="top"?"bottom":c==="bottom"||s%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let s=0;s<10;s++){const o=s%2===0?"saw":"spike_ball",r=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:r,w:60,h:60,type:o,movement:{type:"updown",range:100+s*10,speed:1+s*.25,phase:s*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let s=0;s<10;s++){const i=3+Math.floor(s/3),o=[];for(let r=0;r<i;r++){const c=50+r*120%(t-100);o.push({dx:r*80,dy:c,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:o,requiredY:"middle",width:i*80,type:"spike_ball_field"})}for(let s=0;s<10;s++){const r=100+s*100%(t-200),c=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h:r,type:"v_laser"},{dx:0,dy:r+c,w:15,h:t-(r+c),type:"v_laser"}],requiredY:r<t/3?"top":r>t*2/3-c?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let s=0;s<10;s++){const i=2+Math.floor(s/2),o=[];for(let r=0;r<i;r++){const c=100+Math.random()*(t-200),f=r*60;o.push({dx:f,dy:c,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:r}})}this.patterns.push({obstacles:o,requiredY:"middle",width:i*60+50,type:"mine_field"})}for(let s=0;s<10;s++){const o=t/2-60,r=[];r.push({dx:0,dy:o,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+s*.1,phase:0}}),this.patterns.push({obstacles:r,requiredY:s%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let s=0;s<10;s++){const i=[],o=t/2-25;i.push({dx:50,dy:o,w:50,h:50,type:"orb"}),i.push({dx:50,dy:0,w:50,h:60,type:"spike"}),i.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:i,requiredY:"middle",width:150})}for(let s=0;s<10;s++){const i=[],o=t/2-20;i.push({dx:0,dy:o,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),i.push({dx:0,dy:o,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:i,requiredY:"middle",width:300,type:"windmill"})}for(let s=0;s<10;s++){const i=[],o=3+s%3;for(let r=0;r<o;r++)i.push({dx:r*40,dy:100+r*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:i,requiredY:"middle",width:o*40,type:"mine_cluster"})}for(let s=0;s<10;s++){const i=[];for(let r=0;r<4;r++)i.push({dx:r*50,dy:50+r*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:i,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.speedMultiplier=1,this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){this.obstacles=t.engineObstacles.map(n=>({...n})),this.portals=t.enginePortals.map(n=>({...n,activated:!1})),this.autoplayLog=t.autoplayLog?[...t.autoplayLog]:[],this.totalLength=t.duration*this.baseSpeed+500,this.lastAutoplayIndex=0,console.log(`[loadMapData] Loaded ${this.obstacles.length} obstacles, ${this.portals.length} portals, ${this.autoplayLog.length} autoplay points`)}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,n,e,h,p=!0,a=0,s=120,i=2,o,r){this.bpm=s,this.measureLength=i;const c=h||t.length*777+Math.floor(e*100);this.obstacles=[],this.portals=[],r&&console.log(`[MapGen] Resuming generation from time ${r.time.toFixed(2)}s`),this.beatTimes=t||[],this.beatTimes=t||[],this.trackDuration=e,this.totalLength=e*this.baseSpeed+2e3,this.autoplayLog=[];const f=new it,x=this.mapConfig.difficulty;console.log(`[MapGen] Procedural Generation with seed: ${c}, Difficulty: ${x}`);const d=this.seededRandom(c+a),S=this.generatePathBasedMap(t,n,d,o,r);this.lastStateEvents=S;let u=0;if(r){const l=this.autoplayLog.find(M=>M.time>=r.time);l&&(u=l.x);const w=Math.max(0,u-100);this.obstacles=r.obstacles.filter(M=>M.x+M.width<w),this.portals=r.portals.filter(M=>M.x+M.width<w)}else this.obstacles=[],this.portals=[];let g=this.autoplayLog;r&&u>0&&(g=this.autoplayLog.filter(l=>l.x>=u-50));const m=f.generateFromPath(g,x,t,S);for(const l of m)["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green"].includes(l.type)?this.portals.push({x:l.x,y:this.minY,width:l.width||50,height:this.maxY-this.minY,type:l.type,activated:!1}):this.obstacles.push({x:l.x,y:l.y,width:l.width||50,height:l.height||50,type:l.type,angle:l.rotation||0,movement:void 0,initialY:l.y});this.obstacles.sort((l,w)=>l.x-w.x),this.portals.sort((l,w)=>l.x-w.x),console.log(`[MapGen] Generated ${this.obstacles.length} obstacles, ${this.portals.length} portals from path`)}generatePathBasedMap(t,n,e,h,p){const a=this.mapConfig.difficulty;this.maxY-this.minY;const s=1/60,o=60/this.bpm*4,r=[],c=t.length>0?Math.max(.5,t[0]):.5;for(let y=c;y<this.trackDuration;y+=o)r.push(y);const f=p?.time||0;console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${o.toFixed(3)}s, Total Measures: ${r.length}`);const x=[];let d="speed_1",S=!1,u=!1;const g=[{time:.5,speedType:"speed_1",isInverted:!1,isMini:!1}],m=g[0];if(a>=5&&m){const y=e();y<.3?m.speedType="speed_0.5":y<.6&&(m.speedType="speed_2")}if(x.push(...g),d=g[0].speedType,p){const y=p.stateEvents.filter(v=>v.time<f);if(x.length=0,x.push(...y),x.length>0){const v=x[x.length-1];d=v.speedType,S=v.isInverted,u=v.isMini}}for(const y of r){if(y<1||y<f)continue;n?.find(_=>y>=_.startTime&&y<_.endTime)?.intensity;let Y;if(a<8){const _=e();_<.8?Y="speed_1":_<.9?Y="speed_0.5":Y="speed_2"}else if(a<16){const _=e();_<.1?Y="speed_0.5":_<.6?Y="speed_1":Y="speed_2"}else if(a<24){const _=e();_<.15?Y="speed_0.5":_<.4?Y="speed_1":_<.8?Y="speed_2":Y="speed_3"}else{const _=e();_<.1?Y="speed_0.25":_<.25?Y="speed_0.5":_<.4?Y="speed_1":_<.5?Y="speed_2":_<.8?Y="speed_3":Y="speed_4"}const D=a>=24?.9:a<8?.25:.5;let z=S;e()<D&&a>=3&&(z=e()>.5);let k=u;if(a>=5)if(u)e()<.6&&(k=!1);else{const _=a>=24?.08:.04;e()<_&&(k=!0)}else k=!1;(Y!==d||z!==S||k!==u)&&(x.push({time:y,speedType:Y,isInverted:z,isMini:k}),d=Y,S=z,u=k)}const l=[];p&&l.push(...p.beatActions.filter(y=>y.time<f));const w=[...t].filter(y=>y>=.3&&y>=f).sort((y,v)=>y-v);let M=!1;p&&p.beatActions.length>0&&p.beatActions[p.beatActions.length-1].action==="click"&&(M=!0);const T=.25;for(let y=0;y<w.length;y++){const v=w[y],D=(y+1<w.length?w[y+1]:v+1)-v;if(D<T)l.push({time:v,action:M?"release":"click"}),M=!M;else if(M){const k=(e()-.5)*.3,_=Math.max(.3,Math.min(.8,.5+k));l.push({time:v,action:"click"}),l.push({time:v+D*_,action:"release"}),M=!1}else{const k=(e()-.5)*.3,_=Math.max(.3,Math.min(.8,.5+k));l.push({time:v,action:"click"}),l.push({time:v+D*_,action:"release"}),M=!1}}l.sort((y,v)=>y.time-v.time);const H=[];for(const y of l){if(H.length>0){const v=H[H.length-1];y.time-v.time<.01&&H.pop()}H.push(y)}l.length=0,l.push(...H),l.sort((y,v)=>y.time-v.time);const B=[];for(const y of l){const v=B[B.length-1];(!v||Math.abs(v.time-y.time)>.03||v.action!==y.action)&&B.push(y)}l.length=0,l.push(...B),this.autoplayLog=[];let b=200,P=360,A=0,F=!1,L=!1,X=1,C=!1,W=45,$=0,O=0;for(;A<this.trackDuration+1;){for(;O<x.length&&x[O].time<=A;){const z=x[O];X=this.getSpeedMultiplierFromType(z.speedType),L=z.isInverted,C=z.isMini,W=this.getEffectiveAngle(C,X),O++}for(;$<l.length&&l[$].time<=A;)F=l[$].action==="click",$++;const y=this.baseSpeed*X,v=y*Math.tan(W*Math.PI/180);let Y;L?Y=F?1:-1:Y=F?-1:1,P+=v*Y*s;const D=70;P<this.minY+D&&(P=this.minY+D),P>this.maxY-D&&(P=this.maxY-D),b+=y*s,this.autoplayLog.push({x:b,y:P,holding:F,time:A}),A+=s}this.lastBeatActions=l,this.totalLength=b+500;for(const y of x){const v=this.autoplayLog.find(q=>Math.abs(q.time-y.time)<.02);if(!v)continue;const Y=[],D=x[x.indexOf(y)-1],z=D?.speedType||"speed_1",k=D?.isInverted||!1,_=D?.isMini||!1;y.speedType!==z&&Y.push(y.speedType),y.isInverted!==k&&Y.push(y.isInverted?"gravity_yellow":"gravity_blue"),y.isMini!==_&&Y.push(y.isMini?"mini_pink":"mini_green"),Y.length>0&&this.generatePathAlignedPortals(v.x,v.y,Y)}return x}generatePathAlignedPortals(t,n,e){e.forEach((s,i)=>{const o=t+i*144,r=n-240/2;if(this.portals.push({x:o,y:this.minY,width:64,height:this.maxY-this.minY,type:s,activated:!1}),this.mapConfig.difficulty<=2)return;const c=r-this.minY-20;c>20&&this.obstacles.push({x:o-5,y:this.minY,width:74,height:c,type:"block",initialY:this.minY});const f=r+240+20,x=this.maxY-f;x>20&&this.obstacles.push({x:o-5,y:f,width:74,height:x,type:"block",initialY:f})})}isObstacleSafe(t,n,e,h,p=0){const a=this.basePlayerSize+p,s=t-a,i=t+e+a;let o=0,r=this.autoplayLog.length;for(;o<r;){const f=o+r>>>1;this.autoplayLog[f].x<s?o=f+1:r=f}const c=o;for(let f=c;f<this.autoplayLog.length;f++){const x=this.autoplayLog[f];if(x.x>i)break;if(x.y>=n-a&&x.y<=n+h+a)return!1}return!0}placeObstaclesForPath(t,n,e,h){const p=Math.max(.1,h/30),a=this.basePlayerSize;let s=1,i=!1;const o=[];this.portals.forEach(d=>{if(d.type==="mini_pink")o.push({x:d.x,isMini:!0,speed:s});else if(d.type==="mini_green")o.push({x:d.x,isMini:!1,speed:s});else if(d.type.startsWith("speed_")){const S=parseFloat(d.type.replace("speed_",""));o.push({x:d.x,isMini:i,speed:S})}}),o.sort((d,S)=>d.x-S.x);const r=d=>d<=.5?.4:d<=1?1:d<=2?1.5:2,c=()=>{const d=Math.max(a+5,50-p*35);return i?d*.5:d},f=800;let x=400;console.log(`[MapGen] Starting path obstacle placement - Diff: ${h}`);for(let d=500;d<this.totalLength-300;d+=100){const S=this.autoplayLog.find(H=>Math.abs(H.x-d)<50);if(!S)continue;const u=S.time,g=[...n].reverse().find(H=>H.time<=u);g&&(i=g.isMini,s=this.getSpeedMultiplierFromType(g.speedType));const m=S.y,l=c(),w=r(s);if(d-x<150*w)continue;if(i){this.placeTiltedBlock(d,m,l,60,e),x=d;continue}const M=Math.floor((d-500)/f)%4;M===0?(this.placeBlockWall(d,m,l,e),x=d):M===1?(this.placeTiltedBlock(d,m,l,45,e),x=d):M===2?(this.placeLaserWall(d,m,l,e),x=d):h>=10?(this.placeMovingObstacle(d,m,l,S.time,e),x=d):(this.placeBlockWall(d,m,l,e),x=d),t.find(H=>Math.abs(H.time*this.baseSpeed+200-d)<100)&&e()<.3+p*.3&&this.placeRapidBlocks(d,m,l,3,e)}}placeBlockWall(t,n,e,h){const p=50+Math.floor(h()*30),a=n-e-this.minY;a>30&&this.isObstacleSafe(t,this.minY,p,a,3)&&this.obstacles.push({x:t,y:this.minY,width:p,height:a,type:"block",initialY:this.minY});const s=n+e,i=this.maxY-s;i>30&&this.isObstacleSafe(t,s,p,i,3)&&this.obstacles.push({x:t,y:s,width:p,height:i,type:"block",initialY:s})}placeTiltedBlock(t,n,e,h,p){const a=100+Math.floor(p()*50),s=this.autoplayLog.find(f=>Math.abs(f.x-(t-100))<60),i=this.autoplayLog.find(f=>Math.abs(f.x-(t+100))<60);let o=!0;s&&i?o=i.y<s.y:s&&(o=n<s.y);const r=n-e-a;r>this.minY&&this.isObstacleSafe(t,r,a,a,3)&&this.obstacles.push({x:t,y:r,width:a,height:a,type:"slope",initialY:r,angle:o?h:-h});const c=n+e;if(c+a<this.maxY&&this.isObstacleSafe(t,c,a,a,3)&&this.obstacles.push({x:t,y:c,width:a,height:a,type:"slope",initialY:c,angle:o?-h:h}),p()<.3){const f=40+Math.floor(p()*30),x=t+a+30,d=n-f/2;this.isObstacleSafe(x,d,f,f,3)&&this.obstacles.push({x,y:d,width:f,height:f,type:"spike_ball",initialY:d})}}placeLaserWall(t,n,e,h){const a=n-e-this.minY-20;a>50&&this.obstacles.push({x:t+10,y:this.minY,width:30,height:a,type:"v_laser",initialY:this.minY});const s=n+e+20,i=this.maxY-s;i>50&&this.obstacles.push({x:t+10,y:s,width:30,height:i,type:"v_laser",initialY:s})}placeMovingObstacle(t,n,e,h,p){const a=40+Math.floor(p()*20),s=80+Math.floor(p()*60),i=1.5+p()*1.5,o=n-e-a-30;o>this.minY+s&&this.obstacles.push({x:t,y:o,width:a,height:a,type:"saw",initialY:o,moveY:{range:s,speed:i}});const r=n+e+30;r+a+s<this.maxY&&this.obstacles.push({x:t,y:r,width:a,height:a,type:"spike_ball",initialY:r,moveY:{range:s,speed:i}})}placeRapidBlocks(t,n,e,h,p){for(let i=0;i<h;i++){const o=t+i*60;if(i%2===0){const c=n-e-this.minY;c>20&&this.isObstacleSafe(o,this.minY,30,c,2)&&this.obstacles.push({x:o,y:this.minY,width:30,height:c,type:"block",initialY:this.minY})}else{const c=n+e,f=this.maxY-c;f>20&&this.isObstacleSafe(o,c,30,f,2)&&this.obstacles.push({x:o,y:c,width:30,height:f,type:"block",initialY:c})}}}getSmallObstacleType(t,n){const e=t();return n<8?e<.4?"spike":e<.7?"mini_spike":"orb":n<16?e<.25?"spike":e<.4?"saw":e<.55?"orb":e<.7?"mini_spike":e<.85?"spike_ball":"mine":n<24?e<.2?"spike":e<.35?"saw":e<.5?"spike_ball":e<.65?"mine":e<.8?"orb":"laser":e<.15?"spike":e<.25?"saw":e<.4?"spike_ball":e<.55?"mine":e<.7?"orb":e<.85?"laser":"v_laser"}getRandomObstacleType(t,n){if(n<8)return t()>.5?"block":"spike";if(n<16){const e=["block","spike","saw","mini_spike"];return e[Math.floor(t()*e.length)]}else if(n<24){const e=["block","spike","saw","laser","spike_ball"];return e[Math.floor(t()*e.length)]}else{const e=["block","spike","saw","laser","spike_ball","mine","orb","v_laser"];return e[Math.floor(t()*e.length)]}}getRandomDecorationType(t,n){if(n<16){const e=["mini_spike","orb"];return e[Math.floor(t()*e.length)]}else{const e=["mine","spike_ball","saw","orb"];return e[Math.floor(t()*e.length)]}}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,n){return t?n>=1.9?78:n>=1.7?72:60:45}getValidPatterns(t,n,e){const p={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let a=this.patterns.filter(s=>p.includes(s.requiredY));return e==="corridor"&&(a=a.filter(s=>s.type!=="corridor")),a}placePattern(t,n){const e=this.minY;for(const h of t.obstacles)this.obstacles.push({x:n+h.dx,y:e+h.dy,width:h.w,height:h.h,type:h.type,initialY:e+h.dy})}placePatternWithScale(t,n,e,h,p){const a=this.minY,s=this.maxY-this.minY;let i=1;e>1.2&&(i*=.85),e<.8&&(i*=1.15),h&&(i*=.75);for(const o of t.obstacles){let r=o.h*i,c=o.w*i,f=o.dy;if(o.dy<s/2)f=o.dy*i;else{const d=s-(o.dy+o.h);f=s-d*i-r}this.obstacles.push({x:n+o.dx*p,y:a+f,width:c,height:r,type:o.type,angle:o.angle,movement:o.movement?{...o.movement}:void 0,initialY:a+f})}}generatePortalWithType(t,n,e,h=[]){const i=this.maxY-this.minY,o=this.minY+80+e()*(i-160),r=[n,...h],c=r.length*50+(r.length-1)*40;r.forEach((S,u)=>{this.portals.push({x:t+u*90,y:o-100/2,width:50,height:100,type:S,activated:!1})});const f=this.basePlayerSize*2.2,x=o-100/2,d=o+100/2;x>this.minY+f&&this.obstacles.push({x:t-10,y:this.minY,width:c+20,height:x-this.minY-f,type:"block",initialY:this.minY}),d<this.maxY-f&&this.obstacles.push({x:t-10,y:d+f,width:c+20,height:this.maxY-(d+f),type:"block",initialY:d+f})}generatePortal(t,n){let e=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"];const h=this.mapConfig.difficulty;h<8?e=e.filter(s=>!["speed_2","speed_3","speed_4"].includes(s)):h<16?e=e.filter(s=>!["speed_3","speed_4"].includes(s)):h<24&&(e=e.filter(s=>s!=="speed_4"));const p=e.filter(s=>s==="gravity_blue"?this.portals.some(i=>i.type==="gravity_yellow"):!0),a=p[Math.floor(n()*p.length)]||"speed_1";this.generatePortalWithType(t,a,n)}*computeAutoplayLogGen(t,n){this.autoplayLog=[],this.validationFailureInfo=null;const e=1/30,h=[...this.obstacles].sort((l,w)=>l.x-w.x),p=[...this.portals].sort((l,w)=>l.x-w.x),a=l=>{let w=0,M=h.length;for(;w<M;){const T=w+M>>>1;h[T].x<l?w=T+1:M=T}return w},s={x:t,y:n,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},i=new Set,o=l=>{const w=Math.floor(l.x/(this.baseSpeed*.033)),M=Math.floor(l.y/12);return`${w}_${M}_${l.g?1:0}_${Math.round(l.sm*10)}_${l.m?1:0}`},r=(l,w,M,T,H=0)=>{if(w<this.minY+M||w>this.maxY-M)return!0;const B=a(l-1e3);for(let b=B;b<h.length;b++){const P=h[b];if(P.x+P.width<l-50)continue;if(P.x>l+100)break;const A=P.movement?2:0;if(this.checkObstacleCollision(P,l,w,M+H+A,T))return!0}return!1},c=(l,w,M)=>{let T=l.x,H=l.y,B=l.g,b=l.sm,P=l.wa,A=l.m,F=l.pIdx,L=l.time;for(let X=0;X<M;X++){for(;F<p.length&&T>=p[F].x;){const y=p[F];H>=y.y&&H<=y.y+y.height&&(y.type==="gravity_yellow"&&(B=!0),y.type==="gravity_blue"&&(B=!1),y.type.startsWith("speed_")&&(b=this.getSpeedMultiplierFromType(y.type)),y.type==="mini_pink"&&(A=!0),y.type==="mini_green"&&(A=!1),P=this.getEffectiveAngle(A,b)),F++}const C=this.baseSpeed*b,W=C*Math.tan(P*Math.PI/180),$=A?this.miniPlayerSize:this.basePlayerSize;if(T+=C*e,L+=e,H+=W*(B?w?1:-1:w?-1:1)*e,r(T,H,$,L,1))return!1}return!0},f=[s];let x=t,d=0;const S=25e4;let u=null,g=t,m=n;for(;f.length>0;){d++;const l=f.pop();if(l.x>x&&(x=l.x),d%1e3===0&&(yield x/this.totalLength),l.x>=this.totalLength){u=l;break}const w=o(l);if(i.has(w))continue;i.add(w);let M=l.g,T=l.sm,H=l.m,B=l.wa,b=l.pIdx;for(;b<p.length&&l.x>=p[b].x;){const I=p[b];if(l.y>=I.y&&l.y<=I.y+I.height){if(I.type==="gravity_yellow"&&(M=!0),I.type==="gravity_blue"&&(M=!1),I.type.startsWith("speed_")&&(T=this.getSpeedMultiplierFromType(I.type)),I.type==="mini_pink"&&(H=!0),I.type==="mini_green"&&(H=!1),I.type==="teleport_in"){const E=this.portals.find(j=>j.type==="teleport_out"&&(I.linkId?j.linkId===I.linkId:j.x>I.x));if(E){l.x=E.x+E.width+20,l.y=E.y+E.height/2,b=p.findIndex(j=>j.x>=l.x),b===-1&&(b=p.length);break}}B=this.getEffectiveAngle(H,T)}b++}const P=this.baseSpeed*T,A=P*Math.tan(B*Math.PI/180),F=H?this.miniPlayerSize:this.basePlayerSize,L=l.time+e,X=l.x+P*e,C=l.y+A*(M?1:-1)*e,W=l.y+A*(M?-1:1)*e;let $=r(X,C,F,L,3),O=r(X,W,F,L,3);const y=F*.8;!$&&Math.abs(C-l.y)>y&&r((l.x+X)/2,(l.y+C)/2,F,l.time+e/2,3)&&($=!0),!O&&Math.abs(W-l.y)>y&&r((l.x+X)/2,(l.y+W)/2,F,l.time+e/2,3)&&(O=!0),$&&O&&X>g&&(g=X,m=l.y);const v=l.h,Y=45,D=.125/Math.pow(l.sm,.7);let k=l.time-l.lastSwitchTime<D;if(k){const I=l.y;if(Math.abs(I-360)>25){const j=l.g,V=v,J=j?V?1:-1:V?-1:1;(I>360&&J>0||I<360&&J<0)&&(k=!1)}}let _=!1;const q=!$&&c({...l,x:X,y:C,time:L,g:M,sm:T,m:H,wa:B,pIdx:b,lastSwitchTime:v?l.lastSwitchTime:L},!0,Y),R=!O&&c({...l,x:X,y:W,time:L,g:M,sm:T,m:H,wa:B,pIdx:b,lastSwitchTime:v?L:l.lastSwitchTime},!1,Y);if(v?q?_=!0:_=!1:R?_=!1:_=!0,q&&R){const I=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let G=a(X-1e3);G<h.length;G++){const N=h[G];if(N.x+N.width<X)continue;if(N.x>X)break;const U=this.getObstacleYRangeAt(N,X,L);U&&I.push(U)}I.sort((G,N)=>G.top-N.top);const E=[];if(I.length>0){let G={...I[0]};for(let N=1;N<I.length;N++){const U=I[N];U.top<=G.bottom?G.bottom=Math.max(G.bottom,U.bottom):(E.push(G),G={...U})}E.push(G)}const j=[];for(let G=0;G<E.length-1;G++)j.push({top:E[G].bottom,bottom:E[G+1].top});let V=j[0],J=1/0;for(const G of j){const N=(G.top+G.bottom)/2,U=Math.abs(l.y-N);if(l.y>=G.top&&l.y<=G.bottom){V=G;break}U<J&&(J=U,V=G)}const Q=(V.top+V.bottom)/2,Z=Math.abs(C-Q),tt=Math.abs(W-Q);Z<tt?_=!0:tt<Z?_=!1:_=v}k&&(v&&q&&(_=!0),!v&&R&&(_=!1));const K=_?[!0,!1]:[!1,!0];for(const I of K)if(I?!$:!O){if(I!==v&&k&&(v?q:R))continue;const E=I!==v?L:l.lastSwitchTime;f.push({x:X,y:I?C:W,time:L,g:M,sm:T,m:H,wa:B,h:I,pIdx:b,lastSwitchTime:E,prev:l})}if(d>S)break}if(u){const l=[];let w=u;for(;w;)l.push({x:w.x,y:w.y,holding:w.h,time:w.time}),w=w.prev;return this.autoplayLog=l.reverse(),!0}else return this.validationFailureInfo={x:g,y:m,nearObstacles:h.filter(l=>l.x>g-400&&l.x<g+600)},!1}computeAutoplayLog(t=200,n=360){const e=this.computeAutoplayLogGen(t,n);let h=e.next();for(;!h.done;)h=e.next();return h.value}async computeAutoplayLogAsync(t,n,e){const h=this.computeAutoplayLogGen(t,n);let p=h.next(),a=performance.now();for(;!p.done;)typeof p.value=="number"&&performance.now()-a>16&&(e(p.value),await new Promise(i=>setTimeout(i,0)),a=performance.now()),p=h.next();return e(1),p.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,n){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const e=this.baseSpeed*this.speedMultiplier;this.waveSpeed=e;const p=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=e*Math.tan(p),this.playerX+=this.waveSpeed*t;let a=null;if(this.isAutoplay&&this.autoplayLog.length>0){const i=this.playerX;let o=null;for(let r=this.lastAutoplayIndex;r<this.autoplayLog.length;r++){const c=this.autoplayLog[r];if(c&&c.x>=i){o=c,this.lastAutoplayIndex=r;break}}if(o){this.isHolding=o.holding;const r=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(r){const f=(i-r.x)/(o.x-r.x);this.playerY=r.y+(o.y-r.y)*Math.max(0,Math.min(1,f)),a=r.time+(o.time-r.time)*Math.max(0,Math.min(1,f))}else this.playerY=o.y,a=o.time;const c=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=c.map(f=>({x:f.x,y:f.y}))}}else{this.aiPredictedPath=[];const i=this.isHolding?-1:1,o=this.isGravityInverted?-i:i;this.playerY+=this.waveAmplitude*o*t}if(this.playerY<this.minY+this.playerSize){this.playerY=this.minY+this.playerSize,this.die("천장에 충돌!"),this.spawnDeathParticles();return}if(this.playerY>this.maxY-this.playerSize){this.playerY=this.maxY-this.playerSize,this.die("바닥에 충돌!"),this.spawnDeathParticles();return}this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const s=a!==null?a:n;if(this.updateMovingObstacles(s),this.updateBoss(t,s),this.checkPortalCollisions(),this.checkCollisions(s),this.beatTimes.length>0){const i=this.beatTimes.findIndex(o=>o>=n);i!==-1&&i!==this.lastMeasureIndex&&Math.abs(this.beatTimes[i]-n)<.1&&(this.isMeasureHighlight=!0,this.lastMeasureIndex=i,setTimeout(()=>this.isMeasureHighlight=!1,150))}this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals){if(t.activated||t.x+t.width<this.playerX-50)continue;if(t.x>this.playerX+100)break;const n=this.playerSize,e=[{x:this.playerX-n,y:this.playerY-n},{x:this.playerX+n,y:this.playerY-n},{x:this.playerX-n,y:this.playerY+n},{x:this.playerX+n,y:this.playerY+n},{x:this.playerX,y:this.playerY}];if(t.angle&&t.angle!==0){const a=t.x+t.width/2,s=t.y+t.height/2,i=-t.angle*Math.PI/180;e.forEach(o=>{const r=o.x-a,c=o.y-s;o.x=a+r*Math.cos(i)-c*Math.sin(i),o.y=s+r*Math.sin(i)+c*Math.cos(i)})}e.some(a=>a.x>=t.x&&a.x<=t.x+t.width&&a.y>=t.y&&a.y<=t.y+t.height)&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break;case"teleport_in":const n=this.portals.find(e=>e.type==="teleport_in"&&e.activated&&Math.abs(e.x-this.playerX)<100);if(n){let e=null;n.linkId?e=this.portals.find(h=>h.type==="teleport_out"&&h.linkId===n.linkId):e=this.portals.find(h=>h.type==="teleport_out"&&h.x>this.playerX),e&&(this.playerX=e.x+e.width+20,this.playerY=e.y+e.height/2,this.cameraX=this.playerX-280,this.trail=[],this.spawnPortalParticles(e))}break}}updateBoss(t,n){if(this.boss.active){this.boss.attackTimer+=t,this.boss.x=this.cameraX+1e3,this.boss.y=360+Math.sin(n*.5)*100;for(let e=this.boss.projectiles.length-1;e>=0;e--){const h=this.boss.projectiles[e];h.x+=h.vx*t,h.y+=h.vy*t,Math.hypot(h.x-this.playerX,h.y-this.playerY)<20+this.playerSize&&this.die("보스 공격에 당했습니다!"),h.x<this.cameraX-100&&this.boss.projectiles.splice(e,1)}this.boss.attackTimer>3&&(this.boss.projectiles.push({x:this.boss.x,y:this.boss.y,vx:-600,vy:(this.playerY-this.boss.y)*2,type:"missile"}),this.boss.attackTimer=0)}}spawnPortalParticles(t){const n=this.getPortalColor(t.type);for(let e=0;e<10;e++){const h=Math.PI*2*e/10,p=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(h)*p,vy:Math.sin(h)*p,life:.6+Math.random()*.3,color:n})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";case"teleport_in":return"#00ffff";case"teleport_out":return"#ff00ff";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";case"teleport_in":return"IN";case"teleport_out":return"OUT";default:return"?"}}updateParticles(t){for(let n=this.particles.length-1;n>=0;n--){const e=this.particles[n];e&&(e.x+=e.vx*t,e.y+=e.vy*t,e.vy+=150*t,e.life-=t,e.life<=0&&this.particles.splice(n,1))}}getObstacleYRangeAt(t,n,e){if(n<t.x||n>t.x+t.width)return null;let h=t.y,p=t.angle||0;if(e!==void 0&&t.movement){const a=this.getObstacleStateAt(t,e);h=a.y,p=a.angle}if(t.type==="block"){if(p){const a=p*Math.PI/180,s=t.x+t.width/2,i=h+t.height/2,o=Math.cos(a),r=Math.sin(a),c=t.width/2,f=t.height/2,x=[{dx:-c,dy:-f},{dx:c,dy:-f},{dx:c,dy:f},{dx:-c,dy:f}].map(g=>({x:s+g.dx*o-g.dy*r,y:i+g.dx*r+g.dy*o}));let d=1/0,S=-1/0,u=!1;for(let g=0;g<4;g++){const m=x[g],l=x[(g+1)%4];if(m.x<=n&&n<=l.x||l.x<=n&&n<=m.x){if(Math.abs(m.x-l.x)<.1)d=Math.min(d,m.y,l.y),S=Math.max(S,m.y,l.y);else{const w=(n-m.x)/(l.x-m.x),M=m.y+w*(l.y-m.y);d=Math.min(d,M),S=Math.max(S,M)}u=!0}}return u?{top:d,bottom:S}:null}return{top:h,bottom:h+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const a=h>330,s=t.x+t.width/2;let i;if(n<=s){const o=(n-t.x)/(s-t.x);i=a?h+t.height-o*t.height:h+o*t.height}else{const o=(n-s)/(t.x+t.width-s);i=a?h+(1-o)*0+o*t.height:h+t.height-(1-o)*0-o*t.height,i=a?h+o*t.height:h+t.height-o*t.height}return a?{top:i,bottom:h+t.height}:{top:h,bottom:i}}if(t.type==="slope"){const a=(n-t.x)/t.width;if(p>0){const s=h+t.height*(1-a);return{top:h,bottom:s}}else{const s=h+t.height*a;return{top:h,bottom:s}}}if(t.type==="triangle"||t.type==="steep_triangle"){const a=(n-t.x)/t.width;return{top:h+t.height*(1-a),bottom:h+t.height}}return{top:h,bottom:h+t.height}}checkCollisions(t){for(const n of this.obstacles)if(!(n.x+n.width<this.playerX-80)){if(n.x>this.playerX+100)break;if(this.checkObstacleCollision(n,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,n,e,h,p){let a=t.y,s=t.angle||0;if(p!==void 0&&t.movement){const u=this.getObstacleStateAt(t,p);a=u.y,s=u.angle}let i=t.width,o=t.height;if(t.type==="mine"&&t.customData?.pulseSpeed){const u=p||performance.now()/1e3,g=t.customData.pulseSpeed||2,m=t.customData.pulseAmount||.2,l=1+Math.sin(u*g)*m;i*=l,o*=l}const r=10;i=Math.max(i,r),o=Math.max(o,r);const c=t.x-(i-t.width)/2,f=a-(o-t.height)/2,x=s!==0,d=[{x:n-h,y:e-h},{x:n+h,y:e-h},{x:n-h,y:e+h},{x:n+h,y:e+h},{x:n,y:e}];if(t.type==="planet"||t.type==="star"){const u=p||performance.now()/1e3,g=t.x+t.width/2,m=a+t.height/2,l=i/2,w=o/2,M=n-g,T=e-m;if(M*M/((l-2)*(l-2))+T*T/((w-2)*(w-2))<1)return!0;if(t.children&&t.children.length>0){const B=t.children,b=t.customData?.orbitSpeed??1;B.forEach((P,A)=>{const F=u*b+A*(Math.PI*2/B.length),L=t.customData?.orbitDistance??t.width*.85,X=g+Math.cos(F)*L,C=m+Math.sin(F)*L,W=P.width/2;if((d[4].x-X)**2+(d[4].y-C)**2<(W+h-2)**2)return!0;if(P.type==="planet"){const O=P.customData?.orbitCount??2,y=P.customData?.orbitSpeed??2,v=P.customData?.orbitDistance??P.width*.8;for(let Y=0;Y<O;Y++){const D=u*y+Y*(Math.PI*2/O),z=X+Math.cos(D)*v,k=C+Math.sin(D)*v;if((d[4].x-z)**2+(d[4].y-k)**2<(8+h-2)**2)return!0}}})}else{const B=t.customData?.orbitCount??(t.type==="star"?0:2);if(!(B===0&&t.type==="star")){const b=t.customData?.orbitSpeed??1,P=t.customData?.orbitDistance??t.width*.8;for(let A=0;A<B;A++){const F=u*b+A*(Math.PI*2/B),L=g+Math.cos(F)*P,X=m+Math.sin(F)*P,C=t.type==="star"?20:10;if((d[4].x-L)**2+(d[4].y-X)**2<(C+h-2)**2)return!0;if(t.type==="star"&&t.customData?.nestedOrbit){const y=b*2.5;for(let v=0;v<2;v++){const Y=u*y+v*(Math.PI*2/2),D=L+Math.cos(Y)*25,z=X+Math.sin(Y)*25;if((d[4].x-D)**2+(d[4].y-z)**2<(8+h-2)**2)return!0}}}}}return!1}if(x){const u=c+i/2,g=f+o/2,m=-s*Math.PI/180;d.forEach(l=>{const w=l.x-u,M=l.y-g;l.x=u+w*Math.cos(m)-M*Math.sin(m),l.y=g+w*Math.sin(m)+M*Math.cos(m)})}const S=d.some(u=>u.x>=c&&u.x<=c+i&&u.y>=f&&u.y<=f+o);if(!S&&t.type!=="slope"&&t.type!=="spike"&&t.type!=="mini_spike")return!1;if(t.type==="block")return S;if(t.type==="slope"){let u;t.angle>0?u=[{x:c,y:f+o},{x:c+i,y:f},{x:c,y:f}]:u=[{x:c+i,y:f+o},{x:c,y:f},{x:c+i,y:f}];for(const g of d)if(this.isPointInTriangle(g.x,g.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(t.type==="triangle"||t.type==="steep_triangle"){const u=[{x:c,y:f+o},{x:c+i,y:f+o},{x:c+i,y:f}];for(const g of d)if(this.isPointInTriangle(g.x,g.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(t.type==="spike"||t.type==="mini_spike"){const g=f>300?[{x:c,y:f+o},{x:c+i/2,y:f},{x:c+i,y:f+o}]:[{x:c,y:f},{x:c+i/2,y:f+o},{x:c+i,y:f}];for(const m of d)if(this.isPointInTriangle(m.x,m.y,g[0].x,g[0].y,g[1].x,g[1].y,g[2].x,g[2].y))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const u=c+i/2,g=f+o/2,m=i/2*.9,l=o/2*.9;for(const w of d){const M=w.x-u,T=w.y-g;if(M*M/(m*m)+T*T/(l*l)<1)return!0}return!1}if(t.type==="laser"){const u=o*.4,g=f+o/2;return d.some(m=>m.x>=c&&m.x<=c+i&&m.y>=g-u&&m.y<=g+u)}if(t.type==="v_laser"||t.type==="laser_beam"){const u=i*.4,g=c+i/2;return d.some(m=>m.y>=f&&m.y<=f+o&&m.x>=g-u&&m.x<=g+u)}if(t.type==="hammer"){const u=c+i/2,g=f+o/2;return d.some(m=>(m.x-u)**2+(m.y-g)**2<(i/2)**2)}if(t.type==="falling_spike"){const u=[{x:c,y:f},{x:c+i/2,y:f+o},{x:c+i,y:f}];for(const g of d)if(this.isPointInTriangle(g.x,g.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(["rotor","cannon","spark_mine","crusher_jaw","swing_blade"].includes(t.type)){const u=c+i/2,g=f+o/2,m=i/2*.8,l=o/2*.8;for(const w of d){const M=w.x-u,T=w.y-g;if(M*M/(m*m)+T*T/(l*l)<1)return!0}return!1}if(t.type==="piston_v")return S;if(t.type==="growing_spike"){const u=[{x:c,y:f+o},{x:c+i/2,y:f},{x:c+i,y:f+o}];for(const g of d)if(this.isPointInTriangle(g.x,g.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}return!1}isPointInRotatedRect(t,n,e){const h=(e.angle||0)*Math.PI/180,p=e.x+e.width/2,a=e.y+e.height/2,s=t-p,i=n-a,o=Math.cos(-h),r=Math.sin(-h),c=s*o-i*r,f=s*r+i*o;return Math.abs(c)<=e.width/2&&Math.abs(f)<=e.height/2}removeRedundantObstacles(){const t=new Set,n=this.obstacles.length;for(let e=0;e<n;e++){const h=this.obstacles[e];if(!h.movement)for(let p=0;p<n;p++){if(e===p)continue;const a=this.obstacles[p];if(a.movement)continue;const s=a.angle?Math.max(a.width,a.height):0;if(!(a.x-s>h.x||a.x+a.width+s<h.x+h.width)&&this.isObstacleContained(h,a)){t.add(e);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((e,h)=>!t.has(h)))}isObstacleContained(t,n){if(n.type!=="block"&&n.type!=="spike"&&n.type!=="mini_spike")return!1;const e=this.getObstacleCorners(t);for(const h of e)if(!this.isPointInStaticObstacle(h.x,h.y,n))return!1;return!0}isPointInStaticObstacle(t,n,e){if(e.type==="block")return this.isPointInRotatedRect(t,n,e);if(e.type==="spike"||e.type==="mini_spike"){const h=e.y>300,p=e.x+e.width/2;return h?this.isPointInTriangle(t,n,e.x,e.y+e.height,p,e.y,e.x+e.width,e.y+e.height):this.isPointInTriangle(t,n,e.x,e.y,p,e.y+e.height,e.x+e.width,e.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const n=t.y>300,e=t.x+t.width/2;return n?[{x:t.x,y:t.y+t.height},{x:e,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:e,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const n=t.angle*Math.PI/180,e=t.x+t.width/2,h=t.y+t.height/2,p=Math.cos(n),a=Math.sin(n),s=t.width/2,i=t.height/2;return[{dx:-s,dy:-i},{dx:s,dy:-i},{dx:s,dy:i},{dx:-s,dy:i}].map(o=>({x:e+o.dx*p-o.dy*a,y:h+o.dx*a+o.dy*p}))}return t.type==="triangle"||t.type==="steep_triangle"?[{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height},{x:t.x+t.width,y:t.y}]:[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,n,e,h,p,a,s,i){const o=Math.abs((e*(a-i)+p*(i-h)+s*(h-a))/2),r=Math.abs((t*(h-a)+e*(a-n)+p*(n-h))/2),c=Math.abs((t*(a-i)+p*(i-n)+s*(n-a))/2),f=Math.abs((t*(i-h)+s*(h-n)+e*(n-i))/2);return Math.abs(o-(r+c+f))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let n=0;n<15;n++){const e=Math.PI*2*n/15,h=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(e)*h,vy:Math.sin(e)*h,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,n){let e=t.y,h=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:p,speed:a,phase:s}=t.movement;e=t.initialY+Math.sin(n*a+s)*p}else if(t.movement.type==="rotate"){const{speed:p,phase:a}=t.movement;h=(n*p+a)*180/Math.PI%360}}return{y:e,angle:h}}updateMovingObstacles(t){for(const n of this.obstacles)if(n.movement){const e=this.getObstacleStateAt(n,t);n.y=e.y,n.movement.type==="rotate"&&(n.angle=e.angle)}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}export{st as G};
