class et{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiPredictedPath=[];constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.reset(),this.initPatterns()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,a=this.mapConfig.difficulty,e=this.basePlayerSize*4;let l=1;a<8?l=2.5-(a-1)/7*.7:a<16?l=1.3-(a-8)/8*.5:a<24?l=.8-(a-16)/8*.35:l=.45-(a-24)/7*.3;let d=1;a<8?d=4:a<16?d=1.5:a<24?d=1.2:d=1;const c=40;for(let i=0;i<10;i++){const s=80+i*12,n=Math.min(s,c),o=s-n,h=[];o>0&&h.push({dx:0,dy:t-o,w:50,h:o,type:"block"}),h.push({dx:0,dy:t-s,w:50,h:n,type:"spike"}),this.patterns.push({obstacles:h,requiredY:"top",width:60})}for(let i=0;i<10;i++){const s=80+i*12,n=Math.min(s,c),o=s-n,h=[];h.push({dx:0,dy:0,w:50,h:n,type:"spike"}),o>0&&h.push({dx:0,dy:n,w:50,h:o,type:"block"}),this.patterns.push({obstacles:h,requiredY:"bottom",width:60})}for(let i=0;i<10;i++){const s=120+i*15,n=t/2-s/2;this.patterns.push({obstacles:[{dx:0,dy:n,w:s,h:s,type:"block"}],requiredY:i%2===0?"top":"bottom",width:s+20,type:"square_block"})}for(let i=0;i<10;i++){const s=(160-i*8)*d,n=Math.max(e,s*l),o=(t-n)/2,h=o+n,p=t-h,m=Math.min(o,c),f=Math.min(p,c),M=[{dx:0,dy:Math.max(0,o-m),w:40,h:Math.max(0,m),type:"spike"},{dx:0,dy:h,w:40,h:Math.max(0,f),type:"spike"}];o>m&&M.push({dx:0,dy:0,w:40,h:o-m,type:"block"}),p>f&&M.push({dx:0,dy:h+f,w:40,h:p-f,type:"block"}),this.patterns.push({obstacles:M,requiredY:"middle",width:50})}for(let i=0;i<10;i++){const s=80+i*10,o=["top","middle","bottom"][i%3];let h=t/2-s/2;o==="top"&&(h=s/2+20),o==="bottom"&&(h=t-s-20),this.patterns.push({obstacles:[{dx:0,dy:h,w:s,h:s,type:"saw"}],requiredY:o==="top"?"bottom":o==="bottom"||i%2===0?"top":"bottom",width:s+30})}for(let i=0;i<10;i++){const s=2+Math.floor(i/3),n=[],o=50,h=Math.min(o,c),p=o-h;for(let m=0;m<s;m++)p>0&&n.push({dx:m*40,dy:t-p,w:35,h:p,type:"block"}),n.push({dx:m*40,dy:t-o,w:35,h,type:"spike"});this.patterns.push({obstacles:n,requiredY:"top",width:s*40+20})}for(let i=0;i<10;i++){const s=2+Math.floor(i/3),n=[],o=50,h=Math.min(o,c),p=o-h;for(let m=0;m<s;m++)n.push({dx:m*40,dy:0,w:35,h,type:"spike"}),p>0&&n.push({dx:m*40,dy:h,w:35,h:p,type:"block"});this.patterns.push({obstacles:n,requiredY:"bottom",width:s*40+20})}for(let i=0;i<10;i++){const s=[],n=100+i*12,o=Math.min(n,c),h=n-o;s.push({dx:0,dy:t-n,w:45,h:o,type:"spike"}),h>0&&s.push({dx:0,dy:t-h,w:45,h,type:"block"}),s.push({dx:60,dy:0,w:45,h:o,type:"spike"}),h>0&&s.push({dx:60,dy:o,w:45,h,type:"block"}),i>=5&&(s.push({dx:120,dy:t-n,w:45,h:o,type:"spike"}),h>0&&s.push({dx:120,dy:t-h,w:45,h,type:"block"})),this.patterns.push({obstacles:s,requiredY:"middle",width:i>=5?180:120})}for(let i=0;i<10;i++){const s=40+i*35,n=(100-i*4)*d,o=Math.max(e,n*l);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:s,type:"block"},{dx:0,dy:s+o,w:40,h:Math.max(0,t-s-o),type:"block"}],requiredY:s<t/3?"top":s>t*2/3-o?"bottom":"middle",width:50,type:"corridor"})}for(let i=0;i<10;i++){const s=[],o=Math.min(70,c),h=70-o;i%2===0?(s.push({dx:0,dy:t-70,w:50,h:o,type:"spike"}),h>0&&s.push({dx:0,dy:t-h,w:50,h,type:"block"}),s.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),s.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(s.push({dx:0,dy:0,w:50,h:o,type:"spike"}),h>0&&s.push({dx:0,dy:o,w:50,h,type:"block"}),s.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),s.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:s,requiredY:i%2===0?"top":"bottom",width:80})}for(let i=0;i<10;i++){const h=["top","middle","bottom"][i%3];let p=t/2-15/2;h==="top"&&(p=60),h==="bottom"&&(p=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:p,w:200,h:15,type:"laser"}],requiredY:h==="top"?"bottom":h==="bottom"||i%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let i=0;i<10;i++){const n=i%2===0?"saw":"spike_ball",o=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:o,w:60,h:60,type:n,movement:{type:"updown",range:100+i*10,speed:1+i*.25,phase:i*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let i=0;i<10;i++){const s=3+Math.floor(i/3),n=[];for(let o=0;o<s;o++){const h=50+o*120%(t-100);n.push({dx:o*80,dy:h,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:n,requiredY:"middle",width:s*80,type:"spike_ball_field"})}for(let i=0;i<10;i++){const o=100+i*100%(t-200),h=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h:o,type:"v_laser"},{dx:0,dy:o+h,w:15,h:t-(o+h),type:"v_laser"}],requiredY:o<t/3?"top":o>t*2/3-h?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let i=0;i<10;i++){const s=2+Math.floor(i/2),n=[];for(let o=0;o<s;o++){const h=100+Math.random()*(t-200),p=o*60;n.push({dx:p,dy:h,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:o}})}this.patterns.push({obstacles:n,requiredY:"middle",width:s*60+50,type:"mine_field"})}for(let i=0;i<10;i++){const n=t/2-60,o=[];o.push({dx:0,dy:n,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+i*.1,phase:0}}),this.patterns.push({obstacles:o,requiredY:i%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let i=0;i<10;i++){const s=[],n=t/2-25;s.push({dx:50,dy:n,w:50,h:50,type:"orb"}),s.push({dx:50,dy:0,w:50,h:60,type:"spike"}),s.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:s,requiredY:"middle",width:150})}for(let i=0;i<10;i++){const s=[],n=t/2-20;s.push({dx:0,dy:n,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),s.push({dx:0,dy:n,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:s,requiredY:"middle",width:300,type:"windmill"})}for(let i=0;i<10;i++){const s=[],n=3+i%3;for(let o=0;o<n;o++)s.push({dx:o*40,dy:100+o*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:s,requiredY:"middle",width:n*40,type:"mine_cluster"})}for(let i=0;i<10;i++){const s=[];for(let o=0;o<4;o++)s.push({dx:o*50,dy:50+o*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:s,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.speedMultiplier=1,this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){this.obstacles=t.engineObstacles.map(a=>({...a})),this.portals=t.enginePortals.map(a=>({...a,activated:!1})),this.autoplayLog=t.autoplayLog?[...t.autoplayLog]:[],this.totalLength=t.duration*this.baseSpeed+500,this.lastAutoplayIndex=0,console.log(`[loadMapData] Loaded ${this.obstacles.length} obstacles, ${this.portals.length} portals, ${this.autoplayLog.length} autoplay points`)}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,a,e,l,d=!0,c=0,i=120,s=2){this.bpm=i,this.measureLength=s;const n=l||t.length*777+Math.floor(e*100);this.initPatterns(),this.obstacles=[],this.portals=[],this.trackDuration=e,this.totalLength=e*this.baseSpeed+500,this.autoplayLog=[];const o=this.seededRandom(n+c);this.generatePathBasedMap(t,a,o),this.obstacles.sort((h,p)=>h.x-p.x),this.portals.sort((h,p)=>h.x-p.x),this.removeRedundantObstacles(),console.log(`[MapGen] Path-based map generated with seed: ${n}, beats: ${t.length}, obstacles: ${this.obstacles.length}, portals: ${this.portals.length}`)}generatePathBasedMap(t,a,e){const l=this.mapConfig.difficulty;this.maxY-this.minY;const d=1/60,i=60/this.bpm*4,s=[],n=t.length>0?Math.max(.5,t[0]):.5;for(let u=n;u<this.trackDuration;u+=i)s.push(u);console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${i.toFixed(3)}s, Total Measures: ${s.length}`);const o=[];let h="speed_1",p=!1,m=!1;for(const u of s){if(u<.5)continue;const _=a?.find(I=>u>=I.startTime&&u<I.endTime)?.intensity||.5;let b;if(l<8)_<.4?b="speed_0.5":_<.7?b="speed_1":b="speed_2";else if(l<16)_<.6?b="speed_1":b="speed_2";else if(l<24)_<.3?b="speed_0.5":_<.65?b="speed_2":b="speed_3";else{const I=e();_>.85?b="speed_4":I<.2?b="speed_0.5":I<.35?b="speed_0.25":I<.6?b="speed_3":b="speed_4"}const L=l>=24?.9:l<8?.25:.5;let z=p;e()<L&&l>=3&&(z=e()>.5);let A=m;if(l>=2){const I=l>=24?.4:.2;e()<I&&(A=!m)}(b!==h||z!==p||A!==m)&&(o.push({time:u,speedType:b,isInverted:z,isMini:A}),h=b,p=z,m=A)}const f=[],M=[...t].filter(u=>u>=.3).sort((u,w)=>u-w);let g=.5;for(let u=1;u<M.length;u++){const w=M[u]-M[u-1];w>.05&&w<g&&(g=w)}for(let u=0;u<M.length;u++){const w=M[u],_=u+1<M.length?M[u+1]:w+g,b=Math.min(_-w,g*2),z=[...o].reverse().find(I=>I.time<=w)?.isMini?.32:.6;f.push({time:w,action:"click"});const A=w+b*z;A<_-.03&&f.push({time:A,action:"release"})}f.sort((u,w)=>u.time-w.time);const x=[];for(const u of f){const w=x[x.length-1];(!w||Math.abs(w.time-u.time)>.03||w.action!==u.action)&&x.push(u)}f.length=0,f.push(...x),this.autoplayLog=[];let r=200,y=360,v=0,k=!1,H=!1,P=1,T=!1,X=45,W=0,O=0;for(;v<this.trackDuration+1;){for(;O<o.length&&o[O].time<=v;){const L=o[O];P=this.getSpeedMultiplierFromType(L.speedType),H=L.isInverted,T=L.isMini,X=this.getEffectiveAngle(T,P),O++}for(;W<f.length&&f[W].time<=v;)k=f[W].action==="click",W++;const u=this.baseSpeed*P,w=u*Math.tan(X*Math.PI/180);let _;H?_=k?1:-1:_=k?-1:1,y+=w*_*d;const b=30;y<this.minY+b&&(y=this.minY+b),y>this.maxY-b&&(y=this.maxY-b),r+=u*d,this.autoplayLog.push({x:r,y,holding:k,time:v}),v+=d}this.totalLength=r+500;for(const u of o){const w=this.autoplayLog.find(I=>Math.abs(I.time-u.time)<.02);if(!w)continue;const _=[],b=o[o.indexOf(u)-1],L=b?.speedType||"speed_1",z=b?.isInverted||!1,A=b?.isMini||!1;u.speedType!==L&&_.push(u.speedType),u.isInverted!==z&&_.push(u.isInverted?"gravity_yellow":"gravity_blue"),u.isMini!==A&&_.push(u.isMini?"mini_pink":"mini_green"),_.length>0&&this.generatePathAlignedPortals(w.x,w.y,_)}this.placeObstaclesForPath(f,o,e,l)}generatePathAlignedPortals(t,a,e){e.forEach((i,s)=>{const n=t+s*110,o=a-80/2;this.portals.push({x:n,y:o,width:50,height:80,type:i,activated:!1});const h=o-this.minY-15;h>20&&this.obstacles.push({x:n-5,y:this.minY,width:60,height:h,type:"block",initialY:this.minY});const p=o+80+15,m=this.maxY-p;m>20&&this.obstacles.push({x:n-5,y:p,width:60,height:m,type:"block",initialY:p})})}isObstacleSafe(t,a,e,l,d=0){const c=this.basePlayerSize+d;for(const i of this.autoplayLog)if(i.x>=t-c&&i.x<=t+e+c&&i.y>=a-c&&i.y<=a+l+c)return!1;return!0}placeObstaclesForPath(t,a,e,l){const d=Math.max(.1,l/30),c=this.basePlayerSize;let i=1,s=!1;const n=[];this.portals.forEach(f=>{if(f.type==="mini_pink")n.push({x:f.x,isMini:!0,speed:i});else if(f.type==="mini_green")n.push({x:f.x,isMini:!1,speed:i});else if(f.type.startsWith("speed_")){const M=parseFloat(f.type.replace("speed_",""));n.push({x:f.x,isMini:s,speed:M})}}),n.sort((f,M)=>f.x-M.x);const o=f=>f<=.5?.4:f<=1?1:f<=2?1.5:2,h=()=>{const f=Math.max(c+5,50-d*35);return s?f*.5:f},p=800;let m=400;console.log(`[MapGen] Starting path obstacle placement - Diff: ${l}`);for(let f=500;f<this.totalLength-300;f+=100){const M=this.autoplayLog.find(P=>Math.abs(P.x-f)<50);if(!M)continue;const g=M.time,x=[...a].reverse().find(P=>P.time<=g);x&&(s=x.isMini,i=this.getSpeedMultiplierFromType(x.speedType));const r=M.y,y=h(),v=o(i);if(f-m<150*v)continue;if(s){this.placeTiltedBlock(f,r,y,60,e),m=f;continue}const k=Math.floor((f-500)/p)%4;k===0?(this.placeBlockWall(f,r,y,e),m=f):k===1?(this.placeTiltedBlock(f,r,y,45,e),m=f):k===2?(this.placeLaserWall(f,r,y,e),m=f):l>=10?(this.placeMovingObstacle(f,r,y,M.time,e),m=f):(this.placeBlockWall(f,r,y,e),m=f),t.find(P=>Math.abs(P.time*this.baseSpeed+200-f)<100)&&e()<.3+d*.3&&this.placeRapidBlocks(f,r,y,3,e)}console.log(`[MapGen] Placed ${this.obstacles.length} obstacles (Mini sections handled with 60° tilted blocks)`)}placeBlockWall(t,a,e,l){const d=50+Math.floor(l()*30),c=a-e-this.minY;c>30&&this.isObstacleSafe(t,this.minY,d,c,3)&&this.obstacles.push({x:t,y:this.minY,width:d,height:c,type:"block",initialY:this.minY});const i=a+e,s=this.maxY-i;s>30&&this.isObstacleSafe(t,i,d,s,3)&&this.obstacles.push({x:t,y:i,width:d,height:s,type:"block",initialY:i})}placeTiltedBlock(t,a,e,l,d){const c=100+Math.floor(d()*50),i=this.autoplayLog.find(p=>Math.abs(p.x-(t-100))<60),s=this.autoplayLog.find(p=>Math.abs(p.x-(t+100))<60);let n=!0;i&&s?n=s.y<i.y:i&&(n=a<i.y);const o=a-e-c;o>this.minY&&this.isObstacleSafe(t,o,c,c,3)&&this.obstacles.push({x:t,y:o,width:c,height:c,type:"slope",initialY:o,angle:n?l:-l});const h=a+e;if(h+c<this.maxY&&this.isObstacleSafe(t,h,c,c,3)&&this.obstacles.push({x:t,y:h,width:c,height:c,type:"slope",initialY:h,angle:n?-l:l}),d()<.3){const p=40+Math.floor(d()*30),m=t+c+30,f=a-p/2;this.isObstacleSafe(m,f,p,p,3)&&this.obstacles.push({x:m,y:f,width:p,height:p,type:"spike_ball",initialY:f})}}placeLaserWall(t,a,e,l){const c=a-e-this.minY-20;c>50&&this.obstacles.push({x:t+10,y:this.minY,width:30,height:c,type:"v_laser",initialY:this.minY});const i=a+e+20,s=this.maxY-i;s>50&&this.obstacles.push({x:t+10,y:i,width:30,height:s,type:"v_laser",initialY:i})}placeMovingObstacle(t,a,e,l,d){const c=40+Math.floor(d()*20),i=80+Math.floor(d()*60),s=1.5+d()*1.5,n=a-e-c-30;n>this.minY+i&&this.obstacles.push({x:t,y:n,width:c,height:c,type:"saw",initialY:n,moveY:{range:i,speed:s}});const o=a+e+30;o+c+i<this.maxY&&this.obstacles.push({x:t,y:o,width:c,height:c,type:"spike_ball",initialY:o,moveY:{range:i,speed:s}})}placeRapidBlocks(t,a,e,l,d){for(let s=0;s<l;s++){const n=t+s*60;if(s%2===0){const h=a-e-this.minY;h>20&&this.isObstacleSafe(n,this.minY,30,h,2)&&this.obstacles.push({x:n,y:this.minY,width:30,height:h,type:"block",initialY:this.minY})}else{const h=a+e,p=this.maxY-h;p>20&&this.isObstacleSafe(n,h,30,p,2)&&this.obstacles.push({x:n,y:h,width:30,height:p,type:"block",initialY:h})}}}getSmallObstacleType(t,a){const e=t();return a<8?e<.4?"spike":e<.7?"mini_spike":"orb":a<16?e<.25?"spike":e<.4?"saw":e<.55?"orb":e<.7?"mini_spike":e<.85?"spike_ball":"mine":a<24?e<.2?"spike":e<.35?"saw":e<.5?"spike_ball":e<.65?"mine":e<.8?"orb":"laser":e<.15?"spike":e<.25?"saw":e<.4?"spike_ball":e<.55?"mine":e<.7?"orb":e<.85?"laser":"v_laser"}getRandomObstacleType(t,a){if(a<8)return t()>.5?"block":"spike";if(a<16){const e=["block","spike","saw","mini_spike"];return e[Math.floor(t()*e.length)]}else if(a<24){const e=["block","spike","saw","laser","spike_ball"];return e[Math.floor(t()*e.length)]}else{const e=["block","spike","saw","laser","spike_ball","mine","orb","v_laser"];return e[Math.floor(t()*e.length)]}}getRandomDecorationType(t,a){if(a<16){const e=["mini_spike","orb"];return e[Math.floor(t()*e.length)]}else{const e=["mine","spike_ball","saw","orb"];return e[Math.floor(t()*e.length)]}}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,a){return t?a>=1.9?78:a>=1.7?72:60:45}getValidPatterns(t,a,e){const d={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let c=this.patterns.filter(i=>d.includes(i.requiredY));return e==="corridor"&&(c=c.filter(i=>i.type!=="corridor")),c}placePattern(t,a){const e=this.minY;for(const l of t.obstacles)this.obstacles.push({x:a+l.dx,y:e+l.dy,width:l.w,height:l.h,type:l.type,initialY:e+l.dy})}placePatternWithScale(t,a,e,l,d){const c=this.minY,i=this.maxY-this.minY;let s=1;e>1.2&&(s*=.85),e<.8&&(s*=1.15),l&&(s*=.75);for(const n of t.obstacles){let o=n.h*s,h=n.w*s,p=n.dy;if(n.dy<i/2)p=n.dy*s;else{const f=i-(n.dy+n.h);p=i-f*s-o}this.obstacles.push({x:a+n.dx*d,y:c+p,width:h,height:o,type:n.type,angle:n.angle,movement:n.movement?{...n.movement}:void 0,initialY:c+p})}}generatePortalWithType(t,a,e,l=[]){const s=this.maxY-this.minY,n=this.minY+80+e()*(s-160),o=[a,...l],h=o.length*50+(o.length-1)*40;o.forEach((M,g)=>{this.portals.push({x:t+g*90,y:n-100/2,width:50,height:100,type:M,activated:!1})});const p=this.basePlayerSize*2.2,m=n-100/2,f=n+100/2;m>this.minY+p&&this.obstacles.push({x:t-10,y:this.minY,width:h+20,height:m-this.minY-p,type:"block",initialY:this.minY}),f<this.maxY-p&&this.obstacles.push({x:t-10,y:f+p,width:h+20,height:this.maxY-(f+p),type:"block",initialY:f+p})}generatePortal(t,a){let e=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"];const l=this.mapConfig.difficulty;l<8?e=e.filter(i=>!["speed_2","speed_3","speed_4"].includes(i)):l<16?e=e.filter(i=>!["speed_3","speed_4"].includes(i)):l<24&&(e=e.filter(i=>i!=="speed_4"));const d=e.filter(i=>i==="gravity_blue"?this.portals.some(s=>s.type==="gravity_yellow"):!0),c=d[Math.floor(a()*d.length)]||"speed_1";this.generatePortalWithType(t,c,a)}*computeAutoplayLogGen(t,a){this.autoplayLog=[],this.validationFailureInfo=null;const e=1/30,l=[...this.obstacles].sort((r,y)=>r.x-y.x),d=[...this.portals].sort((r,y)=>r.x-y.x),c={x:t,y:a,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},i=new Set,s=r=>{const y=Math.floor(r.x/(this.baseSpeed*.033)),v=Math.floor(r.y/12);return`${y}_${v}_${r.g?1:0}_${Math.round(r.sm*10)}_${r.m?1:0}`},n=(r,y,v,k,H=0)=>{if(y<this.minY+v||y>this.maxY-v)return!0;for(let P=0;P<l.length;P++){const T=l[P];if(T.x+T.width<r-50)continue;if(T.x>r+100)break;const X=T.movement?2:0;if(this.checkObstacleCollision(T,r,y,v+H+X,k))return!0}return!1},o=(r,y,v)=>{let k=r.x,H=r.y,P=r.g,T=r.sm,X=r.wa,W=r.m,O=r.pIdx,u=r.time;for(let w=0;w<v;w++){for(;O<d.length&&k>=d[O].x;){const A=d[O];H>=A.y&&H<=A.y+A.height&&(A.type==="gravity_yellow"&&(P=!0),A.type==="gravity_blue"&&(P=!1),A.type.startsWith("speed_")&&(T=this.getSpeedMultiplierFromType(A.type)),A.type==="mini_pink"&&(W=!0),A.type==="mini_green"&&(W=!1),X=this.getEffectiveAngle(W,T)),O++}const _=this.baseSpeed*T,b=_*Math.tan(X*Math.PI/180),L=W?this.miniPlayerSize:this.basePlayerSize;if(k+=_*e,u+=e,H+=b*(P?y?1:-1:y?-1:1)*e,n(k,H,L,u,3))return!1}return!0},h=[c];let p=t,m=0;const f=25e4;let M=null,g=t,x=a;for(;h.length>0;){m++;const r=h.pop();if(r.x>p&&(p=r.x,m%500===0&&(yield p/this.totalLength)),r.x>=this.totalLength){M=r;break}const y=s(r);if(i.has(y))continue;i.add(y);let v=r.g,k=r.sm,H=r.m,P=r.wa,T=r.pIdx;for(;T<d.length&&r.x>=d[T].x;){const Y=d[T];r.y>=Y.y&&r.y<=Y.y+Y.height&&(Y.type==="gravity_yellow"&&(v=!0),Y.type==="gravity_blue"&&(v=!1),Y.type.startsWith("speed_")&&(k=this.getSpeedMultiplierFromType(Y.type)),Y.type==="mini_pink"&&(H=!0),Y.type==="mini_green"&&(H=!1),P=this.getEffectiveAngle(H,k)),T++}const X=this.baseSpeed*k,W=X*Math.tan(P*Math.PI/180),O=H?this.miniPlayerSize:this.basePlayerSize,u=r.time+e,w=r.x+X*e,_=r.y+W*(v?1:-1)*e,b=r.y+W*(v?-1:1)*e;let L=n(w,_,O,u,3),z=n(w,b,O,u,3);const A=O*.8;!L&&Math.abs(_-r.y)>A&&n((r.x+w)/2,(r.y+_)/2,O,r.time+e/2,3)&&(L=!0),!z&&Math.abs(b-r.y)>A&&n((r.x+w)/2,(r.y+b)/2,O,r.time+e/2,3)&&(z=!0),L&&z&&w>g&&(g=w,x=r.y);const I=r.h,N=45,J=.125/Math.pow(r.sm,.7);let F=r.time-r.lastSwitchTime<J;if(F){const Y=r.y;if(Math.abs(Y-360)>25){const D=r.g,G=I,E=D?G?1:-1:G?-1:1;(Y>360&&E>0||Y<360&&E<0)&&(F=!1)}}let q=!1;const $=!L&&o({...r,x:w,y:_,time:u,g:v,sm:k,m:H,wa:P,pIdx:T,lastSwitchTime:I?r.lastSwitchTime:u},!0,N),j=!z&&o({...r,x:w,y:b,time:u,g:v,sm:k,m:H,wa:P,pIdx:T,lastSwitchTime:I?u:r.lastSwitchTime},!1,N);if(I?$?q=!0:q=!1:j?q=!1:q=!0,$&&j){const Y=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let S=0;S<l.length;S++){const R=l[S];if(R.x+R.width<w)continue;if(R.x>w)break;const B=this.getObstacleYRangeAt(R,w,u);B&&Y.push(B)}Y.sort((S,R)=>S.top-R.top);const C=[];if(Y.length>0){let S={...Y[0]};for(let R=1;R<Y.length;R++){const B=Y[R];B.top<=S.bottom?S.bottom=Math.max(S.bottom,B.bottom):(C.push(S),S={...B})}C.push(S)}const D=[];for(let S=0;S<C.length-1;S++)D.push({top:C[S].bottom,bottom:C[S+1].top});let G=D[0],E=1/0;for(const S of D){const R=(S.top+S.bottom)/2,B=Math.abs(r.y-R);if(r.y>=S.top&&r.y<=S.bottom){G=S;break}B<E&&(E=B,G=S)}const V=(G.top+G.bottom)/2,K=Math.abs(_-V),U=Math.abs(b-V);K<U?q=!0:U<K?q=!1:q=I}F&&(I&&$&&(q=!0),!I&&j&&(q=!1));const Q=q?[!0,!1]:[!1,!0];for(const Y of Q)if(Y?!L:!z){if(Y!==I&&F&&(I?$:j))continue;const C=Y!==I?u:r.lastSwitchTime;h.push({x:w,y:Y?_:b,time:u,g:v,sm:k,m:H,wa:P,h:Y,pIdx:T,lastSwitchTime:C,prev:r})}if(m>f)break}if(M){const r=[];let y=M;for(;y;)r.push({x:y.x,y:y.y,holding:y.h,time:y.time}),y=y.prev;return this.autoplayLog=r.reverse(),!0}else return this.validationFailureInfo={x:g,y:x,nearObstacles:l.filter(r=>r.x>g-400&&r.x<g+600)},!1}computeAutoplayLog(t=200,a=360){const e=this.computeAutoplayLogGen(t,a);let l=e.next();for(;!l.done;)l=e.next();return l.value}async computeAutoplayLogAsync(t,a,e){const l=this.computeAutoplayLogGen(t,a);let d=l.next(),c=performance.now();for(;!d.done;)typeof d.value=="number"&&performance.now()-c>16&&(e(d.value),await new Promise(s=>setTimeout(s,0)),c=performance.now()),d=l.next();return e(1),d.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,a){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const e=this.baseSpeed*this.speedMultiplier;this.waveSpeed=e;const d=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=e*Math.tan(d),this.playerX+=this.waveSpeed*t;let c=null;if(this.isAutoplay&&this.autoplayLog.length>0){const s=this.playerX;let n=null;for(let o=this.lastAutoplayIndex;o<this.autoplayLog.length;o++){const h=this.autoplayLog[o];if(h&&h.x>=s){n=h,this.lastAutoplayIndex=o;break}}if(n){this.isHolding=n.holding;const o=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(o){const p=(s-o.x)/(n.x-o.x);this.playerY=o.y+(n.y-o.y)*Math.max(0,Math.min(1,p)),c=o.time+(n.time-o.time)*Math.max(0,Math.min(1,p))}else this.playerY=n.y,c=n.time;const h=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=h.map(p=>({x:p.x,y:p.y}))}}else{this.aiPredictedPath=[];const s=this.isHolding?-1:1,n=this.isGravityInverted?-s:s;this.playerY+=this.waveAmplitude*n*t}if(this.playerY<this.minY+this.playerSize){this.playerY=this.minY+this.playerSize,this.die("천장에 충돌!"),this.spawnDeathParticles();return}if(this.playerY>this.maxY-this.playerSize){this.playerY=this.maxY-this.playerSize,this.die("바닥에 충돌!"),this.spawnDeathParticles();return}this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const i=c!==null?c:a;this.updateMovingObstacles(i),this.checkPortalCollisions(),this.checkCollisions(i),this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals)if(!t.activated&&!(t.x+t.width<this.playerX-50)){if(t.x>this.playerX+100)break;this.playerX+this.playerSize>t.x&&this.playerX-this.playerSize<t.x+t.width&&this.playerY+this.playerSize>t.y&&this.playerY-this.playerSize<t.y+t.height&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break}}spawnPortalParticles(t){const a=this.getPortalColor(t.type);for(let e=0;e<10;e++){const l=Math.PI*2*e/10,d=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(l)*d,vy:Math.sin(l)*d,life:.6+Math.random()*.3,color:a})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";default:return"?"}}updateParticles(t){for(let a=this.particles.length-1;a>=0;a--){const e=this.particles[a];e&&(e.x+=e.vx*t,e.y+=e.vy*t,e.vy+=150*t,e.life-=t,e.life<=0&&this.particles.splice(a,1))}}getObstacleYRangeAt(t,a,e){if(a<t.x||a>t.x+t.width)return null;let l=t.y,d=t.angle||0;if(e!==void 0&&t.movement){const c=this.getObstacleStateAt(t,e);l=c.y,d=c.angle}if(t.type==="block"){if(d){const c=d*Math.PI/180,i=t.x+t.width/2,s=l+t.height/2,n=Math.cos(c),o=Math.sin(c),h=t.width/2,p=t.height/2,m=[{dx:-h,dy:-p},{dx:h,dy:-p},{dx:h,dy:p},{dx:-h,dy:p}].map(x=>({x:i+x.dx*n-x.dy*o,y:s+x.dx*o+x.dy*n}));let f=1/0,M=-1/0,g=!1;for(let x=0;x<4;x++){const r=m[x],y=m[(x+1)%4];if(r.x<=a&&a<=y.x||y.x<=a&&a<=r.x){if(Math.abs(r.x-y.x)<.1)f=Math.min(f,r.y,y.y),M=Math.max(M,r.y,y.y);else{const v=(a-r.x)/(y.x-r.x),k=r.y+v*(y.y-r.y);f=Math.min(f,k),M=Math.max(M,k)}g=!0}}return g?{top:f,bottom:M}:null}return{top:l,bottom:l+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const c=l>330,i=t.x+t.width/2;let s;if(a<=i){const n=(a-t.x)/(i-t.x);s=c?l+t.height-n*t.height:l+n*t.height}else{const n=(a-i)/(t.x+t.width-i);s=c?l+(1-n)*0+n*t.height:l+t.height-(1-n)*0-n*t.height,s=c?l+n*t.height:l+t.height-n*t.height}return c?{top:s,bottom:l+t.height}:{top:l,bottom:s}}if(t.type==="slope"){const c=(a-t.x)/t.width;if(d>0){const i=l+t.height*(1-c);return{top:l,bottom:i}}else return{top:l+t.height*c,bottom:l+t.height}}return{top:l,bottom:l+t.height}}checkCollisions(t){for(const a of this.obstacles)if(!(a.x+a.width<this.playerX-80)){if(a.x>this.playerX+100)break;if(this.checkObstacleCollision(a,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,a,e,l,d){let c=t.y,i=t.angle||0;if(d!==void 0&&t.movement){const g=this.getObstacleStateAt(t,d);c=g.y,i=g.angle}const s=10,n=Math.max(t.width,s),o=Math.max(t.height,s),h=t.x-(n-t.width)/2,p=c-(o-t.height)/2,m=i!==0,f=[{x:a-l,y:e-l},{x:a+l,y:e-l},{x:a-l,y:e+l},{x:a+l,y:e+l},{x:a,y:e}];if(m){const g=h+n/2,x=p+o/2,r=-i*Math.PI/180;f.forEach(y=>{const v=y.x-g,k=y.y-x;y.x=g+v*Math.cos(r)-k*Math.sin(r),y.y=x+v*Math.sin(r)+k*Math.cos(r)})}const M=f.some(g=>g.x>=h&&g.x<=h+n&&g.y>=p&&g.y<=p+o);if(!M&&t.type!=="slope"&&t.type!=="spike"&&t.type!=="mini_spike")return!1;if(t.type==="block")return M;if(t.type==="slope"){let g;t.angle>0?g=[{x:h,y:p+o},{x:h+n,y:p},{x:h,y:p}]:g=[{x:h+n,y:p+o},{x:h,y:p},{x:h+n,y:p}];for(const x of f)if(this.isPointInTriangle(x.x,x.y,g[0].x,g[0].y,g[1].x,g[1].y,g[2].x,g[2].y))return!0;return!1}if(t.type==="spike"||t.type==="mini_spike"){const x=p>300?[{x:h,y:p+o},{x:h+n/2,y:p},{x:h+n,y:p+o}]:[{x:h,y:p},{x:h+n/2,y:p+o},{x:h+n,y:p}];for(const r of f)if(this.isPointInTriangle(r.x,r.y,x[0].x,x[0].y,x[1].x,x[1].y,x[2].x,x[2].y))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const g=h+n/2,x=p+o/2,r=n/2*.9;for(const y of f){const v=y.x-g,k=y.y-x;if(v*v+k*k<r*r)return!0}return!1}if(t.type==="laser"){const g=o*.4,x=p+o/2;return f.some(r=>r.x>=h&&r.x<=h+n&&r.y>=x-g&&r.y<=x+g)}if(t.type==="v_laser"){const g=n*.4,x=h+n/2;return f.some(r=>r.y>=p&&r.y<=p+o&&r.x>=x-g&&r.x<=x+g)}return!1}isPointInRotatedRect(t,a,e){const l=(e.angle||0)*Math.PI/180,d=e.x+e.width/2,c=e.y+e.height/2,i=t-d,s=a-c,n=Math.cos(-l),o=Math.sin(-l),h=i*n-s*o,p=i*o+s*n;return Math.abs(h)<=e.width/2&&Math.abs(p)<=e.height/2}removeRedundantObstacles(){const t=new Set,a=this.obstacles.length;for(let e=0;e<a;e++){const l=this.obstacles[e];if(!l.movement)for(let d=0;d<a;d++){if(e===d)continue;const c=this.obstacles[d];if(c.movement)continue;const i=c.angle?Math.max(c.width,c.height):0;if(!(c.x-i>l.x||c.x+c.width+i<l.x+l.width)&&this.isObstacleContained(l,c)){t.add(e);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((e,l)=>!t.has(l)))}isObstacleContained(t,a){if(a.type!=="block"&&a.type!=="spike"&&a.type!=="mini_spike")return!1;const e=this.getObstacleCorners(t);for(const l of e)if(!this.isPointInStaticObstacle(l.x,l.y,a))return!1;return!0}isPointInStaticObstacle(t,a,e){if(e.type==="block")return this.isPointInRotatedRect(t,a,e);if(e.type==="spike"||e.type==="mini_spike"){const l=e.y>300,d=e.x+e.width/2;return l?this.isPointInTriangle(t,a,e.x,e.y+e.height,d,e.y,e.x+e.width,e.y+e.height):this.isPointInTriangle(t,a,e.x,e.y,d,e.y+e.height,e.x+e.width,e.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const a=t.y>300,e=t.x+t.width/2;return a?[{x:t.x,y:t.y+t.height},{x:e,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:e,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const a=t.angle*Math.PI/180,e=t.x+t.width/2,l=t.y+t.height/2,d=Math.cos(a),c=Math.sin(a),i=t.width/2,s=t.height/2;return[{dx:-i,dy:-s},{dx:i,dy:-s},{dx:i,dy:s},{dx:-i,dy:s}].map(n=>({x:e+n.dx*d-n.dy*c,y:l+n.dx*c+n.dy*d}))}return[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,a,e,l,d,c,i,s){const n=Math.abs((e*(c-s)+d*(s-l)+i*(l-c))/2),o=Math.abs((t*(l-c)+e*(c-a)+d*(a-l))/2),h=Math.abs((t*(c-s)+d*(s-a)+i*(a-c))/2),p=Math.abs((t*(s-l)+i*(l-a)+e*(a-s))/2);return Math.abs(n-(o+h+p))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let a=0;a<15;a++){const e=Math.PI*2*a/15,l=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(e)*l,vy:Math.sin(e)*l,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,a){let e=t.y,l=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:d,speed:c,phase:i}=t.movement;e=t.initialY+Math.sin(a*c+i)*d}else if(t.movement.type==="rotate"){const{speed:d,phase:c}=t.movement;l=(a*d+c)*180/Math.PI%360}}return{y:e,angle:l}}updateMovingObstacles(t){for(const a of this.obstacles)if(a.movement){const e=this.getObstacleStateAt(a,t);a.y=e.y,a.movement.type==="rotate"&&(a.angle=e.angle)}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}export{et as G};
