class et{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiPredictedPath=[];constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.reset(),this.initPatterns()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,a=this.mapConfig.difficulty,i=this.basePlayerSize*4;let o=1;a<8?o=2.5-(a-1)/7*.7:a<16?o=1.3-(a-8)/8*.5:a<24?o=.8-(a-16)/8*.35:o=.45-(a-24)/7*.3;let p=1;a<8?p=4:a<16?p=1.5:a<24?p=1.2:p=1;const c=40;for(let e=0;e<10;e++){const s=80+e*12,n=Math.min(s,c),h=s-n,r=[];h>0&&r.push({dx:0,dy:t-h,w:50,h,type:"block"}),r.push({dx:0,dy:t-s,w:50,h:n,type:"spike"}),this.patterns.push({obstacles:r,requiredY:"top",width:60})}for(let e=0;e<10;e++){const s=80+e*12,n=Math.min(s,c),h=s-n,r=[];r.push({dx:0,dy:0,w:50,h:n,type:"spike"}),h>0&&r.push({dx:0,dy:n,w:50,h,type:"block"}),this.patterns.push({obstacles:r,requiredY:"bottom",width:60})}for(let e=0;e<10;e++){const s=120+e*15,n=t/2-s/2;this.patterns.push({obstacles:[{dx:0,dy:n,w:s,h:s,type:"block"}],requiredY:e%2===0?"top":"bottom",width:s+20,type:"square_block"})}for(let e=0;e<10;e++){const s=(160-e*8)*p,n=Math.max(i,s*o),h=(t-n)/2,r=h+n,d=t-r,g=Math.min(h,c),_=Math.min(d,c),k=[{dx:0,dy:Math.max(0,h-g),w:40,h:Math.max(0,g),type:"spike"},{dx:0,dy:r,w:40,h:Math.max(0,_),type:"spike"}];h>g&&k.push({dx:0,dy:0,w:40,h:h-g,type:"block"}),d>_&&k.push({dx:0,dy:r+_,w:40,h:d-_,type:"block"}),this.patterns.push({obstacles:k,requiredY:"middle",width:50})}for(let e=0;e<10;e++){const s=80+e*10,h=["top","middle","bottom"][e%3];let r=t/2-s/2;h==="top"&&(r=s/2+20),h==="bottom"&&(r=t-s-20),this.patterns.push({obstacles:[{dx:0,dy:r,w:s,h:s,type:"saw"}],requiredY:h==="top"?"bottom":h==="bottom"||e%2===0?"top":"bottom",width:s+30})}for(let e=0;e<10;e++){const s=2+Math.floor(e/3),n=[],h=50,r=Math.min(h,c),d=h-r;for(let g=0;g<s;g++)d>0&&n.push({dx:g*40,dy:t-d,w:35,h:d,type:"block"}),n.push({dx:g*40,dy:t-h,w:35,h:r,type:"spike"});this.patterns.push({obstacles:n,requiredY:"top",width:s*40+20})}for(let e=0;e<10;e++){const s=2+Math.floor(e/3),n=[],h=50,r=Math.min(h,c),d=h-r;for(let g=0;g<s;g++)n.push({dx:g*40,dy:0,w:35,h:r,type:"spike"}),d>0&&n.push({dx:g*40,dy:r,w:35,h:d,type:"block"});this.patterns.push({obstacles:n,requiredY:"bottom",width:s*40+20})}for(let e=0;e<10;e++){const s=[],n=100+e*12,h=Math.min(n,c),r=n-h;s.push({dx:0,dy:t-n,w:45,h,type:"spike"}),r>0&&s.push({dx:0,dy:t-r,w:45,h:r,type:"block"}),s.push({dx:60,dy:0,w:45,h,type:"spike"}),r>0&&s.push({dx:60,dy:h,w:45,h:r,type:"block"}),e>=5&&(s.push({dx:120,dy:t-n,w:45,h,type:"spike"}),r>0&&s.push({dx:120,dy:t-r,w:45,h:r,type:"block"})),this.patterns.push({obstacles:s,requiredY:"middle",width:e>=5?180:120})}for(let e=0;e<10;e++){const s=40+e*35,n=(100-e*4)*p,h=Math.max(i,n*o);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:s,type:"block"},{dx:0,dy:s+h,w:40,h:Math.max(0,t-s-h),type:"block"}],requiredY:s<t/3?"top":s>t*2/3-h?"bottom":"middle",width:50,type:"corridor"})}for(let e=0;e<10;e++){const s=[],h=Math.min(70,c),r=70-h;e%2===0?(s.push({dx:0,dy:t-70,w:50,h,type:"spike"}),r>0&&s.push({dx:0,dy:t-r,w:50,h:r,type:"block"}),s.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),s.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(s.push({dx:0,dy:0,w:50,h,type:"spike"}),r>0&&s.push({dx:0,dy:h,w:50,h:r,type:"block"}),s.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),s.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:s,requiredY:e%2===0?"top":"bottom",width:80})}for(let e=0;e<10;e++){const r=["top","middle","bottom"][e%3];let d=t/2-15/2;r==="top"&&(d=60),r==="bottom"&&(d=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:d,w:200,h:15,type:"laser"}],requiredY:r==="top"?"bottom":r==="bottom"||e%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let e=0;e<10;e++){const n=e%2===0?"saw":"spike_ball",h=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:h,w:60,h:60,type:n,movement:{type:"updown",range:100+e*10,speed:1+e*.25,phase:e*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let e=0;e<10;e++){const s=3+Math.floor(e/3),n=[];for(let h=0;h<s;h++){const r=50+h*120%(t-100);n.push({dx:h*80,dy:r,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:n,requiredY:"middle",width:s*80,type:"spike_ball_field"})}for(let e=0;e<10;e++){const h=100+e*100%(t-200),r=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h,type:"v_laser"},{dx:0,dy:h+r,w:15,h:t-(h+r),type:"v_laser"}],requiredY:h<t/3?"top":h>t*2/3-r?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let e=0;e<10;e++){const s=2+Math.floor(e/2),n=[];for(let h=0;h<s;h++){const r=100+Math.random()*(t-200),d=h*60;n.push({dx:d,dy:r,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:h}})}this.patterns.push({obstacles:n,requiredY:"middle",width:s*60+50,type:"mine_field"})}for(let e=0;e<10;e++){const n=t/2-60,h=[];h.push({dx:0,dy:n,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+e*.1,phase:0}}),this.patterns.push({obstacles:h,requiredY:e%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let e=0;e<10;e++){const s=[],n=t/2-25;s.push({dx:50,dy:n,w:50,h:50,type:"orb"}),s.push({dx:50,dy:0,w:50,h:60,type:"spike"}),s.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:s,requiredY:"middle",width:150})}for(let e=0;e<10;e++){const s=[],n=t/2-20;s.push({dx:0,dy:n,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),s.push({dx:0,dy:n,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:s,requiredY:"middle",width:300,type:"windmill"})}for(let e=0;e<10;e++){const s=[],n=3+e%3;for(let h=0;h<n;h++)s.push({dx:h*40,dy:100+h*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:s,requiredY:"middle",width:n*40,type:"mine_cluster"})}for(let e=0;e<10;e++){const s=[];for(let h=0;h<4;h++)s.push({dx:h*50,dy:50+h*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:s,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.speedMultiplier=1,this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){this.obstacles=t.engineObstacles.map(a=>({...a})),this.portals=t.enginePortals.map(a=>({...a,activated:!1})),this.autoplayLog=[...t.autoplayLog],this.totalLength=t.duration*this.baseSpeed+500}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,a,i,o,p=!0,c=0,e=120,s=2){this.bpm=e,this.measureLength=s;const n=o||t.length*777+Math.floor(i*100),h=p?10:1;for(let r=0;r<h;r++){const d=r+c;this.patternGapMultiplier=Math.pow(1.2,d),this.initPatterns(),this.obstacles=[],this.portals=[],this.trackDuration=i,this.totalLength=i*this.baseSpeed+500,this.autoplayLog=[];let g=this.seededRandom(n+d);if(this.generatePatternBasedMap(t,a,g),this.obstacles.sort((k,I)=>k.x-I.x),this.portals.sort((k,I)=>k.x-I.x),this.removeRedundantObstacles(),!p){console.log(`[MapGen] Map generated quickly with seed: ${n}`);return}if(this.computeAutoplayLog(200,360)){console.log(`[MapGen] Map generated with seed: ${n}, attempt: ${r+1}, gapMultiplier: ${this.patternGapMultiplier.toFixed(2)}`);return}console.log(`[MapGen] AI path failed at attempt ${r+1}, increasing gap...`)}console.warn(`[MapGen] All ${h} attempts failed. Using last generated map.`)}generatePatternBasedMap(t,a,i){const{density:o,portalFrequency:p}=this.mapConfig;let c=0;this.mapConfig.difficulty>=24;let e=200,s=!1,n=!1,h=0,r=0,d="middle",g="speed_1",_;const k=[],A=60/this.bpm*4,l=t.length>0?Math.max(.5,t[0]):.5;for(let f=l;f<this.trackDuration;f+=A)k.push(f);console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${A.toFixed(3)}s, Total Measures: ${k.length}`);const y=[];k.forEach((f,w)=>{const M=a?.find(x=>f>=x.startTime&&f<x.endTime);y.push({time:f,type:"measure",data:{measureIndex:w,intensity:M?.intensity||.5}})}),t.forEach(f=>y.push({time:f,type:"beat",data:f})),y.sort((f,w)=>f.time-w.time);for(const f of y){const w=f.time-c;if(w>0){const M=this.getSpeedMultiplierFromType(g);e+=w*this.baseSpeed*M,c=f.time}if(f.type==="measure"){const x=f.data.intensity||.5;if(f.time<.5)continue;const u=this.mapConfig.difficulty;let m;if(u<8)x<.4?m="speed_0.5":x<.7?m="speed_1":m="speed_2";else if(u<16)x<.6?m="speed_1":m="speed_2";else if(u<24)x<.3?m="speed_0.5":x<.65?m="speed_2":m="speed_3";else{const v=i();x>.85?m="speed_4":v<.2?m="speed_0.5":v<.35?m="speed_0.25":v<.6?m="speed_3":m="speed_4"}const T=[];let L=e;(m!==g||r===0)&&(T.push(m),g=m);const H=u>=24?.9:u<8?.35:.75;if(i()<H&&u>=3){const v=i()>.5;v!==n&&(T.push(v?"gravity_yellow":"gravity_blue"),n=v)}const S=u>=24?.3:.8;this.mapConfig.difficulty>=2&&(u>=24?i()>.4&&(T.push(s?"mini_green":"mini_pink"),s=!s):(x>S||x>.6&&i()<.4)&&(T.push(s?"mini_green":"mini_pink"),s=!s)),T.length>0&&(this.generatePortalWithType(L,T[0],i,T.slice(1)),r=L)}else{const M=f.time;if(M<.4)continue;const x=this.getSpeedMultiplierFromType(g),u=Math.max(1,this.mapConfig.difficulty);let m;u<8?m=1.5-(u-1)/7*.5:u<16?m=.6-(u-8)/8*.2:u<24?m=.35-(u-16)/8*.17:m=.12-(u-24)/6*.07,m*=this.patternGapMultiplier,m*=Math.pow(x,.6),m*=.8,u>=16&&u<24&&g==="speed_0.5"&&(m*=.4),u>=24?g==="speed_0.25"||g==="speed_0.5"?m*=.15:s?m*=1.4:(m*=.85,n&&(m*=.95)):u>=16?(m*=.95,s&&(m*=1.1)):s&&(m*=1.25);const T=e,H=(u>=24?180:u>=16?220:u<8?600:280)*m/(this.baseSpeed*x);if(M<h+H)continue;let S=this.getValidPatterns(d,i,_);if(u<8&&(S=S.filter(b=>!b.type?.includes("laser")&&!b.type?.includes("moving")&&!b.type?.includes("spike_ball")&&!b.type?.includes("mine")&&!b.type?.includes("orb"))),S.length===0)continue;let v;if(i()<.2){const b=2+Math.floor(i()*3),X=this.maxY-this.minY,W=["orb","mine","saw","mini_spike","spike_ball"];for(let $=0;$<b;$++){const C=W[Math.floor(i()*W.length)],B=50+i()*(X-100),j=30+i()*20;this.obstacles.push({x:e+$*50,y:this.minY+B,width:j,height:j,type:C,initialY:this.minY+B,movement:{type:"none",range:0,speed:0,phase:0}})}h=M+b*50/(this.baseSpeed*x);continue}const O=S.map(b=>{let X=1;const W=b.type||"";return(W.includes("mine")||W.includes("orb")||W.includes("cluster")||W.includes("field"))&&(X=4),W.includes("mini_spike")&&(X=2.5),(W==="square_block"||W==="corridor")&&(X=.25),{p:b,weight:X}}),z=O.reduce((b,X)=>b+X.weight,0);let q=i()*z;v=O[0].p;for(const b of O)if(q-=b.weight,q<=0){v=b.p;break}if(v.type==="square_block"){const b=900*x;if(Math.abs(T-r)<b)continue}else{const b=.4*this.baseSpeed*x;if(Math.abs(T-r)<b)continue}this.placePatternWithScale(v,T,x,s,m),h=M+v.width*m/(this.baseSpeed*x),d=v.requiredY,_=v.type;const G=v.type==="square_block"?600:50;if(e-r>800*x&&i()<p*2.8){const b=i()>.5?"gravity_yellow":"gravity_blue",X=v.width*m;this.generatePortalWithType(e+X+G,b,i),r=e+X+G}}}this.totalLength=e+800}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,a){return t?a>=1.9?78:a>=1.7?72:60:45}getValidPatterns(t,a,i){const p={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let c=this.patterns.filter(e=>p.includes(e.requiredY));return i==="corridor"&&(c=c.filter(e=>e.type!=="corridor")),c}placePattern(t,a){const i=this.minY;for(const o of t.obstacles)this.obstacles.push({x:a+o.dx,y:i+o.dy,width:o.w,height:o.h,type:o.type,initialY:i+o.dy})}placePatternWithScale(t,a,i,o,p){const c=this.minY,e=this.maxY-this.minY;let s=1;i>1.2&&(s*=.85),i<.8&&(s*=1.15),o&&(s*=.75);for(const n of t.obstacles){let h=n.h*s,r=n.w*s,d=n.dy;if(n.dy<e/2)d=n.dy*s;else{const _=e-(n.dy+n.h);d=e-_*s-h}this.obstacles.push({x:a+n.dx*p,y:c+d,width:r,height:h,type:n.type,angle:n.angle,movement:n.movement?{...n.movement}:void 0,initialY:c+d})}}generatePortalWithType(t,a,i,o=[]){const s=this.maxY-this.minY,n=this.minY+80+i()*(s-160),h=[a,...o],r=h.length*50+(h.length-1)*40;h.forEach((k,I)=>{this.portals.push({x:t+I*90,y:n-100/2,width:50,height:100,type:k,activated:!1})});const d=this.basePlayerSize*2.2,g=n-100/2,_=n+100/2;g>this.minY+d&&this.obstacles.push({x:t-10,y:this.minY,width:r+20,height:g-this.minY-d,type:"block",initialY:this.minY}),_<this.maxY-d&&this.obstacles.push({x:t-10,y:_+d,width:r+20,height:this.maxY-(_+d),type:"block",initialY:_+d})}generatePortal(t,a){let i=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"];const o=this.mapConfig.difficulty;o<8?i=i.filter(e=>!["speed_2","speed_3","speed_4"].includes(e)):o<16?i=i.filter(e=>!["speed_3","speed_4"].includes(e)):o<24&&(i=i.filter(e=>e!=="speed_4"));const p=i.filter(e=>e==="gravity_blue"?this.portals.some(s=>s.type==="gravity_yellow"):!0),c=p[Math.floor(a()*p.length)]||"speed_1";this.generatePortalWithType(t,c,a)}*computeAutoplayLogGen(t,a){this.autoplayLog=[],this.validationFailureInfo=null;const i=1/30,o=[...this.obstacles].sort((l,y)=>l.x-y.x),p=[...this.portals].sort((l,y)=>l.x-y.x),c={x:t,y:a,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},e=new Set,s=l=>{const y=Math.floor(l.x/(this.baseSpeed*.033)),f=Math.floor(l.y/12);return`${y}_${f}_${l.g?1:0}_${Math.round(l.sm*10)}_${l.m?1:0}`},n=(l,y,f,w,M=0)=>{if(y<this.minY+f||y>this.maxY-f)return!0;for(let x=0;x<o.length;x++){const u=o[x];if(u.x+u.width<l-50)continue;if(u.x>l+100)break;const m=u.movement?2:0;if(this.checkObstacleCollision(u,l,y,f+M+m,w))return!0}return!1},h=(l,y,f)=>{let w=l.x,M=l.y,x=l.g,u=l.sm,m=l.wa,T=l.m,L=l.pIdx,H=l.time;for(let S=0;S<f;S++){for(;L<p.length&&w>=p[L].x;){const q=p[L];M>=q.y&&M<=q.y+q.height&&(q.type==="gravity_yellow"&&(x=!0),q.type==="gravity_blue"&&(x=!1),q.type.startsWith("speed_")&&(u=this.getSpeedMultiplierFromType(q.type)),q.type==="mini_pink"&&(T=!0),q.type==="mini_green"&&(T=!1),m=this.getEffectiveAngle(T,u)),L++}const v=this.baseSpeed*u,F=v*Math.tan(m*Math.PI/180),O=T?this.miniPlayerSize:this.basePlayerSize;if(w+=v*i,H+=i,M+=F*(x?y?1:-1:y?-1:1)*i,n(w,M,O,H,3))return!1}return!0},r=[c];let d=t,g=0;const _=25e4;let k=null,I=t,A=a;for(;r.length>0;){g++;const l=r.pop();if(l.x>d&&(d=l.x,g%500===0&&(yield d/this.totalLength)),l.x>=this.totalLength){k=l;break}const y=s(l);if(e.has(y))continue;e.add(y);let f=l.g,w=l.sm,M=l.m,x=l.wa,u=l.pIdx;for(;u<p.length&&l.x>=p[u].x;){const Y=p[u];l.y>=Y.y&&l.y<=Y.y+Y.height&&(Y.type==="gravity_yellow"&&(f=!0),Y.type==="gravity_blue"&&(f=!1),Y.type.startsWith("speed_")&&(w=this.getSpeedMultiplierFromType(Y.type)),Y.type==="mini_pink"&&(M=!0),Y.type==="mini_green"&&(M=!1),x=this.getEffectiveAngle(M,w)),u++}const m=this.baseSpeed*w,T=m*Math.tan(x*Math.PI/180),L=M?this.miniPlayerSize:this.basePlayerSize,H=l.time+i,S=l.x+m*i,v=l.y+T*(f?1:-1)*i,F=l.y+T*(f?-1:1)*i;let O=n(S,v,L,H,3),z=n(S,F,L,H,3);const q=L*.8;!O&&Math.abs(v-l.y)>q&&n((l.x+S)/2,(l.y+v)/2,L,l.time+i/2,3)&&(O=!0),!z&&Math.abs(F-l.y)>q&&n((l.x+S)/2,(l.y+F)/2,L,l.time+i/2,3)&&(z=!0),O&&z&&S>I&&(I=S,A=l.y);const G=l.h,b=45,X=.125/Math.pow(l.sm,.7);let $=l.time-l.lastSwitchTime<X;if($){const Y=l.y;if(Math.abs(Y-360)>25){const N=l.g,V=G,K=N?V?1:-1:V?-1:1;(Y>360&&K>0||Y<360&&K<0)&&($=!1)}}let C=!1;const B=!O&&h({...l,x:S,y:v,time:H,g:f,sm:w,m:M,wa:x,pIdx:u,lastSwitchTime:G?l.lastSwitchTime:H},!0,b),j=!z&&h({...l,x:S,y:F,time:H,g:f,sm:w,m:M,wa:x,pIdx:u,lastSwitchTime:G?H:l.lastSwitchTime},!1,b);if(G?B?C=!0:C=!1:j?C=!1:C=!0,B&&j){const Y=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let P=0;P<o.length;P++){const R=o[P];if(R.x+R.width<S)continue;if(R.x>S)break;const D=this.getObstacleYRangeAt(R,S,H);D&&Y.push(D)}Y.sort((P,R)=>P.top-R.top);const E=[];if(Y.length>0){let P={...Y[0]};for(let R=1;R<Y.length;R++){const D=Y[R];D.top<=P.bottom?P.bottom=Math.max(P.bottom,D.bottom):(E.push(P),P={...D})}E.push(P)}const N=[];for(let P=0;P<E.length-1;P++)N.push({top:E[P].bottom,bottom:E[P+1].top});let V=N[0],K=1/0;for(const P of N){const R=(P.top+P.bottom)/2,D=Math.abs(l.y-R);if(l.y>=P.top&&l.y<=P.bottom){V=P;break}D<K&&(K=D,V=P)}const U=(V.top+V.bottom)/2,J=Math.abs(v-U),Q=Math.abs(F-U);J<Q?C=!0:Q<J?C=!1:C=G}$&&(G&&B&&(C=!0),!G&&j&&(C=!1));const Z=C?[!0,!1]:[!1,!0];for(const Y of Z)if(Y?!O:!z){if(Y!==G&&$&&(G?B:j))continue;const E=Y!==G?H:l.lastSwitchTime;r.push({x:S,y:Y?v:F,time:H,g:f,sm:w,m:M,wa:x,h:Y,pIdx:u,lastSwitchTime:E,prev:l})}if(g>_)break}if(k){const l=[];let y=k;for(;y;)l.push({x:y.x,y:y.y,holding:y.h,time:y.time}),y=y.prev;return this.autoplayLog=l.reverse(),!0}else return this.validationFailureInfo={x:I,y:A,nearObstacles:o.filter(l=>l.x>I-400&&l.x<I+600)},!1}computeAutoplayLog(t=200,a=360){const i=this.computeAutoplayLogGen(t,a);let o=i.next();for(;!o.done;)o=i.next();return o.value}async computeAutoplayLogAsync(t,a,i){const o=this.computeAutoplayLogGen(t,a);let p=o.next(),c=performance.now();for(;!p.done;)typeof p.value=="number"&&performance.now()-c>16&&(i(p.value),await new Promise(s=>setTimeout(s,0)),c=performance.now()),p=o.next();return i(1),p.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,a){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const i=this.baseSpeed*this.speedMultiplier;this.waveSpeed=i;const p=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=i*Math.tan(p),this.playerX+=this.waveSpeed*t;let c=null;if(this.isAutoplay&&this.autoplayLog.length>0){const s=this.playerX;let n=null;for(let h=this.lastAutoplayIndex;h<this.autoplayLog.length;h++){const r=this.autoplayLog[h];if(r&&r.x>=s){n=r,this.lastAutoplayIndex=h;break}}if(n){this.isHolding=n.holding;const h=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(h){const d=(s-h.x)/(n.x-h.x);this.playerY=h.y+(n.y-h.y)*Math.max(0,Math.min(1,d)),c=h.time+(n.time-h.time)*Math.max(0,Math.min(1,d))}else this.playerY=n.y,c=n.time;const r=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=r.map(d=>({x:d.x,y:d.y}))}}else{this.aiPredictedPath=[];const s=this.isHolding?-1:1,n=this.isGravityInverted?-s:s;this.playerY+=this.waveAmplitude*n*t}if(this.playerY<this.minY+this.playerSize){this.playerY=this.minY+this.playerSize,this.die("천장에 충돌!"),this.spawnDeathParticles();return}if(this.playerY>this.maxY-this.playerSize){this.playerY=this.maxY-this.playerSize,this.die("바닥에 충돌!"),this.spawnDeathParticles();return}this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const e=c!==null?c:a;this.updateMovingObstacles(e),this.checkPortalCollisions(),this.checkCollisions(e),this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals)if(!t.activated&&!(t.x+t.width<this.playerX-50)){if(t.x>this.playerX+100)break;this.playerX+this.playerSize>t.x&&this.playerX-this.playerSize<t.x+t.width&&this.playerY+this.playerSize>t.y&&this.playerY-this.playerSize<t.y+t.height&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break}}spawnPortalParticles(t){const a=this.getPortalColor(t.type);for(let i=0;i<10;i++){const o=Math.PI*2*i/10,p=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(o)*p,vy:Math.sin(o)*p,life:.6+Math.random()*.3,color:a})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";default:return"?"}}updateParticles(t){for(let a=this.particles.length-1;a>=0;a--){const i=this.particles[a];i&&(i.x+=i.vx*t,i.y+=i.vy*t,i.vy+=150*t,i.life-=t,i.life<=0&&this.particles.splice(a,1))}}getObstacleYRangeAt(t,a,i){if(a<t.x||a>t.x+t.width)return null;let o=t.y,p=t.angle||0;if(i!==void 0&&t.movement){const c=this.getObstacleStateAt(t,i);o=c.y,p=c.angle}if(t.type==="block"){if(p){const c=p*Math.PI/180,e=t.x+t.width/2,s=o+t.height/2,n=Math.cos(c),h=Math.sin(c),r=t.width/2,d=t.height/2,g=[{dx:-r,dy:-d},{dx:r,dy:-d},{dx:r,dy:d},{dx:-r,dy:d}].map(A=>({x:e+A.dx*n-A.dy*h,y:s+A.dx*h+A.dy*n}));let _=1/0,k=-1/0,I=!1;for(let A=0;A<4;A++){const l=g[A],y=g[(A+1)%4];if(l.x<=a&&a<=y.x||y.x<=a&&a<=l.x){if(Math.abs(l.x-y.x)<.1)_=Math.min(_,l.y,y.y),k=Math.max(k,l.y,y.y);else{const f=(a-l.x)/(y.x-l.x),w=l.y+f*(y.y-l.y);_=Math.min(_,w),k=Math.max(k,w)}I=!0}}return I?{top:_,bottom:k}:null}return{top:o,bottom:o+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const c=o>330,e=t.x+t.width/2;let s;if(a<=e){const n=(a-t.x)/(e-t.x);s=c?o+t.height-n*t.height:o+n*t.height}else{const n=(a-e)/(t.x+t.width-e);s=c?o+(1-n)*0+n*t.height:o+t.height-(1-n)*0-n*t.height,s=c?o+n*t.height:o+t.height-n*t.height}return c?{top:s,bottom:o+t.height}:{top:o,bottom:s}}return{top:o,bottom:o+t.height}}checkCollisions(t){for(const a of this.obstacles)if(!(a.x+a.width<this.playerX-80)){if(a.x>this.playerX+100)break;if(this.checkObstacleCollision(a,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,a,i,o,p){let c=t.y,e=t.angle||0;if(p!==void 0&&t.movement){const l=this.getObstacleStateAt(t,p);c=l.y,e=l.angle}const s=10,n=Math.max(t.width,s),h=Math.max(t.height,s),r=(n-t.width)/2,d=(h-t.height)/2,g=t.x-r,_=c-d,k=e!==0,I=k?Math.max(n,h):0;if(a+o<=g-I||a-o>=g+n+I||i+o<=_-I||i-o>=_+h+I)return!1;const A=[{x:a-o,y:i-o},{x:a+o,y:i-o},{x:a-o,y:i+o},{x:a+o,y:i+o},{x:a,y:i}];if(k&&t.type==="block"){const l={...t,y:c,angle:e};for(const y of A)if(this.isPointInRotatedRect(y.x,y.y,l))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const l=t.x+t.width/2,y=c+t.height/2;let f=.9;t.type==="spike_ball"&&(f=.85),t.type==="mine"&&(f=.9),t.type==="orb"&&(f=.95);const w=t.width/2*f;for(const M of A){const x=M.x-l,u=M.y-y;if(x*x+u*u<w*w)return!0}return!1}if(t.type==="laser"){const l=t.height*.4,y=c+t.height/2;return a+o>t.x&&a-o<t.x+t.width&&i+o>y-l&&i-o<y+l}if(t.type==="v_laser"){const l=t.width*.4,y=t.x+t.width/2;return i+o>c&&i-o<c+t.height&&a+o>y-l&&a-o<y+l}if(t.type==="spike"||t.type==="mini_spike"){const l=c>300,y=t.x+t.width/2,f=7;if(l){for(const w of A)if(this.isPointInTriangle(w.x,w.y,t.x+f,c+t.height-f,y,c+f,t.x+t.width-f,c+t.height-f))return!0}else for(const w of A)if(this.isPointInTriangle(w.x,w.y,t.x+f,c+f,y,c+t.height-f,t.x+t.width-f,c+f))return!0;return!1}return a+o>t.x&&a-o<t.x+t.width&&i+o>c&&i-o<c+t.height}isPointInRotatedRect(t,a,i){const o=(i.angle||0)*Math.PI/180,p=i.x+i.width/2,c=i.y+i.height/2,e=t-p,s=a-c,n=Math.cos(-o),h=Math.sin(-o),r=e*n-s*h,d=e*h+s*n;return Math.abs(r)<=i.width/2&&Math.abs(d)<=i.height/2}removeRedundantObstacles(){const t=new Set,a=this.obstacles.length;for(let i=0;i<a;i++){const o=this.obstacles[i];if(!o.movement)for(let p=0;p<a;p++){if(i===p)continue;const c=this.obstacles[p];if(c.movement)continue;const e=c.angle?Math.max(c.width,c.height):0;if(!(c.x-e>o.x||c.x+c.width+e<o.x+o.width)&&this.isObstacleContained(o,c)){t.add(i);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((i,o)=>!t.has(o)))}isObstacleContained(t,a){if(a.type!=="block"&&a.type!=="spike"&&a.type!=="mini_spike")return!1;const i=this.getObstacleCorners(t);for(const o of i)if(!this.isPointInStaticObstacle(o.x,o.y,a))return!1;return!0}isPointInStaticObstacle(t,a,i){if(i.type==="block")return this.isPointInRotatedRect(t,a,i);if(i.type==="spike"||i.type==="mini_spike"){const o=i.y>300,p=i.x+i.width/2;return o?this.isPointInTriangle(t,a,i.x,i.y+i.height,p,i.y,i.x+i.width,i.y+i.height):this.isPointInTriangle(t,a,i.x,i.y,p,i.y+i.height,i.x+i.width,i.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const a=t.y>300,i=t.x+t.width/2;return a?[{x:t.x,y:t.y+t.height},{x:i,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:i,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const a=t.angle*Math.PI/180,i=t.x+t.width/2,o=t.y+t.height/2,p=Math.cos(a),c=Math.sin(a),e=t.width/2,s=t.height/2;return[{dx:-e,dy:-s},{dx:e,dy:-s},{dx:e,dy:s},{dx:-e,dy:s}].map(n=>({x:i+n.dx*p-n.dy*c,y:o+n.dx*c+n.dy*p}))}return[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,a,i,o,p,c,e,s){const n=Math.abs((i*(c-s)+p*(s-o)+e*(o-c))/2),h=Math.abs((t*(o-c)+i*(c-a)+p*(a-o))/2),r=Math.abs((t*(c-s)+p*(s-a)+e*(a-c))/2),d=Math.abs((t*(s-o)+e*(o-a)+i*(a-s))/2);return Math.abs(n-(h+r+d))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let a=0;a<15;a++){const i=Math.PI*2*a/15,o=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(i)*o,vy:Math.sin(i)*o,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,a){let i=t.y,o=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:p,speed:c,phase:e}=t.movement;i=t.initialY+Math.sin(a*c+e)*p}else if(t.movement.type==="rotate"){const{speed:p,phase:c}=t.movement;o=(a*p+c)*180/Math.PI%360}}return{y:i,angle:o}}updateMovingObstacles(t){for(const a of this.obstacles)if(a.movement){const i=this.getObstacleStateAt(a,t);a.y=i.y,a.movement.type==="rotate"&&(a.angle=i.angle)}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}export{et as G};
