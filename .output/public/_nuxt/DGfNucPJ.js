class nt{calculateGap(t,s){let e;return t<=7?e=580-(t-1)*20:t<=15?e=460-(t-8)*17.5:t<=23?e=320-(t-16)*17.5:e=180-(t-24)*15,e=Math.max(90,e),s?e*1.5:e}generateFromPath(t,s,e,r=[]){if(!t||t.length<2)return[];const d=[],l=50,a=this.calculateGap(s,!1),n=Math.floor(t[0].x/l)*l,h=t[t.length-1].x;if(isNaN(n)||isNaN(h)||h<=n)return[];const f=10,o=["spike","piston_v","hammer","growing_spike","cannon","crusher_jaw"],c=["spike","falling_spike","hammer","swing_blade","piston_v","crusher_jaw"],g=["mine","rotor","spark_mine","laser_beam","planet","star"],y=(S,D,I)=>{let H=Array(D).fill([]).map(()=>[]),R=[...S];const L=D*I;for(;R.length<L;)R.push(S[Math.floor(Math.random()*S.length)]);for(let C=R.length-1;C>0;C--){const F=Math.floor(Math.random()*(C+1));[R[C],R[F]]=[R[F],R[C]]}for(let C=0;C<D;C++)H[C]=R.slice(C*I,(C+1)*I);return H},Y=y(o,f,2),u=y(c,f,2),m=y(g,f,2);let w=Math.floor((t[0].y+a/2)/l)*l,p=Math.floor((t[0].y-a/2)/l)*l,k=0,_=0;e.sort((S,D)=>S-D);let B=0,A=!1,X=a*(1/1.4);for(let S=n;S<h;S+=l){const D=S+l/2;for(;k<t.length-1&&t[k+1].x<D;)k++;const I=t[k];if(!I)continue;const H=k<t.length-1?t[k+1]:I,R=I.time;for(;B<r.length&&r[B].time<=R;)A=r[B].isMini,B++;A?X=a*1.3:X=a;const L=X/2,C=S+l;let F=k;for(;F<t.length-1&&t[F+1].x<C;)F++;const O=t[F],V=O.y+L,M=O.y-L;let v=0,P=0;const G=10,E=35,W=V-w;A?W<-l*1.5?v=-l*2:W<-35?v=-l:W>l*1.5?v=l*2:W>G&&(v=l):W<-35?v=-l:W>G&&(v=l);const T=M-p;if(A?T<-l*1.5?P=-l*2:T<-10?P=-l:T>l*1.5?P=l*2:T>E&&(P=l):T<-10?P=-l:T>E&&(P=l),v<0){const j=v===-l*2?"steep_triangle":"triangle",$=Math.abs(v);w+=v;const N=w;d.push({type:j,x:S,y:N,width:l,height:$,rotation:0}),this.fillBelow(d,S,N+$,l)}else if(v>0){const j=v===l*2?"steep_triangle":"triangle",$=Math.abs(v),N=w;d.push({type:j,x:S,y:N,width:l,height:$,rotation:90}),this.fillBelow(d,S,N+$,l),w+=v}else{const x=w;d.push({type:"block",x:S,y:x,width:l,height:l}),this.fillBelow(d,S,x+l,l)}if(P<0){const j=P===-l*2?"steep_triangle":"triangle",$=Math.abs(P);p+=P;const N=p;d.push({type:j,x:S,y:N,width:l,height:$,rotation:180}),this.fillAbove(d,S,N,l)}else if(P>0){const j=P===l*2?"steep_triangle":"triangle",$=Math.abs(P),N=p;d.push({type:j,x:S,y:N,width:l,height:$,rotation:-90}),this.fillAbove(d,S,N,l),p+=P}else{const x=p-l;d.push({type:"block",x:S,y:x,width:l,height:l}),this.fillAbove(d,S,x,l)}const Z=Math.abs(Math.sin(S*.123+w*.456));if(v===0&&X>100&&Z<.2){let x=40;s<=5?x=20:s<=10&&(x=30);const j=Math.min(Math.max((S-n)/(h-n),0),.999),$=Math.floor(j*f),N=Y[$],b=u[$];let z=N[Math.floor(Math.random()*N.length)]||"spike",U=b[Math.floor(Math.random()*b.length)]||"spike";z==="spike"&&s<=8&&(z="mini_spike"),U==="spike"&&s<=8&&(U="mini_spike"),Z<.1?I.y<w-x-40&&w-x>p+40&&d.push({type:z,x:S,y:w-x,width:l,height:x}):I.y>p+x+40&&p+x<w-40&&d.push({type:U,x:S,y:p,width:l,height:x,rotation:180})}if(Z>.95&&X>200){const x=s<=7?20:30,j=(w+p)/2;let $=j;I.y<j?$=j+(w-j)*.5:$=j-(j-p)*.5;const N=Math.min(Math.max((S-n)/(h-n),0),.999),b=Math.floor(N*f),z=m[b],K=z[Math.floor(Math.random()*z.length)]||"mine";let Q,it;if(K==="planet"){it={orbitSpeed:1.5,orbitDistance:x*.8,orbitCount:2},Q=[];for(let et=0;et<2;et++)Q.push({type:"planet",x:0,y:0,width:x*.4,height:x*.4,isHitbox:!0})}else if(K==="star"){it={orbitSpeed:1,orbitDistance:x*.8,orbitCount:3},Q=[];for(let et=0;et<3;et++)Q.push({type:"planet",x:0,y:0,width:x*.5,height:x*.5,isHitbox:!0})}d.push({type:K,x:S+10,y:$-x/2,width:x,height:x,isHitbox:!0,rotation:K==="laser_beam"?90:0,children:Q,customData:it})}for(;_<e.length&&e[_]<I.time;)_++;for(;_<e.length&&e[_]<=H.time;){const x=(w+p)/2-40;x>=p&&x+80<=w&&d.push({type:"orb",x:S+25,y:x,width:80,height:80,isHitbox:!1}),_++}}return d.filter(S=>(["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green"].includes(S.type)||S.isHitbox===!0,!0))}fillBelow(t,s,e,r){const l=1e3-e;l>0&&t.push({type:"block",x:s,y:e,width:r,height:l,isHitbox:!0})}fillAbove(t,s,e,r){const a=e- -500;a>0&&t.push({type:"block",x:s,y:-500,width:r,height:a,isHitbox:!0})}}class lt{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;getDynamicBaseSpeed(){const t=this.mapConfig.difficulty;return t<=2?260:t<=7?300:t<=12?330:350}isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiPredictedPath=[];beatTimes=[];boss={active:!1,x:0,y:0,health:100,maxHealth:100,state:"idle",attackTimer:0,projectiles:[]};lastStateEvents=[];lastBeatActions=[];lastMeasureIndex=-1;isMeasureHighlight=!1;onPortalActivation=null;constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.baseSpeed=this.getDynamicBaseSpeed(),this.reset()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,s=this.mapConfig.difficulty,e=this.basePlayerSize*4;let r=1;s<8?r=2.5-(s-1)/7*.7:s<16?r=1.3-(s-8)/8*.5:s<24?r=.8-(s-16)/8*.35:r=.45-(s-24)/7*.3;let d=1;s<8?d=4:s<16?d=1.5:s<24?d=1.2:d=1;const l=40;for(let a=0;a<10;a++){const n=80+a*12,h=Math.min(n,l),f=n-h,o=[];f>0&&o.push({dx:0,dy:t-f,w:50,h:f,type:"block"}),o.push({dx:0,dy:t-n,w:50,h,type:"spike"}),this.patterns.push({obstacles:o,requiredY:"top",width:60})}for(let a=0;a<10;a++){const n=80+a*12,h=Math.min(n,l),f=n-h,o=[];o.push({dx:0,dy:0,w:50,h,type:"spike"}),f>0&&o.push({dx:0,dy:h,w:50,h:f,type:"block"}),this.patterns.push({obstacles:o,requiredY:"bottom",width:60})}for(let a=0;a<10;a++){const n=120+a*15,h=t/2-n/2;this.patterns.push({obstacles:[{dx:0,dy:h,w:n,h:n,type:"block"}],requiredY:a%2===0?"top":"bottom",width:n+20,type:"square_block"})}for(let a=0;a<10;a++){const n=(160-a*8)*d,h=Math.max(e,n*r),f=(t-h)/2,o=f+h,c=t-o,g=Math.min(f,l),y=Math.min(c,l),Y=[{dx:0,dy:Math.max(0,f-g),w:40,h:Math.max(0,g),type:"spike"},{dx:0,dy:o,w:40,h:Math.max(0,y),type:"spike"}];f>g&&Y.push({dx:0,dy:0,w:40,h:f-g,type:"block"}),c>y&&Y.push({dx:0,dy:o+y,w:40,h:c-y,type:"block"}),this.patterns.push({obstacles:Y,requiredY:"middle",width:50})}for(let a=0;a<10;a++){const n=80+a*10,f=["top","middle","bottom"][a%3];let o=t/2-n/2;f==="top"&&(o=n/2+20),f==="bottom"&&(o=t-n-20),this.patterns.push({obstacles:[{dx:0,dy:o,w:n,h:n,type:"saw"}],requiredY:f==="top"?"bottom":f==="bottom"||a%2===0?"top":"bottom",width:n+30})}for(let a=0;a<10;a++){const n=2+Math.floor(a/3),h=[],f=50,o=Math.min(f,l),c=f-o;for(let g=0;g<n;g++)c>0&&h.push({dx:g*40,dy:t-c,w:35,h:c,type:"block"}),h.push({dx:g*40,dy:t-f,w:35,h:o,type:"spike"});this.patterns.push({obstacles:h,requiredY:"top",width:n*40+20})}for(let a=0;a<10;a++){const n=2+Math.floor(a/3),h=[],f=50,o=Math.min(f,l),c=f-o;for(let g=0;g<n;g++)h.push({dx:g*40,dy:0,w:35,h:o,type:"spike"}),c>0&&h.push({dx:g*40,dy:o,w:35,h:c,type:"block"});this.patterns.push({obstacles:h,requiredY:"bottom",width:n*40+20})}for(let a=0;a<10;a++){const n=[],h=100+a*12,f=Math.min(h,l),o=h-f;n.push({dx:0,dy:t-h,w:45,h:f,type:"spike"}),o>0&&n.push({dx:0,dy:t-o,w:45,h:o,type:"block"}),n.push({dx:60,dy:0,w:45,h:f,type:"spike"}),o>0&&n.push({dx:60,dy:f,w:45,h:o,type:"block"}),a>=5&&(n.push({dx:120,dy:t-h,w:45,h:f,type:"spike"}),o>0&&n.push({dx:120,dy:t-o,w:45,h:o,type:"block"})),this.patterns.push({obstacles:n,requiredY:"middle",width:a>=5?180:120})}for(let a=0;a<10;a++){const n=40+a*35,h=(100-a*4)*d,f=Math.max(e,h*r);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:n,type:"block"},{dx:0,dy:n+f,w:40,h:Math.max(0,t-n-f),type:"block"}],requiredY:n<t/3?"top":n>t*2/3-f?"bottom":"middle",width:50,type:"corridor"})}for(let a=0;a<10;a++){const n=[],f=Math.min(70,l),o=70-f;a%2===0?(n.push({dx:0,dy:t-70,w:50,h:f,type:"spike"}),o>0&&n.push({dx:0,dy:t-o,w:50,h:o,type:"block"}),n.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),n.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(n.push({dx:0,dy:0,w:50,h:f,type:"spike"}),o>0&&n.push({dx:0,dy:f,w:50,h:o,type:"block"}),n.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),n.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:n,requiredY:a%2===0?"top":"bottom",width:80})}for(let a=0;a<10;a++){const o=["top","middle","bottom"][a%3];let c=t/2-15/2;o==="top"&&(c=60),o==="bottom"&&(c=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:c,w:200,h:15,type:"laser"}],requiredY:o==="top"?"bottom":o==="bottom"||a%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let a=0;a<10;a++){const h=a%2===0?"saw":"spike_ball",f=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:f,w:60,h:60,type:h,movement:{type:"updown",range:100+a*10,speed:1+a*.25,phase:a*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let a=0;a<10;a++){const n=3+Math.floor(a/3),h=[];for(let f=0;f<n;f++){const o=50+f*120%(t-100);h.push({dx:f*80,dy:o,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:h,requiredY:"middle",width:n*80,type:"spike_ball_field"})}for(let a=0;a<10;a++){const f=100+a*100%(t-200),o=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h:f,type:"v_laser"},{dx:0,dy:f+o,w:15,h:t-(f+o),type:"v_laser"}],requiredY:f<t/3?"top":f>t*2/3-o?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let a=0;a<10;a++){const n=2+Math.floor(a/2),h=[];for(let f=0;f<n;f++){const o=100+Math.random()*(t-200),c=f*60;h.push({dx:c,dy:o,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:f}})}this.patterns.push({obstacles:h,requiredY:"middle",width:n*60+50,type:"mine_field"})}for(let a=0;a<10;a++){const h=t/2-60,f=[];f.push({dx:0,dy:h,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+a*.1,phase:0}}),this.patterns.push({obstacles:f,requiredY:a%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let a=0;a<10;a++){const n=[],h=t/2-25;n.push({dx:50,dy:h,w:50,h:50,type:"orb"}),n.push({dx:50,dy:0,w:50,h:60,type:"spike"}),n.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:n,requiredY:"middle",width:150})}for(let a=0;a<10;a++){const n=[],h=t/2-20;n.push({dx:0,dy:h,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),n.push({dx:0,dy:h,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:n,requiredY:"middle",width:300,type:"windmill"})}for(let a=0;a<10;a++){const n=[],h=3+a%3;for(let f=0;f<h;f++)n.push({dx:f*40,dy:100+f*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:n,requiredY:"middle",width:h*40,type:"mine_cluster"})}for(let a=0;a<10;a++){const n=[];for(let f=0;f<4;f++)n.push({dx:f*50,dy:50+f*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:n,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.baseSpeed=this.getDynamicBaseSpeed(),this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){this.obstacles=t.engineObstacles.map(s=>({...s})),this.portals=t.enginePortals.map(s=>({...s,activated:!1})),this.autoplayLog=t.autoplayLog?[...t.autoplayLog]:[],this.totalLength=t.duration*this.baseSpeed+500,this.lastAutoplayIndex=0,console.log(`[loadMapData] Loaded ${this.obstacles.length} obstacles, ${this.portals.length} portals, ${this.autoplayLog.length} autoplay points`)}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,s,e,r,d=!0,l=0,a=120,n=2,h,f){this.bpm=a,this.measureLength=n;const o=r||t.length*777+Math.floor(e*100);this.obstacles=[],this.portals=[],f&&console.log(`[MapGen] Resuming generation from time ${f.time.toFixed(2)}s`),this.beatTimes=t||[],this.beatTimes=t||[],this.trackDuration=e,this.totalLength=e*this.baseSpeed+2e3,this.autoplayLog=[];const c=new nt,g=this.mapConfig.difficulty;console.log(`[MapGen] Procedural Generation with seed: ${o}, Difficulty: ${g}`);const y=this.seededRandom(o+l),Y=this.generatePathBasedMap(t,s,y,h,f);this.lastStateEvents=Y;let u=0;if(f){const p=this.autoplayLog.find(_=>_.time>=f.time);p&&(u=p.x);const k=u;this.obstacles=f.obstacles.filter(_=>_.x+_.width<=k),this.portals=f.portals.filter(_=>_.x+_.width<=k)}else this.obstacles=[],this.portals=[];let m=this.autoplayLog;f&&u>0&&(m=this.autoplayLog.filter(p=>p.x>=u));const w=c.generateFromPath(m,g,t,Y);for(const p of w)["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green"].includes(p.type)?this.portals.push({x:p.x,y:this.minY,width:p.width||50,height:this.maxY-this.minY,type:p.type,activated:!1}):this.obstacles.push({x:p.x,y:p.y,width:p.width||50,height:p.height||50,type:p.type,angle:p.rotation||0,movement:void 0,initialY:p.y,children:p.children,customData:p.customData});this.obstacles.sort((p,k)=>p.x-k.x),this.portals.sort((p,k)=>p.x-k.x),console.log(`[MapGen] Generated ${this.obstacles.length} obstacles, ${this.portals.length} portals from path`)}generatePathBasedMap(t,s,e,r,d){const l=this.mapConfig.difficulty;this.maxY-this.minY;const a=1/60,h=60/this.bpm*4,f=[],o=t.length>0?Math.max(.5,t[0]):.5;for(let M=o;M<this.trackDuration;M+=h)f.push(M);const c=d?.time||0;console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${h.toFixed(3)}s, Total Measures: ${f.length}`);const g=[];let y="speed_1",Y=!1,u=!1;const m=[{time:.5,speedType:"speed_1",isInverted:!1,isMini:!1}],w=m[0];if(l>=5&&w){const M=e();M<.3?w.speedType="speed_0.5":M<.6&&(w.speedType="speed_2")}if(g.push(...m),m[0]&&(y=m[0].speedType),d){const M=d.stateEvents.filter(v=>v.time<c);if(g.length=0,g.push(...M),g.length>0){const v=g[g.length-1];v&&(y=v.speedType,Y=v.isInverted,u=v.isMini)}}for(const M of f){if(M<1||M<c)continue;s?.find(T=>M>=T.startTime&&M<T.endTime)?.intensity;let P;if(l<8){const T=e();T<.8?P="speed_1":T<.9?P="speed_0.5":P="speed_2"}else if(l<16){const T=e();T<.1?P="speed_0.5":T<.6?P="speed_1":P="speed_2"}else if(l<24){const T=e();T<.15?P="speed_0.5":T<.4?P="speed_1":T<.8?P="speed_2":P="speed_3"}else{const T=e();T<.1?P="speed_0.25":T<.25?P="speed_0.5":T<.4?P="speed_1":T<.5?P="speed_2":T<.8?P="speed_3":P="speed_4"}const G=l>=24?.9:l<8?.25:.5;let E=Y;e()<G&&l>=3&&(E=e()>.5);let W=u;if(l>=5)if(u)e()<.6&&(W=!1);else{const T=l>=24?.08:.04;e()<T&&(W=!0)}else W=!1;(P!==y||E!==Y||W!==u)&&(g.push({time:M,speedType:P,isInverted:E,isMini:W}),y=P,Y=E,u=W)}const p=[];d&&p.push(...d.beatActions.filter(M=>M.time<c));const k=[...t].filter(M=>M>=.3&&M>=c).sort((M,v)=>M-v);let _=!1;d&&d.beatActions.length>0&&d.beatActions[d.beatActions.length-1].action==="click"&&(_=!0);const B=.25;for(let M=0;M<k.length;M++){const v=k[M],G=(M+1<k.length?k[M+1]:v+1)-v;if(G<B)p.push({time:v,action:_?"release":"click"}),_=!_;else if(_){const W=(e()-.5)*.3,T=Math.max(.3,Math.min(.8,.5+W));p.push({time:v,action:"click"}),p.push({time:v+G*T,action:"release"}),_=!1}else{const W=(e()-.5)*.3,T=Math.max(.3,Math.min(.8,.5+W));p.push({time:v,action:"click"}),p.push({time:v+G*T,action:"release"}),_=!1}}p.sort((M,v)=>M.time-v.time);const A=[];for(const M of p){if(A.length>0){const v=A[A.length-1];M.time-v.time<.01&&A.pop()}A.push(M)}p.length=0,p.push(...A),p.sort((M,v)=>M.time-v.time);const X=[];for(const M of p){const v=X[X.length-1];(!v||Math.abs(v.time-M.time)>.03||v.action!==M.action)&&X.push(M)}p.length=0,p.push(...X),this.autoplayLog=[];let S=200,D=360,I=0,H=!1,R=!1,L=1,C=!1,F=45,O=0,V=0;for(;I<this.trackDuration+1;){for(;V<g.length&&g[V].time<=I;){const E=g[V];L=this.getSpeedMultiplierFromType(E.speedType),R=E.isInverted,C=E.isMini,F=this.getEffectiveAngle(C,L),V++}for(;O<p.length&&p[O].time<=I;)H=p[O].action==="click",O++;const M=this.baseSpeed*L,v=M*Math.tan(F*Math.PI/180);let P;R?P=H?1:-1:P=H?-1:1,D+=v*P*a;const G=70;D<this.minY+G&&(D=this.minY+G),D>this.maxY-G&&(D=this.maxY-G),S+=M*a,this.autoplayLog.push({x:S,y:D,holding:H,time:I}),I+=a}this.lastBeatActions=p,this.totalLength=S+500;for(const M of g){const v=this.autoplayLog.find(Z=>Math.abs(Z.time-M.time)<.02);if(!v)continue;const P=[],G=g[g.indexOf(M)-1],E=G?.speedType||"speed_1",W=G?.isInverted||!1,T=G?.isMini||!1;M.speedType!==E&&P.push(M.speedType),M.isInverted!==W&&P.push(M.isInverted?"gravity_yellow":"gravity_blue"),M.isMini!==T&&P.push(M.isMini?"mini_pink":"mini_green"),P.length>0&&this.generatePathAlignedPortals(v.x,v.y,P)}return g}generatePathAlignedPortals(t,s,e){e.forEach((a,n)=>{const h=t+n*144,f=s-240/2;if(this.portals.push({x:h,y:this.minY,width:64,height:this.maxY-this.minY,type:a,activated:!1}),this.mapConfig.difficulty<=2)return;const o=f-this.minY-20;o>20&&this.obstacles.push({x:h-5,y:this.minY,width:74,height:o,type:"block",initialY:this.minY});const c=f+240+20,g=this.maxY-c;g>20&&this.obstacles.push({x:h-5,y:c,width:74,height:g,type:"block",initialY:c})})}isObstacleSafe(t,s,e,r,d=0){const l=this.basePlayerSize+d,a=t-l,n=t+e+l;let h=0,f=this.autoplayLog.length;for(;h<f;){const c=h+f>>>1;this.autoplayLog[c].x<a?h=c+1:f=c}const o=h;for(let c=o;c<this.autoplayLog.length;c++){const g=this.autoplayLog[c];if(g.x>n)break;if(g.y>=s-l&&g.y<=s+r+l)return!1}return!0}placeObstaclesForPath(t,s,e,r){const d=Math.max(.1,r/30),l=this.basePlayerSize;let a=1,n=!1;const h=[];this.portals.forEach(y=>{if(y.type==="mini_pink")h.push({x:y.x,isMini:!0,speed:a});else if(y.type==="mini_green")h.push({x:y.x,isMini:!1,speed:a});else if(y.type.startsWith("speed_")){const Y=parseFloat(y.type.replace("speed_",""));h.push({x:y.x,isMini:n,speed:Y})}}),h.sort((y,Y)=>y.x-Y.x);const f=y=>y<=.5?.4:y<=1?1:y<=2?1.5:2,o=()=>{const y=Math.max(l+5,50-d*35);return n?y*.5:y},c=800;let g=400;console.log(`[MapGen] Starting path obstacle placement - Diff: ${r}`);for(let y=500;y<this.totalLength-300;y+=100){const Y=this.autoplayLog.find(A=>Math.abs(A.x-y)<50);if(!Y)continue;const u=Y.time,m=[...s].reverse().find(A=>A.time<=u);m&&(n=m.isMini,a=this.getSpeedMultiplierFromType(m.speedType));const w=Y.y,p=o(),k=f(a);if(y-g<150*k)continue;if(n){this.placeTiltedBlock(y,w,p,60,e),g=y;continue}const _=Math.floor((y-500)/c)%4;_===0?(this.placeBlockWall(y,w,p,e),g=y):_===1?(this.placeTiltedBlock(y,w,p,45,e),g=y):_===2?(this.placeLaserWall(y,w,p,e),g=y):r>=10?(this.placeMovingObstacle(y,w,p,Y.time,e),g=y):(this.placeBlockWall(y,w,p,e),g=y),t.find(A=>Math.abs(A.time*this.baseSpeed+200-y)<100)&&e()<.3+d*.3&&this.placeRapidBlocks(y,w,p,3,e)}}placeBlockWall(t,s,e,r){const d=50+Math.floor(r()*30),l=s-e-this.minY;l>30&&this.isObstacleSafe(t,this.minY,d,l,3)&&this.obstacles.push({x:t,y:this.minY,width:d,height:l,type:"block",initialY:this.minY});const a=s+e,n=this.maxY-a;n>30&&this.isObstacleSafe(t,a,d,n,3)&&this.obstacles.push({x:t,y:a,width:d,height:n,type:"block",initialY:a})}placeTiltedBlock(t,s,e,r,d){const l=100+Math.floor(d()*50),a=this.autoplayLog.find(c=>Math.abs(c.x-(t-100))<60),n=this.autoplayLog.find(c=>Math.abs(c.x-(t+100))<60);let h=!0;a&&n?h=n.y<a.y:a&&(h=s<a.y);const f=s-e-l;f>this.minY&&this.isObstacleSafe(t,f,l,l,3)&&this.obstacles.push({x:t,y:f,width:l,height:l,type:"slope",initialY:f,angle:h?r:-r});const o=s+e;if(o+l<this.maxY&&this.isObstacleSafe(t,o,l,l,3)&&this.obstacles.push({x:t,y:o,width:l,height:l,type:"slope",initialY:o,angle:h?-r:r}),d()<.3){const c=40+Math.floor(d()*30),g=t+l+30,y=s-c/2;this.isObstacleSafe(g,y,c,c,3)&&this.obstacles.push({x:g,y,width:c,height:c,type:"spike_ball",initialY:y})}}placeLaserWall(t,s,e,r){const l=s-e-this.minY-20;l>50&&this.obstacles.push({x:t+10,y:this.minY,width:30,height:l,type:"v_laser",initialY:this.minY});const a=s+e+20,n=this.maxY-a;n>50&&this.obstacles.push({x:t+10,y:a,width:30,height:n,type:"v_laser",initialY:a})}placeMovingObstacle(t,s,e,r,d){const l=40+Math.floor(d()*20),a=80+Math.floor(d()*60),n=1.5+d()*1.5,h=s-e-l-30;h>this.minY+a&&this.obstacles.push({x:t,y:h,width:l,height:l,type:"saw",initialY:h,moveY:{range:a,speed:n}});const f=s+e+30;f+l+a<this.maxY&&this.obstacles.push({x:t,y:f,width:l,height:l,type:"spike_ball",initialY:f,moveY:{range:a,speed:n}})}placeRapidBlocks(t,s,e,r,d){for(let n=0;n<r;n++){const h=t+n*60;if(n%2===0){const o=s-e-this.minY;o>20&&this.isObstacleSafe(h,this.minY,30,o,2)&&this.obstacles.push({x:h,y:this.minY,width:30,height:o,type:"block",initialY:this.minY})}else{const o=s+e,c=this.maxY-o;c>20&&this.isObstacleSafe(h,o,30,c,2)&&this.obstacles.push({x:h,y:o,width:30,height:c,type:"block",initialY:o})}}}getSmallObstacleType(t,s){const e=t();return s<8?e<.4?"spike":e<.7?"mini_spike":"orb":s<16?e<.25?"spike":e<.4?"saw":e<.55?"orb":e<.7?"mini_spike":e<.85?"spike_ball":"mine":s<24?e<.2?"spike":e<.35?"saw":e<.5?"spike_ball":e<.65?"mine":e<.8?"orb":"laser":e<.15?"spike":e<.25?"saw":e<.4?"spike_ball":e<.55?"mine":e<.7?"orb":e<.85?"laser":"v_laser"}getRandomObstacleType(t,s){if(s<8)return t()>.5?"block":"spike";if(s<16){const e=["block","spike","saw","mini_spike"];return e[Math.floor(t()*e.length)]}else if(s<24){const e=["block","spike","saw","laser","spike_ball"];return e[Math.floor(t()*e.length)]}else{const e=["block","spike","saw","laser","spike_ball","mine","orb","v_laser"];return e[Math.floor(t()*e.length)]}}getRandomDecorationType(t,s){if(s<16){const e=["mini_spike","orb"];return e[Math.floor(t()*e.length)]}else{const e=["mine","spike_ball","saw","orb"];return e[Math.floor(t()*e.length)]}}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,s){return t?s>=1.9?78:s>=1.7?72:60:45}getValidPatterns(t,s,e){const d={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let l=this.patterns.filter(a=>d.includes(a.requiredY));return e==="corridor"&&(l=l.filter(a=>a.type!=="corridor")),l}placePattern(t,s){const e=this.minY;for(const r of t.obstacles)this.obstacles.push({x:s+r.dx,y:e+r.dy,width:r.w,height:r.h,type:r.type,initialY:e+r.dy})}placePatternWithScale(t,s,e,r,d){const l=this.minY,a=this.maxY-this.minY;let n=1;e>1.2&&(n*=.85),e<.8&&(n*=1.15),r&&(n*=.75);for(const h of t.obstacles){let f=h.h*n,o=h.w*n,c=h.dy;if(h.dy<a/2)c=h.dy*n;else{const y=a-(h.dy+h.h);c=a-y*n-f}this.obstacles.push({x:s+h.dx*d,y:l+c,width:o,height:f,type:h.type,angle:h.angle,movement:h.movement?{...h.movement}:void 0,initialY:l+c})}}generatePortalWithType(t,s,e,r=[]){const n=this.maxY-this.minY,h=this.minY+80+e()*(n-160),f=[s,...r],o=f.length*50+(f.length-1)*40;f.forEach((Y,u)=>{this.portals.push({x:t+u*90,y:h-100/2,width:50,height:100,type:Y,activated:!1})});const c=this.basePlayerSize*2.2,g=h-100/2,y=h+100/2;g>this.minY+c&&this.obstacles.push({x:t-10,y:this.minY,width:o+20,height:g-this.minY-c,type:"block",initialY:this.minY}),y<this.maxY-c&&this.obstacles.push({x:t-10,y:y+c,width:o+20,height:this.maxY-(y+c),type:"block",initialY:y+c})}generatePortal(t,s){let e=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"];const r=this.mapConfig.difficulty;r<8?e=e.filter(a=>!["speed_2","speed_3","speed_4"].includes(a)):r<16?e=e.filter(a=>!["speed_3","speed_4"].includes(a)):r<24&&(e=e.filter(a=>a!=="speed_4"));const d=e.filter(a=>a==="gravity_blue"?this.portals.some(n=>n.type==="gravity_yellow"):!0),l=d[Math.floor(s()*d.length)]||"speed_1";this.generatePortalWithType(t,l,s)}*computeAutoplayLogGen(t,s){this.autoplayLog=[],this.validationFailureInfo=null;const e=1/30,r=[...this.obstacles].sort((p,k)=>p.x-k.x),d=[...this.portals].sort((p,k)=>p.x-k.x),l=p=>{let k=0,_=r.length;for(;k<_;){const B=k+_>>>1;r[B].x<p?k=B+1:_=B}return k},a={x:t,y:s,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},n=new Set,h=p=>{const k=Math.floor(p.x/(this.baseSpeed*.033)),_=Math.floor(p.y/12);return`${k}_${_}_${p.g?1:0}_${Math.round(p.sm*10)}_${p.m?1:0}`},f=(p,k,_,B,A=0)=>{const X=l(p-1e3);for(let S=X;S<r.length;S++){const D=r[S];if(D.x+D.width<p-50)continue;if(D.x>p+100)break;const I=D.movement?2:0;if(this.checkObstacleCollision(D,p,k,_+A+I,B))return!0}return!1},o=(p,k,_)=>{let B=p.x,A=p.y,X=p.g,S=p.sm,D=p.wa,I=p.m,H=p.pIdx,R=p.time;for(let L=0;L<_;L++){for(;H<d.length&&B>=d[H].x;){const M=d[H];A>=M.y&&A<=M.y+M.height&&(M.type==="gravity_yellow"&&(X=!0),M.type==="gravity_blue"&&(X=!1),M.type.startsWith("speed_")&&(S=this.getSpeedMultiplierFromType(M.type)),M.type==="mini_pink"&&(I=!0),M.type==="mini_green"&&(I=!1),D=this.getEffectiveAngle(I,S)),H++}const C=this.baseSpeed*S,F=C*Math.tan(D*Math.PI/180),O=I?this.miniPlayerSize:this.basePlayerSize;if(B+=C*e,R+=e,A+=F*(X?k?1:-1:k?-1:1)*e,A<this.minY+O&&(A=this.minY+O),A>this.maxY-O&&(A=this.maxY-O),f(B,A,O,R,1))return!1}return!0},c=[a];let g=t,y=0;const Y=25e4;let u=null,m=t,w=s;for(;c.length>0;){y++;const p=c.pop();if(p.x>g&&(g=p.x),y%1e3===0&&(yield g/this.totalLength),p.x>=this.totalLength){u=p;break}const k=h(p);if(n.has(k))continue;n.add(k);let _=p.g,B=p.sm,A=p.m,X=p.wa,S=p.pIdx;for(;S<d.length&&p.x>=d[S].x;){const b=d[S];if(p.y>=b.y&&p.y<=b.y+b.height){if(b.type==="gravity_yellow"&&(_=!0),b.type==="gravity_blue"&&(_=!1),b.type.startsWith("speed_")&&(B=this.getSpeedMultiplierFromType(b.type)),b.type==="mini_pink"&&(A=!0),b.type==="mini_green"&&(A=!1),b.type==="teleport_in"){const z=this.portals.find(U=>U.type==="teleport_out"&&(b.linkId?U.linkId===b.linkId:U.x>b.x));if(z){p.x=z.x+z.width+20,p.y=z.y+z.height/2,S=d.findIndex(U=>U.x>=p.x),S===-1&&(S=d.length);break}}X=this.getEffectiveAngle(A,B)}S++}const D=this.baseSpeed*B,I=D*Math.tan(X*Math.PI/180),H=A?this.miniPlayerSize:this.basePlayerSize,R=p.time+e,L=p.x+D*e;let C=p.y+I*(_?1:-1)*e,F=p.y+I*(_?-1:1)*e;C<this.minY+H&&(C=this.minY+H),C>this.maxY-H&&(C=this.maxY-H),F<this.minY+H&&(F=this.minY+H),F>this.maxY-H&&(F=this.maxY-H);let O=f(L,C,H,R,3),V=f(L,F,H,R,3);const M=H*.8;!O&&Math.abs(C-p.y)>M&&f((p.x+L)/2,(p.y+C)/2,H,p.time+e/2,3)&&(O=!0),!V&&Math.abs(F-p.y)>M&&f((p.x+L)/2,(p.y+F)/2,H,p.time+e/2,3)&&(V=!0),O&&V&&L>m&&(m=L,w=p.y);const v=p.h,P=45,G=.125/Math.pow(p.sm,.7);let W=p.time-p.lastSwitchTime<G;if(W){const b=p.y;if(Math.abs(b-360)>25){const U=p.g,K=v,Q=U?K?1:-1:K?-1:1;(b>360&&Q>0||b<360&&Q<0)&&(W=!1)}}let T=!1;const Z=!O&&o({...p,x:L,y:C,time:R,g:_,sm:B,m:A,wa:X,pIdx:S,lastSwitchTime:v?p.lastSwitchTime:R},!0,P),x=!V&&o({...p,x:L,y:F,time:R,g:_,sm:B,m:A,wa:X,pIdx:S,lastSwitchTime:v?R:p.lastSwitchTime},!1,P);let j=!1;const $=L+400;for(let b=l(L);b<r.length;b++){const z=r[b];if(z.x>$)break;if(z.type==="falling_spike"){j=!0;break}}if(j?T=!0:v?Z?T=!0:T=!1:x?T=!1:T=!0,Z&&x){const b=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let q=l(L-1e3);q<r.length;q++){const J=r[q];if(J.x+J.width<L)continue;if(J.x>L)break;const tt=this.getObstacleYRangeAt(J,L,R);tt&&b.push(tt)}b.sort((q,J)=>q.top-J.top);const z=[];if(b.length>0){let q={...b[0]};for(let J=1;J<b.length;J++){const tt=b[J];tt.top<=q.bottom?q.bottom=Math.max(q.bottom,tt.bottom):(z.push(q),q={...tt})}z.push(q)}const U=[];for(let q=0;q<z.length-1;q++)U.push({top:z[q].bottom,bottom:z[q+1].top});let K=U[0],Q=1/0;for(const q of U){const J=(q.top+q.bottom)/2,tt=Math.abs(p.y-J);if(p.y>=q.top&&p.y<=q.bottom){K=q;break}tt<Q&&(Q=tt,K=q)}const it=(K.top+K.bottom)/2,et=Math.abs(C-it),st=Math.abs(F-it);et<st?T=!0:st<et?T=!1:T=v}W&&(v&&Z&&(T=!0),!v&&x&&(T=!1));const N=T?[!0,!1]:[!1,!0];for(const b of N)if(b?!O:!V){if(b!==v&&W&&(v?Z:x))continue;const z=b!==v?R:p.lastSwitchTime;c.push({x:L,y:b?C:F,time:R,g:_,sm:B,m:A,wa:X,h:b,pIdx:S,lastSwitchTime:z,prev:p})}if(y>Y)break}if(u){const p=[];let k=u;for(;k;)p.push({x:k.x,y:k.y,holding:k.h,time:k.time}),k=k.prev;return this.autoplayLog=p.reverse(),!0}else return this.validationFailureInfo={x:m,y:w,nearObstacles:r.filter(p=>p.x>m-400&&p.x<m+600)},!1}computeAutoplayLog(t=200,s=360){const e=this.computeAutoplayLogGen(t,s);let r=e.next();for(;!r.done;)r=e.next();return r.value}async computeAutoplayLogAsync(t,s,e){const r=this.computeAutoplayLogGen(t,s);let d=r.next(),l=performance.now();for(;!d.done;)typeof d.value=="number"&&performance.now()-l>16&&(e(d.value),await new Promise(n=>setTimeout(n,0)),l=performance.now()),d=r.next();return e(1),d.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,s){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const e=this.baseSpeed*this.speedMultiplier;this.waveSpeed=e;const d=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=e*Math.tan(d),this.playerX+=this.waveSpeed*t;let l=null;if(this.isAutoplay&&this.autoplayLog.length>0){const n=this.playerX;let h=null;for(let f=this.lastAutoplayIndex;f<this.autoplayLog.length;f++){const o=this.autoplayLog[f];if(o&&o.x>=n){h=o,this.lastAutoplayIndex=f;break}}if(h){this.isHolding=h.holding;const f=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(f){const c=(n-f.x)/(h.x-f.x);this.playerY=f.y+(h.y-f.y)*Math.max(0,Math.min(1,c)),l=f.time+(h.time-f.time)*Math.max(0,Math.min(1,c))}else this.playerY=h.y,l=h.time;const o=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=o.map(c=>({x:c.x,y:c.y}))}}else{this.aiPredictedPath=[];const n=this.isHolding?-1:1,h=this.isGravityInverted?-n:n;this.playerY+=this.waveAmplitude*h*t}this.playerY<this.minY+this.playerSize&&(this.playerY=this.minY+this.playerSize),this.playerY>this.maxY-this.playerSize&&(this.playerY=this.maxY-this.playerSize),this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const a=l!==null?l:s;if(this.updateMovingObstacles(t,a),this.updateBoss(t,a),this.checkPortalCollisions(),this.checkCollisions(a),this.beatTimes.length>0){const n=this.beatTimes.findIndex(h=>h>=s);n!==-1&&n!==this.lastMeasureIndex&&Math.abs(this.beatTimes[n]-s)<.1&&(this.isMeasureHighlight=!0,this.lastMeasureIndex=n,setTimeout(()=>this.isMeasureHighlight=!1,150))}this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals){if(t.activated||t.x+t.width<this.playerX-50)continue;if(t.x>this.playerX+100)break;const s=this.playerSize,e=[{x:this.playerX-s,y:this.playerY-s},{x:this.playerX+s,y:this.playerY-s},{x:this.playerX-s,y:this.playerY+s},{x:this.playerX+s,y:this.playerY+s},{x:this.playerX,y:this.playerY}];if(t.angle&&t.angle!==0){const l=t.x+t.width/2,a=t.y+t.height/2,n=-t.angle*Math.PI/180;e.forEach(h=>{const f=h.x-l,o=h.y-a;h.x=l+f*Math.cos(n)-o*Math.sin(n),h.y=a+f*Math.sin(n)+o*Math.cos(n)})}e.some(l=>l.x>=t.x&&l.x<=t.x+t.width&&l.y>=t.y&&l.y<=t.y+t.height)&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t),this.onPortalActivation&&this.onPortalActivation(t.type))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break;case"teleport_in":const s=this.portals.find(e=>e.type==="teleport_in"&&e.activated&&Math.abs(e.x-this.playerX)<100);if(s){let e=null;s.linkId?e=this.portals.find(r=>r.type==="teleport_out"&&r.linkId===s.linkId):e=this.portals.find(r=>r.type==="teleport_out"&&r.x>this.playerX),e&&(this.playerX=e.x+e.width+20,this.playerY=e.y+e.height/2,this.cameraX=this.playerX-280,this.trail=[],this.spawnPortalParticles(e))}break}}updateBoss(t,s){if(this.boss.active){this.boss.attackTimer+=t,this.boss.x=this.cameraX+1e3,this.boss.y=360+Math.sin(s*.5)*100;for(let e=this.boss.projectiles.length-1;e>=0;e--){const r=this.boss.projectiles[e];r.x+=r.vx*t,r.y+=r.vy*t,Math.hypot(r.x-this.playerX,r.y-this.playerY)<20+this.playerSize&&this.die("보스 공격에 당했습니다!"),r.x<this.cameraX-100&&this.boss.projectiles.splice(e,1)}this.boss.attackTimer>3&&(this.boss.projectiles.push({x:this.boss.x,y:this.boss.y,vx:-600,vy:(this.playerY-this.boss.y)*2,type:"missile"}),this.boss.attackTimer=0)}}spawnPortalParticles(t){const s=this.getPortalColor(t.type);for(let e=0;e<10;e++){const r=Math.PI*2*e/10,d=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(r)*d,vy:Math.sin(r)*d,life:.6+Math.random()*.3,color:s})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";case"teleport_in":return"#00ffff";case"teleport_out":return"#ff00ff";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";case"teleport_in":return"IN";case"teleport_out":return"OUT";default:return"?"}}updateParticles(t){for(let s=this.particles.length-1;s>=0;s--){const e=this.particles[s];e&&(e.x+=e.vx*t,e.y+=e.vy*t,e.vy+=150*t,e.life-=t,e.life<=0&&this.particles.splice(s,1))}}getObstacleYRangeAt(t,s,e){if(s<t.x||s>t.x+t.width)return null;let r=t.y,d=t.angle||0;if(e!==void 0&&t.movement){const l=this.getObstacleStateAt(t,e);r=l.y,d=l.angle}if(t.type==="block"){if(d){const l=d*Math.PI/180,a=t.x+t.width/2,n=r+t.height/2,h=Math.cos(l),f=Math.sin(l),o=t.width/2,c=t.height/2,g=[{dx:-o,dy:-c},{dx:o,dy:-c},{dx:o,dy:c},{dx:-o,dy:c}].map(m=>({x:a+m.dx*h-m.dy*f,y:n+m.dx*f+m.dy*h}));let y=1/0,Y=-1/0,u=!1;for(let m=0;m<4;m++){const w=g[m],p=g[(m+1)%4];if(w.x<=s&&s<=p.x||p.x<=s&&s<=w.x){if(Math.abs(w.x-p.x)<.1)y=Math.min(y,w.y,p.y),Y=Math.max(Y,w.y,p.y);else{const k=(s-w.x)/(p.x-w.x),_=w.y+k*(p.y-w.y);y=Math.min(y,_),Y=Math.max(Y,_)}u=!0}}return u?{top:y,bottom:Y}:null}return{top:r,bottom:r+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const l=r>330,a=t.x+t.width/2;let n;if(s<=a){const h=(s-t.x)/(a-t.x);n=l?r+t.height-h*t.height:r+h*t.height}else{const h=(s-a)/(t.x+t.width-a);n=l?r+(1-h)*0+h*t.height:r+t.height-(1-h)*0-h*t.height,n=l?r+h*t.height:r+t.height-h*t.height}return l?{top:n,bottom:r+t.height}:{top:r,bottom:n}}if(t.type==="slope"){const l=(s-t.x)/t.width;if(d>0){const a=r+t.height*(1-l);return{top:r,bottom:a}}else{const a=r+t.height*l;return{top:r,bottom:a}}}if(t.type==="triangle"||t.type==="steep_triangle"){const l=(s-t.x)/t.width;return{top:r+t.height*(1-l),bottom:r+t.height}}return{top:r,bottom:r+t.height}}checkCollisions(t){for(const s of this.obstacles)if(!(s.x+s.width<this.playerX-80)){if(s.x>this.playerX+100)break;if(this.checkObstacleCollision(s,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,s,e,r,d){let l=t.y,a=t.angle||0;if(d!==void 0&&t.movement){const u=this.getObstacleStateAt(t,d);l=u.y,a=u.angle}let n=t.width,h=t.height;if(t.type==="mine"&&t.customData?.pulseSpeed){const u=d||performance.now()/1e3,m=t.customData.pulseSpeed||2,w=t.customData.pulseAmount||.2,p=1+Math.sin(u*m)*w;n*=p,h*=p}const f=10;n=Math.max(n,f),h=Math.max(h,f);const o=t.x-(n-t.width)/2,c=l-(h-t.height)/2,g=a!==0,y=[{x:s-r,y:e-r},{x:s+r,y:e-r},{x:s-r,y:e+r},{x:s+r,y:e+r},{x:s,y:e}];if(t.type==="falling_spike"&&d!==void 0){const u=t.x-150;if(s>u){const m=this.baseSpeed*(this.speedMultiplier||1),p=Math.max(0,s-u)/m,k=.5*2500*p*p;if(l=(t.initialY!==void 0?t.initialY:t.y)+k,l>this.maxY+100)return!1}else l=t.initialY!==void 0?t.initialY:t.y}if(t.type==="planet"||t.type==="star"){const u=d||performance.now()/1e3,m=t.x+t.width/2,w=l+t.height/2,p=n/2,k=h/2,_=s-m,B=e-w;if(_*_/((p-2)*(p-2))+B*B/((k-2)*(k-2))<1)return!0;if(t.children&&t.children.length>0){const X=t.children,S=t.customData?.orbitSpeed??1;for(let D=0;D<X.length;D++){const I=X[D];if(!I)continue;const H=u*S+D*(Math.PI*2/X.length),R=t.customData?.orbitDistance??t.width*.85,L=m+Math.cos(H)*R,C=w+Math.sin(H)*R,F=I.width?I.width/2:14;if((y[4].x-L)**2+(y[4].y-C)**2<(F+r-2)**2)return!0;if(I.type==="planet"){const V=I.customData?.orbitCount??2,M=I.customData?.orbitSpeed??2,v=I.customData?.orbitDistance??I.width*.8;for(let P=0;P<V;P++){const G=u*M+P*(Math.PI*2/V),E=L+Math.cos(G)*v,W=C+Math.sin(G)*v;if((y[4].x-E)**2+(y[4].y-W)**2<(8+r-2)**2)return!0}}}}else{const X=t.customData?.orbitCount??(t.type==="star"?0:2);if(!(X===0&&t.type==="star")){const S=t.customData?.orbitSpeed??1,D=t.customData?.orbitDistance??t.width*.8;for(let I=0;I<X;I++){const H=u*S+I*(Math.PI*2/X),R=m+Math.cos(H)*D,L=w+Math.sin(H)*D,C=t.type==="star"?20:10;if((y[4].x-R)**2+(y[4].y-L)**2<(C+r-2)**2)return!0;if(t.type==="star"&&t.customData?.nestedOrbit){const M=S*2.5;for(let v=0;v<2;v++){const P=u*M+v*(Math.PI*2/2),G=R+Math.cos(P)*25,E=L+Math.sin(P)*25;if((y[4].x-G)**2+(y[4].y-E)**2<(8+r-2)**2)return!0}}}}}return!1}if(g){const u=o+n/2,m=c+h/2,w=-a*Math.PI/180;y.forEach(p=>{const k=p.x-u,_=p.y-m;p.x=u+k*Math.cos(w)-_*Math.sin(w),p.y=m+k*Math.sin(w)+_*Math.cos(w)})}const Y=y.some(u=>u.x>=o&&u.x<=o+n&&u.y>=c&&u.y<=c+h);if(!Y&&t.type!=="slope"&&t.type!=="spike"&&t.type!=="mini_spike")return!1;if(t.type==="block")return Y;if(t.type==="slope"){let u;t.angle>0?u=[{x:o,y:c+h},{x:o+n,y:c},{x:o,y:c}]:u=[{x:o+n,y:c+h},{x:o,y:c},{x:o+n,y:c}];for(const m of y)if(this.isPointInTriangle(m.x,m.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(t.type==="triangle"||t.type==="steep_triangle"){const u=[{x:o,y:c+h},{x:o+n,y:c+h},{x:o+n,y:c}];for(const m of y)if(this.isPointInTriangle(m.x,m.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(t.type==="spike"||t.type==="mini_spike"){const m=c>300?[{x:o,y:c+h},{x:o+n/2,y:c},{x:o+n,y:c+h}]:[{x:o,y:c},{x:o+n/2,y:c+h},{x:o+n,y:c}];for(const w of y)if(m[0]&&m[1]&&m[2]&&this.isPointInTriangle(w.x,w.y,m[0].x,m[0].y,m[1].x,m[1].y,m[2].x,m[2].y))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const u=o+n/2,m=c+h/2,w=n/2*.9,p=h/2*.9;for(const k of y){const _=k.x-u,B=k.y-m;if(_*_/(w*w)+B*B/(p*p)<1)return!0}return!1}if(t.type==="laser"){const u=h*.4,m=c+h/2;return y.some(w=>w.x>=o&&w.x<=o+n&&w.y>=m-u&&w.y<=m+u)}if(t.type==="v_laser"||t.type==="laser_beam"){const u=n*.4,m=o+n/2;return y.some(w=>w.y>=c&&w.y<=c+h&&w.x>=m-u&&w.x<=m+u)}if(t.type==="hammer"){const u=o+n/2,m=c+h/2;return y.some(w=>(w.x-u)**2+(w.y-m)**2<(n/2)**2)}if(t.type==="falling_spike"){const u=[{x:o,y:c},{x:o+n/2,y:c+h},{x:o+n,y:c}];for(const m of y)if(u[0]&&u[1]&&u[2]&&this.isPointInTriangle(m.x,m.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(["rotor","cannon","spark_mine","crusher_jaw","swing_blade"].includes(t.type)){const u=o+n/2,m=c+h/2,w=n/2*.8,p=h/2*.8;for(const k of y){const _=k.x-u,B=k.y-m;if(_*_/(w*w)+B*B/(p*p)<1)return!0}return!1}if(t.type==="piston_v")return Y;if(t.type==="growing_spike"){const u=[{x:o,y:c+h},{x:o+n/2,y:c},{x:o+n,y:c+h}];for(const m of y)if(u[0]&&u[1]&&u[2]&&this.isPointInTriangle(m.x,m.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}return!1}isPointInRotatedRect(t,s,e){const r=(e.angle||0)*Math.PI/180,d=e.x+e.width/2,l=e.y+e.height/2,a=t-d,n=s-l,h=Math.cos(-r),f=Math.sin(-r),o=a*h-n*f,c=a*f+n*h;return Math.abs(o)<=e.width/2&&Math.abs(c)<=e.height/2}removeRedundantObstacles(){const t=new Set,s=this.obstacles.length;for(let e=0;e<s;e++){const r=this.obstacles[e];if(!r.movement)for(let d=0;d<s;d++){if(e===d)continue;const l=this.obstacles[d];if(l.movement)continue;const a=l.angle?Math.max(l.width,l.height):0;if(!(l.x-a>r.x||l.x+l.width+a<r.x+r.width)&&this.isObstacleContained(r,l)){t.add(e);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((e,r)=>!t.has(r)))}isObstacleContained(t,s){if(s.type!=="block"&&s.type!=="spike"&&s.type!=="mini_spike")return!1;const e=this.getObstacleCorners(t);for(const r of e)if(!this.isPointInStaticObstacle(r.x,r.y,s))return!1;return!0}isPointInStaticObstacle(t,s,e){if(e.type==="block")return this.isPointInRotatedRect(t,s,e);if(e.type==="spike"||e.type==="mini_spike"){const r=e.y>300,d=e.x+e.width/2;return r?this.isPointInTriangle(t,s,e.x,e.y+e.height,d,e.y,e.x+e.width,e.y+e.height):this.isPointInTriangle(t,s,e.x,e.y,d,e.y+e.height,e.x+e.width,e.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const s=t.y>300,e=t.x+t.width/2;return s?[{x:t.x,y:t.y+t.height},{x:e,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:e,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const s=t.angle*Math.PI/180,e=t.x+t.width/2,r=t.y+t.height/2,d=Math.cos(s),l=Math.sin(s),a=t.width/2,n=t.height/2;return[{dx:-a,dy:-n},{dx:a,dy:-n},{dx:a,dy:n},{dx:-a,dy:n}].map(h=>({x:e+h.dx*d-h.dy*l,y:r+h.dx*l+h.dy*d}))}return t.type==="triangle"||t.type==="steep_triangle"?[{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height},{x:t.x+t.width,y:t.y}]:[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,s,e,r,d,l,a,n){const h=Math.abs((e*(l-n)+d*(n-r)+a*(r-l))/2),f=Math.abs((t*(r-l)+e*(l-s)+d*(s-r))/2),o=Math.abs((t*(l-n)+d*(n-s)+a*(s-l))/2),c=Math.abs((t*(n-r)+a*(r-s)+e*(s-n))/2);return Math.abs(h-(f+o+c))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let s=0;s<15;s++){const e=Math.PI*2*s/15,r=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(e)*r,vy:Math.sin(e)*r,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,s){let e=t.y,r=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:d,speed:l,phase:a}=t.movement;e=t.initialY+Math.sin(s*l+a)*d}else if(t.movement.type==="rotate"){const{speed:d,phase:l}=t.movement;r=(s*d+l)*180/Math.PI%360}}else["saw","rotor","spike_ball"].includes(t.type)?r=s*3*180/Math.PI%360:["hammer","swing_blade"].includes(t.type)?r=Math.sin(s*3)*60:["piston_v","crusher_jaw"].includes(t.type)&&t.initialY!==void 0&&(e=t.initialY+Math.sin(s*2)*50);return{y:e,angle:r}}updateMovingObstacles(t,s){for(const e of this.obstacles){const r=["saw","rotor","spike_ball","hammer","swing_blade","piston_v","crusher_jaw"].includes(e.type);if(e.movement||r){const d=this.getObstacleStateAt(e,s);(r||e.movement?.type==="updown")&&e.initialY===void 0&&(e.initialY=e.y),e.y=d.y,e.angle=d.angle}if(e.type==="falling_spike")if(e.customData||(e.customData={}),e.customData.isFalling===void 0&&(e.customData.isFalling=!1,e.customData.vy=0,e.initialY===void 0&&(e.initialY=e.y)),e.customData.isFalling)e.customData.vy=(e.customData.vy||0)+2500*t,e.y+=e.customData.vy*t;else{const l=e.x-this.playerX;l<150&&l>-50&&(e.customData.isFalling=!0,e.customData.vy=0),e.initialY!==void 0&&(e.y=e.initialY)}}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}function at(i,t,s,e,r,d=!1,l){const a=s+t.width/2,n=e+t.height/2,h=l??t.angle,f=h&&h!==0;if(f&&(i.save(),i.translate(a,n),i.rotate(h*Math.PI/180),i.translate(-a,-n)),t.type==="invisible_wall"){d&&(i.strokeStyle="rgba(255, 255, 255, 0.5)",i.lineWidth=1,i.setLineDash([5,5]),i.strokeRect(s,e,t.width,t.height),i.setLineDash([]),i.fillStyle="rgba(255, 255, 255, 0.1)",i.fillText("INVISIBLE",s,e+15)),f&&i.restore();return}else if(t.type==="fake_block"){i.fillStyle="rgba(255, 255, 255, 0.2)",i.fillRect(s,e,t.width,t.height),i.strokeStyle="#fff",i.strokeRect(s,e,t.width,t.height),d&&(i.fillStyle="#fff",i.font="10px Arial",i.fillText("FAKE",s+5,e+15)),f&&i.restore();return}if(t.type==="spike"||t.type==="mini_spike"){const o=t.type==="mini_spike";i.fillStyle=o?"#ff6666":"#ff4444",i.shadowBlur=o?8:12,i.shadowColor="#ff4444",i.beginPath(),e>300?(i.moveTo(s,e+t.height),i.lineTo(s+t.width/2,e),i.lineTo(s+t.width,e+t.height)):(i.moveTo(s,e),i.lineTo(s+t.width/2,e+t.height),i.lineTo(s+t.width,e)),i.closePath(),i.fill()}else if(t.type==="block")i.fillStyle="#444",i.shadowBlur=5,i.shadowColor="#666",i.fillRect(s,e,t.width,t.height),i.fillStyle="#555",i.fillRect(s+2,e+2,t.width-4,t.height-4);else if(t.type==="triangle"||t.type==="steep_triangle"){const o=t.type==="steep_triangle";i.fillStyle=o?"#222":"#333",i.shadowBlur=5,i.shadowColor="#555",i.beginPath(),i.moveTo(s,e+t.height),i.lineTo(s+t.width,e+t.height),i.lineTo(s+t.width,e),i.closePath(),i.fill(),i.fillStyle=o?"#444":"#555";const c=4;i.beginPath(),i.moveTo(s+c*2,e+t.height-c),i.lineTo(s+t.width-c,e+t.height-c),i.lineTo(s+t.width-c,e+c*2),i.fill()}else if(t.type==="saw"){const o=t.width/2,c=t.height/2;i.save(),i.translate(a,n),i.fillStyle="#ffaa00",i.shadowBlur=20,i.shadowColor="#ffaa00",i.beginPath(),i.ellipse(0,0,o,c,0,0,Math.PI*2),i.fill(),i.fillStyle="#ff6600";const g=10,y=r*8;for(let Y=0;Y<g;Y++){const u=Math.PI*2*Y/g+y,m=Math.cos(u)*o*.75,w=Math.sin(u)*c*.75;i.beginPath(),i.ellipse(m,w,o*.15,c*.15,0,0,Math.PI*2),i.fill()}i.fillStyle="#cc8800",i.beginPath(),i.ellipse(0,0,o*.25,c*.25,0,0,Math.PI*2),i.fill(),i.restore()}else if(t.type==="spike_ball"){const o=t.width/2,c=t.height/2;i.save(),i.translate(a,n),i.fillStyle="#666",i.shadowBlur=15,i.shadowColor="#444";const g=8,y=r*3;i.fillStyle="#444";for(let u=0;u<g;u++){const m=Math.PI*2*u/g+y;i.beginPath();const w=Math.cos(m)*o*1.2,p=Math.sin(m)*c*1.2;i.moveTo(Math.cos(m-.2)*o*.8,Math.sin(m-.2)*c*.8),i.lineTo(w,p),i.lineTo(Math.cos(m+.2)*o*.8,Math.sin(m+.2)*c*.8),i.fill()}const Y=i.createRadialGradient(-o*.3,-c*.3,o*.1,0,0,o);Y.addColorStop(0,"#888"),Y.addColorStop(1,"#222"),i.fillStyle=Y,i.beginPath(),i.ellipse(0,0,o*.8,c*.8,0,0,Math.PI*2),i.fill(),i.restore()}else if(t.type==="laser"){const o=e+t.height/2,c=Math.sin(r*15)*5+10;i.strokeStyle="#ff3333",i.lineWidth=2,i.shadowBlur=Math.max(0,c),i.shadowColor="#ff0000",i.beginPath(),i.moveTo(s,o),i.lineTo(s+t.width,o),i.stroke(),i.strokeStyle="#ffffff",i.lineWidth=1,i.shadowBlur=0,i.beginPath(),i.moveTo(s,o),i.lineTo(s+t.width,o),i.stroke(),i.fillStyle="#777",i.fillRect(s,e,8,t.height),i.fillRect(s+t.width-8,e,8,t.height)}else if(t.type==="v_laser"){const o=s+t.width/2,c=Math.sin(r*15)*5+10;i.strokeStyle="#ff3333",i.lineWidth=2,i.shadowBlur=Math.max(0,c),i.shadowColor="#ff0000",i.beginPath(),i.moveTo(o,e),i.lineTo(o,e+t.height),i.stroke(),i.strokeStyle="#ffffff",i.lineWidth=1,i.shadowBlur=0,i.beginPath(),i.moveTo(o,e),i.lineTo(o,e+t.height),i.stroke(),i.fillStyle="#777",i.fillRect(s,e,t.width,8),i.fillRect(s,e+t.height-8,t.width,8)}else if(t.type==="slope")i.fillStyle="#222",i.beginPath(),(t.angle||0)>0?(i.moveTo(s,e+t.height),i.lineTo(s+t.width,e),i.lineTo(s,e)):(i.moveTo(s+t.width,e+t.height),i.lineTo(s,e),i.lineTo(s+t.width,e)),i.closePath(),i.fill(),i.strokeStyle="rgba(100,200,255,0.3)",i.lineWidth=3,i.stroke();else if(t.type==="mine"){const o=t.width/2,c=Math.sin(r*10)*.1+.9;i.fillStyle="#ff3333",i.shadowBlur=10,i.shadowColor="#ff0000",i.beginPath();for(let g=0;g<6;g++){const y=Math.PI/3*g+r*2,Y=a+Math.cos(y)*o*c,u=n+Math.sin(y)*o*c;g===0?i.moveTo(Y,u):i.lineTo(Y,u)}i.closePath(),i.fill(),i.fillStyle="#550000",i.beginPath(),i.arc(a,n,o*.4,0,Math.PI*2),i.fill()}else if(t.type==="orb"){const o=t.width/2,c=t.height/2,g=Math.sin(r*5)*.1+1,y=i.createRadialGradient(a,n,o*.1,a,n,o*g);y.addColorStop(0,"#ffffff"),y.addColorStop(.4,"#aa44ff"),y.addColorStop(.8,"#4400cc"),y.addColorStop(1,"rgba(68, 0, 204, 0)"),i.fillStyle=y,i.globalCompositeOperation="lighter",i.beginPath(),i.ellipse(a,n,o*g,c*g,0,0,Math.PI*2),i.fill(),i.globalCompositeOperation="source-over"}else if(t.type==="hammer"){i.save(),i.translate(a,n);const o=Math.sin(r*3)*.5;i.rotate(o),i.fillStyle="#666",i.fillRect(-5,-t.height/2,10,t.height*.7),i.fillStyle="#888",i.shadowBlur=10,i.shadowColor="#fff",i.fillRect(-t.width/2,t.height*.2-t.height/2,t.width,t.height*.3),i.strokeStyle="#fff",i.lineWidth=2,i.strokeRect(-t.width/2,t.height*.2-t.height/2,t.width,t.height*.3),i.restore()}else if(["rotor","spark_mine"].includes(t.type)){i.save(),i.translate(a,n);const o=t.type==="spark_mine"?2:8,c=r*o;i.rotate(c);const g=t.width/2;if(t.type==="rotor"){i.fillStyle="#ff3333",i.shadowBlur=15,i.shadowColor="#ff0000";for(let y=0;y<3;y++)i.rotate(Math.PI*2/3),i.beginPath(),i.moveTo(0,0),i.lineTo(-5,-t.height/2),i.lineTo(5,-t.height/2),i.fill();i.fillStyle="#fff",i.beginPath(),i.arc(0,0,8,0,Math.PI*2),i.fill()}else if(t.type==="spark_mine"){i.fillStyle="#ffaa00",i.beginPath();const y=12;for(let Y=0;Y<y*2;Y++){const u=Y%2===0?g:g*.4,m=Math.PI*Y/y;i.lineTo(Math.cos(m)*u,Math.sin(m)*u)}i.fill()}i.restore()}else if(t.type==="laser_beam"){const o=e+t.height/2,c=Math.sin(r*20)*2+3;i.strokeStyle="#00ffff",i.lineWidth=t.height+c,i.shadowColor="#00ffff",i.shadowBlur=20,i.beginPath(),i.moveTo(s,o),i.lineTo(s+t.width,o),i.stroke(),i.shadowBlur=0,i.strokeStyle="#fff",i.lineWidth=t.height*.3,i.stroke()}else if(t.type==="piston_v")i.fillStyle="#555",i.fillRect(s,e,t.width,t.height),i.fillStyle="#888",i.fillRect(s+t.width*.3,e,t.width*.4,t.height),i.fillStyle="#333",e<360?i.fillRect(s,e+t.height-20,t.width,20):i.fillRect(s,e,t.width,20);else if(t.type==="cannon")i.fillStyle="#444",i.beginPath(),i.arc(s+t.width/2,e+t.height/2,t.width/2,0,Math.PI*2),i.fill(),i.fillStyle="#000",i.beginPath(),i.arc(s+t.width/2,e+t.height/2,t.width/3,0,Math.PI*2),i.fill();else if(["falling_spike","growing_spike"].includes(t.type)){i.fillStyle="#ff4444",i.beginPath();const o=s+t.width/2;t.type==="falling_spike"?(i.moveTo(s,e),i.lineTo(s+t.width,e),i.lineTo(o,e+t.height)):(i.moveTo(s,e+t.height),i.lineTo(s+t.width,e+t.height),i.lineTo(o,e)),i.fill()}else if(t.type==="crusher_jaw"){const o=s+t.width/2,c=e+t.height/2,g=5;i.fillStyle="#ff4444",i.beginPath(),i.moveTo(s+g,e),i.lineTo(s+t.width-g,e),i.lineTo(o,c-5),i.fill(),i.beginPath(),i.moveTo(s+g,e+t.height),i.lineTo(s+t.width-g,e+t.height),i.lineTo(o,c+5),i.fill(),i.fillStyle="#ffaaaa",i.beginPath(),i.moveTo(s+t.width*.3,e),i.lineTo(s+t.width*.35,e+t.height*.3),i.lineTo(s+t.width*.4,e),i.fill(),i.beginPath(),i.moveTo(s+t.width*.6,e+t.height),i.lineTo(s+t.width*.65,e+t.height*.7),i.lineTo(s+t.width*.7,e+t.height),i.fill()}else if(t.type==="swing_blade"){const o=s+t.width/2,c=e;i.save(),i.translate(o,c);const g=Math.sin(r*2)*.8;i.rotate(g),i.strokeStyle="#eee",i.lineWidth=2,i.beginPath(),i.moveTo(0,0),i.lineTo(0,t.height),i.stroke(),i.fillStyle="#ccc",i.beginPath(),i.ellipse(0,t.height,t.width/2,t.height/2,0,0,Math.PI*2),i.fill(),i.restore()}else if(t.type==="planet"||t.type==="star"){const o=t.type==="star",c=t.width/2;if(o){const g=1+Math.sin(r*5)*.05,y=i.createRadialGradient(a,n,c*.2,a,n,c*g);y.addColorStop(0,"#ffff88"),y.addColorStop(.5,"#ffaa00"),y.addColorStop(1,"rgba(255, 68, 0, 0)"),i.fillStyle=y,i.beginPath(),i.arc(a,n,c*1.2*g,0,Math.PI*2),i.fill(),i.fillStyle="#fff",i.beginPath(),i.arc(a,n,c*.6,0,Math.PI*2),i.fill()}else{const g=i.createRadialGradient(a,n-c*.3,c*.1,a,n,c);g.addColorStop(0,"#4488ff"),g.addColorStop(1,"#002266"),i.fillStyle=g,i.beginPath(),i.arc(a,n,c,0,Math.PI*2),i.fill()}if(t.children&&t.children.length>0){const g=t.customData?.orbitSpeed??1;for(let y=0;y<t.children.length;y++){const Y=t.children[y];if(!Y)continue;const u=r*g+y*(Math.PI*2/t.children.length),m=t.customData?.orbitDistance??t.width*.85,w=a+Math.cos(u)*m,p=n+Math.sin(u)*m,k=w-Y.width/2,_=p-Y.height/2;at(i,Y,k,_,r,d)}}}f&&i.restore()}export{lt as G,at as d};
