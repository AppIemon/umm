class tt{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiPredictedPath=[];constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.reset(),this.initPatterns()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,a=this.mapConfig.difficulty,i=this.basePlayerSize*4;let h=1;a<8?h=2.5-(a-1)/7*.7:a<16?h=1.3-(a-8)/8*.5:a<24?h=.8-(a-16)/8*.35:h=.45-(a-24)/7*.3;let d=1;a<8?d=4:a<16?d=1.5:a<24?d=1.2:d=1;const r=40;for(let e=0;e<10;e++){const s=80+e*12,n=Math.min(s,r),o=s-n,l=[];o>0&&l.push({dx:0,dy:t-o,w:50,h:o,type:"block"}),l.push({dx:0,dy:t-s,w:50,h:n,type:"spike"}),this.patterns.push({obstacles:l,requiredY:"top",width:60})}for(let e=0;e<10;e++){const s=80+e*12,n=Math.min(s,r),o=s-n,l=[];l.push({dx:0,dy:0,w:50,h:n,type:"spike"}),o>0&&l.push({dx:0,dy:n,w:50,h:o,type:"block"}),this.patterns.push({obstacles:l,requiredY:"bottom",width:60})}for(let e=0;e<10;e++){const s=120+e*15,n=t/2-s/2;this.patterns.push({obstacles:[{dx:0,dy:n,w:s,h:s,type:"block"}],requiredY:e%2===0?"top":"bottom",width:s+20,type:"square_block"})}for(let e=0;e<10;e++){const s=(160-e*8)*d,n=Math.max(i,s*h),o=(t-n)/2,l=o+n,p=t-l,f=Math.min(o,r),w=Math.min(p,r),M=[{dx:0,dy:Math.max(0,o-f),w:40,h:Math.max(0,f),type:"spike"},{dx:0,dy:l,w:40,h:Math.max(0,w),type:"spike"}];o>f&&M.push({dx:0,dy:0,w:40,h:o-f,type:"block"}),p>w&&M.push({dx:0,dy:l+w,w:40,h:p-w,type:"block"}),this.patterns.push({obstacles:M,requiredY:"middle",width:50})}for(let e=0;e<10;e++){const s=80+e*10,o=["top","middle","bottom"][e%3];let l=t/2-s/2;o==="top"&&(l=s/2+20),o==="bottom"&&(l=t-s-20),this.patterns.push({obstacles:[{dx:0,dy:l,w:s,h:s,type:"saw"}],requiredY:o==="top"?"bottom":o==="bottom"||e%2===0?"top":"bottom",width:s+30})}for(let e=0;e<10;e++){const s=2+Math.floor(e/3),n=[],o=50,l=Math.min(o,r),p=o-l;for(let f=0;f<s;f++)p>0&&n.push({dx:f*40,dy:t-p,w:35,h:p,type:"block"}),n.push({dx:f*40,dy:t-o,w:35,h:l,type:"spike"});this.patterns.push({obstacles:n,requiredY:"top",width:s*40+20})}for(let e=0;e<10;e++){const s=2+Math.floor(e/3),n=[],o=50,l=Math.min(o,r),p=o-l;for(let f=0;f<s;f++)n.push({dx:f*40,dy:0,w:35,h:l,type:"spike"}),p>0&&n.push({dx:f*40,dy:l,w:35,h:p,type:"block"});this.patterns.push({obstacles:n,requiredY:"bottom",width:s*40+20})}for(let e=0;e<10;e++){const s=[],n=100+e*12,o=Math.min(n,r),l=n-o;s.push({dx:0,dy:t-n,w:45,h:o,type:"spike"}),l>0&&s.push({dx:0,dy:t-l,w:45,h:l,type:"block"}),s.push({dx:60,dy:0,w:45,h:o,type:"spike"}),l>0&&s.push({dx:60,dy:o,w:45,h:l,type:"block"}),e>=5&&(s.push({dx:120,dy:t-n,w:45,h:o,type:"spike"}),l>0&&s.push({dx:120,dy:t-l,w:45,h:l,type:"block"})),this.patterns.push({obstacles:s,requiredY:"middle",width:e>=5?180:120})}for(let e=0;e<10;e++){const s=40+e*35,n=(100-e*4)*d,o=Math.max(i,n*h);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:s,type:"block"},{dx:0,dy:s+o,w:40,h:Math.max(0,t-s-o),type:"block"}],requiredY:s<t/3?"top":s>t*2/3-o?"bottom":"middle",width:50,type:"corridor"})}for(let e=0;e<10;e++){const s=[],o=Math.min(70,r),l=70-o;e%2===0?(s.push({dx:0,dy:t-70,w:50,h:o,type:"spike"}),l>0&&s.push({dx:0,dy:t-l,w:50,h:l,type:"block"}),s.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),s.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(s.push({dx:0,dy:0,w:50,h:o,type:"spike"}),l>0&&s.push({dx:0,dy:o,w:50,h:l,type:"block"}),s.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),s.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:s,requiredY:e%2===0?"top":"bottom",width:80})}for(let e=0;e<10;e++){const l=["top","middle","bottom"][e%3];let p=t/2-15/2;l==="top"&&(p=60),l==="bottom"&&(p=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:p,w:200,h:15,type:"laser"}],requiredY:l==="top"?"bottom":l==="bottom"||e%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let e=0;e<10;e++){const n=e%2===0?"saw":"spike_ball",o=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:o,w:60,h:60,type:n,movement:{type:"updown",range:100+e*10,speed:1+e*.25,phase:e*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let e=0;e<10;e++){const s=3+Math.floor(e/3),n=[];for(let o=0;o<s;o++){const l=50+o*120%(t-100);n.push({dx:o*80,dy:l,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:n,requiredY:"middle",width:s*80,type:"spike_ball_field"})}for(let e=0;e<10;e++){const o=100+e*100%(t-200),l=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h:o,type:"v_laser"},{dx:0,dy:o+l,w:15,h:t-(o+l),type:"v_laser"}],requiredY:o<t/3?"top":o>t*2/3-l?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let e=0;e<10;e++){const s=2+Math.floor(e/2),n=[];for(let o=0;o<s;o++){const l=100+Math.random()*(t-200),p=o*60;n.push({dx:p,dy:l,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:o}})}this.patterns.push({obstacles:n,requiredY:"middle",width:s*60+50,type:"mine_field"})}for(let e=0;e<10;e++){const n=t/2-60,o=[];o.push({dx:0,dy:n,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+e*.1,phase:0}}),this.patterns.push({obstacles:o,requiredY:e%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let e=0;e<10;e++){const s=[],n=t/2-25;s.push({dx:50,dy:n,w:50,h:50,type:"orb"}),s.push({dx:50,dy:0,w:50,h:60,type:"spike"}),s.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:s,requiredY:"middle",width:150})}for(let e=0;e<10;e++){const s=[],n=t/2-20;s.push({dx:0,dy:n,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),s.push({dx:0,dy:n,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:s,requiredY:"middle",width:300,type:"windmill"})}for(let e=0;e<10;e++){const s=[],n=3+e%3;for(let o=0;o<n;o++)s.push({dx:o*40,dy:100+o*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:s,requiredY:"middle",width:n*40,type:"mine_cluster"})}for(let e=0;e<10;e++){const s=[];for(let o=0;o<4;o++)s.push({dx:o*50,dy:50+o*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:s,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.speedMultiplier=1,this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){this.obstacles=t.engineObstacles.map(a=>({...a})),this.portals=t.enginePortals.map(a=>({...a,activated:!1})),this.autoplayLog=[...t.autoplayLog],this.totalLength=t.duration*this.baseSpeed+500}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,a,i,h,d=!0,r=0,e=120,s=2){this.bpm=e,this.measureLength=s;const n=h||t.length*777+Math.floor(i*100),o=d?10:1;for(let l=0;l<o;l++){const p=l+r;this.patternGapMultiplier=Math.pow(1.2,p),this.initPatterns(),this.obstacles=[],this.portals=[],this.trackDuration=i,this.totalLength=i*this.baseSpeed+500,this.autoplayLog=[];let f=this.seededRandom(n+p);if(this.generatePatternBasedMap(t,a,f),this.obstacles.sort((M,T)=>M.x-T.x),this.portals.sort((M,T)=>M.x-T.x),this.removeRedundantObstacles(),!d){console.log(`[MapGen] Map generated quickly with seed: ${n}`);return}if(this.computeAutoplayLog(200,360)){console.log(`[MapGen] Map generated with seed: ${n}, attempt: ${l+1}, gapMultiplier: ${this.patternGapMultiplier.toFixed(2)}`);return}console.log(`[MapGen] AI path failed at attempt ${l+1}, increasing gap...`)}console.warn(`[MapGen] All ${o} attempts failed. Using last generated map.`)}generatePatternBasedMap(t,a,i){const{density:h,portalFrequency:d}=this.mapConfig;let r=0;this.mapConfig.difficulty>=24;let e=200,s=!1,n=!1,o=0,l=0,p="middle",f="speed_1",w;const M=[],q=60/this.bpm*4,c=t.length>0?Math.max(.5,t[0]):.5;for(let m=c;m<this.trackDuration;m+=q)M.push(m);console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${q.toFixed(3)}s, Total Measures: ${M.length}`);const g=[];M.forEach((m,S)=>{const _=a?.find(x=>m>=x.startTime&&m<x.endTime);g.push({time:m,type:"measure",data:{measureIndex:S,intensity:_?.intensity||.5}})}),t.forEach(m=>g.push({time:m,type:"beat",data:m})),g.sort((m,S)=>m.time-S.time);for(const m of g){const S=m.time-r;if(S>0){const _=this.getSpeedMultiplierFromType(f);e+=S*this.baseSpeed*_,r=m.time}if(m.type==="measure"){const x=m.data.intensity||.5;if(m.time<.5)continue;const u=this.mapConfig.difficulty;let y;if(u<8)x<.4?y="speed_0.5":x<.7?y="speed_1":y="speed_2";else if(u<16)x<.6?y="speed_1":y="speed_2";else if(u<24)x<.3?y="speed_0.5":x<.65?y="speed_2":y="speed_3";else{const k=i();x>.8?y="speed_4":k<.15?y="speed_3":k<.2?y="speed_2":y="speed_4"}const A=[];let R=e;(y!==f||l===0)&&(A.push(y),f=y);const H=u>=24?.9:u<8?.35:.75;if(i()<H&&u>=3){const k=i()>.5;k!==n&&(A.push(k?"gravity_yellow":"gravity_blue"),n=k)}const I=u>=24?.3:.8;this.mapConfig.difficulty>=2&&(u>=24?i()>.4&&(A.push(s?"mini_green":"mini_pink"),s=!s):(x>I||x>.6&&i()<.4)&&(A.push(s?"mini_green":"mini_pink"),s=!s)),A.length>0&&(this.generatePortalWithType(R,A[0],i,A.slice(1)),l=R)}else{const _=m.time;if(_<.4)continue;const x=this.getSpeedMultiplierFromType(f),u=Math.max(1,this.mapConfig.difficulty);let y;u<8?y=1.5-(u-1)/7*.5:u<16?y=.65-(u-8)/8*.2:u<24?y=.45-(u-16)/8*.2:y=.25-(u-24)/6*.13,y*=this.patternGapMultiplier,y*=Math.pow(x,.6),y*=.8,u>=16&&f==="speed_0.5"&&(y*=.4),u>=24?s?y*=1.4:(y*=.85,n&&(y*=.95)):u>=16?(y*=.95,s&&(y*=1.1)):s&&(y*=1.25);const A=e,H=(u>=24?180:u>=16?220:u<8?600:280)*y/(this.baseSpeed*x);if(_<o+H)continue;let I=this.getValidPatterns(p,i,w);if(u<8&&(I=I.filter(Y=>!Y.type?.includes("laser")&&!Y.type?.includes("moving")&&!Y.type?.includes("spike_ball")&&!Y.type?.includes("mine")&&!Y.type?.includes("orb"))),I.length===0)continue;let k;if(i()<.2){const Y=2+Math.floor(i()*3),X=this.maxY-this.minY,L=["orb","mine","saw","mini_spike","spike_ball"];for(let G=0;G<Y;G++){const B=L[Math.floor(i()*L.length)],$=50+i()*(X-100),K=30+i()*20;this.obstacles.push({x:e+G*50,y:this.minY+$,width:K,height:K,type:B,initialY:this.minY+$,movement:{type:"none",range:0,speed:0,phase:0}})}o=_+Y*50/(this.baseSpeed*x);continue}const O=I.map(Y=>{let X=1;const L=Y.type||"";return(L.includes("mine")||L.includes("orb")||L.includes("cluster")||L.includes("field"))&&(X=4),L.includes("mini_spike")&&(X=2.5),(L==="square_block"||L==="corridor")&&(X=.25),{p:Y,weight:X}}),E=O.reduce((Y,X)=>Y+X.weight,0);let b=i()*E;k=O[0].p;for(const Y of O)if(b-=Y.weight,b<=0){k=Y.p;break}if(k.type==="square_block"){const Y=900*x;if(Math.abs(A-l)<Y)continue}else{const Y=.4*this.baseSpeed*x;if(Math.abs(A-l)<Y)continue}this.placePatternWithScale(k,A,x,s,y),o=_+k.width*y/(this.baseSpeed*x),p=k.requiredY,w=k.type;const V=k.type==="square_block"?600:50;if(e-l>800*x&&i()<d*2.8){const Y=i()>.5?"gravity_yellow":"gravity_blue",X=k.width*y;this.generatePortalWithType(e+X+V,Y,i),l=e+X+V}}}this.totalLength=e+800}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,a){return t?a>=1.9?78:a>=1.7?72:60:45}getValidPatterns(t,a,i){const d={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let r=this.patterns.filter(e=>d.includes(e.requiredY));return i==="corridor"&&(r=r.filter(e=>e.type!=="corridor")),r}placePattern(t,a){const i=this.minY;for(const h of t.obstacles)this.obstacles.push({x:a+h.dx,y:i+h.dy,width:h.w,height:h.h,type:h.type,initialY:i+h.dy})}placePatternWithScale(t,a,i,h,d){const r=this.minY,e=this.maxY-this.minY;let s=1;i>1.2&&(s*=.85),i<.8&&(s*=1.15),h&&(s*=.75);for(const n of t.obstacles){let o=n.h*s,l=n.w*s,p=n.dy;if(n.dy<e/2)p=n.dy*s;else{const w=e-(n.dy+n.h);p=e-w*s-o}this.obstacles.push({x:a+n.dx*d,y:r+p,width:l,height:o,type:n.type,angle:n.angle,movement:n.movement?{...n.movement}:void 0,initialY:r+p})}}generatePortalWithType(t,a,i,h=[]){const s=this.maxY-this.minY,n=this.minY+80+i()*(s-160),o=[a,...h],l=o.length*50+(o.length-1)*40;o.forEach((M,T)=>{this.portals.push({x:t+T*90,y:n-100/2,width:50,height:100,type:M,activated:!1})});const p=this.basePlayerSize*2.2,f=n-100/2,w=n+100/2;f>this.minY+p&&this.obstacles.push({x:t-10,y:this.minY,width:l+20,height:f-this.minY-p,type:"block",initialY:this.minY}),w<this.maxY-p&&this.obstacles.push({x:t-10,y:w+p,width:l+20,height:this.maxY-(w+p),type:"block",initialY:w+p})}generatePortal(t,a){const h=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"].filter(r=>r==="gravity_blue"?this.portals.some(e=>e.type==="gravity_yellow"):!0),d=h[Math.floor(a()*h.length)]||"speed_1";this.generatePortalWithType(t,d,a)}*computeAutoplayLogGen(t,a){this.autoplayLog=[],this.validationFailureInfo=null;const i=1/60,h=[...this.obstacles].sort((c,g)=>c.x-g.x),d=[...this.portals].sort((c,g)=>c.x-g.x),r={x:t,y:a,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},e=new Set,s=c=>{const g=Math.floor(c.x/(this.baseSpeed*.016)),m=Math.floor(c.y/8);return`${g}_${m}_${c.g?1:0}_${c.sm}_${c.m?1:0}`},n=(c,g,m,S,_=0)=>{if(g<this.minY+m||g>this.maxY-m)return!0;for(let x=0;x<h.length;x++){const u=h[x];if(u.x+u.width<c-50)continue;if(u.x>c+100)break;const y=u.movement?2:0;if(this.checkObstacleCollision(u,c,g,m+_+y,S))return!0}return!1},o=(c,g,m)=>{let S=c.x,_=c.y,x=c.g,u=c.sm,y=c.wa,A=c.m,R=c.pIdx,H=c.time;for(let I=0;I<m;I++){for(;R<d.length&&S>=d[R].x;){const b=d[R];_>=b.y&&_<=b.y+b.height&&(b.type==="gravity_yellow"&&(x=!0),b.type==="gravity_blue"&&(x=!1),b.type.startsWith("speed_")&&(u=this.getSpeedMultiplierFromType(b.type)),b.type==="mini_pink"&&(A=!0),b.type==="mini_green"&&(A=!1),y=this.getEffectiveAngle(A,u)),R++}const k=this.baseSpeed*u,D=k*Math.tan(y*Math.PI/180),O=A?this.miniPlayerSize:this.basePlayerSize;if(S+=k*i,H+=i,_+=D*(x?g?1:-1:g?-1:1)*i,n(S,_,O,H,0))return!1}return!0},l=[r];let p=t,f=0;const w=25e4;let M=null,T=t,q=a;for(;l.length>0;){f++;const c=l.pop();if(c.x>p&&(p=c.x,f%500===0&&(yield p/this.totalLength)),c.x>=this.totalLength){M=c;break}const g=s(c);if(e.has(g))continue;e.add(g);let m=c.g,S=c.sm,_=c.m,x=c.wa,u=c.pIdx;for(;u<d.length&&c.x>=d[u].x;){const v=d[u];c.y>=v.y&&c.y<=v.y+v.height&&(v.type==="gravity_yellow"&&(m=!0),v.type==="gravity_blue"&&(m=!1),v.type.startsWith("speed_")&&(S=this.getSpeedMultiplierFromType(v.type)),v.type==="mini_pink"&&(_=!0),v.type==="mini_green"&&(_=!1),x=this.getEffectiveAngle(_,S)),u++}const y=this.baseSpeed*S,A=y*Math.tan(x*Math.PI/180),R=_?this.miniPlayerSize:this.basePlayerSize,H=c.time+i,I=c.x+y*i,k=c.y+A*(m?1:-1)*i,D=c.y+A*(m?-1:1)*i,O=n(I,k,R,H,0),E=n(I,D,R,H,0);O&&E&&I>T&&(T=I,q=c.y);const b=c.h,V=45,Y=.125/Math.pow(c.sm,.7);let L=c.time-c.lastSwitchTime<Y;if(L){const v=c.y;if(Math.abs(v-360)>25){const j=c.g,z=b,N=j?z?1:-1:z?-1:1;(v>360&&N>0||v<360&&N<0)&&(L=!1)}}let G=!1;const B=!O&&o({...c,x:I,y:k,time:H,g:m,sm:S,m:_,wa:x,pIdx:u,lastSwitchTime:b?c.lastSwitchTime:H},!0,V),$=!E&&o({...c,x:I,y:D,time:H,g:m,sm:S,m:_,wa:x,pIdx:u,lastSwitchTime:b?H:c.lastSwitchTime},!1,V);if(b?B?G=!0:G=!1:$?G=!1:G=!0,B&&$){const v=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let P=0;P<h.length;P++){const C=h[P];if(C.x+C.width<I)continue;if(C.x>I)break;const W=this.getObstacleYRangeAt(C,I,H);W&&v.push(W)}v.sort((P,C)=>P.top-C.top);const F=[];if(v.length>0){let P={...v[0]};for(let C=1;C<v.length;C++){const W=v[C];W.top<=P.bottom?P.bottom=Math.max(P.bottom,W.bottom):(F.push(P),P={...W})}F.push(P)}const j=[];for(let P=0;P<F.length-1;P++)j.push({top:F[P].bottom,bottom:F[P+1].top});let z=j[0],N=1/0;for(const P of j){const C=(P.top+P.bottom)/2,W=Math.abs(c.y-C);if(c.y>=P.top&&c.y<=P.bottom){z=P;break}W<N&&(N=W,z=P)}const U=(z.top+z.bottom)/2,J=Math.abs(k-U),Q=Math.abs(D-U);J<Q?G=!0:Q<J?G=!1:G=b}L&&(b&&B&&(G=!0),!b&&$&&(G=!1));const K=G?[!0,!1]:[!1,!0];for(const v of K)if(v?!O:!E){if(v!==b&&L&&(b?B:$))continue;const F=v!==b?H:c.lastSwitchTime;l.push({x:I,y:v?k:D,time:H,g:m,sm:S,m:_,wa:x,h:v,pIdx:u,lastSwitchTime:F,prev:c})}if(f>w)break}if(M){const c=[];let g=M;for(;g;)c.push({x:g.x,y:g.y,holding:g.h,time:g.time}),g=g.prev;return this.autoplayLog=c.reverse(),!0}else return this.validationFailureInfo={x:T,y:q,nearObstacles:h.filter(c=>c.x>T-400&&c.x<T+600)},!1}computeAutoplayLog(t=200,a=360){const i=this.computeAutoplayLogGen(t,a);let h=i.next();for(;!h.done;)h=i.next();return h.value}async computeAutoplayLogAsync(t,a,i){const h=this.computeAutoplayLogGen(t,a);let d=h.next(),r=performance.now();for(;!d.done;)typeof d.value=="number"&&performance.now()-r>16&&(i(d.value),await new Promise(s=>setTimeout(s,0)),r=performance.now()),d=h.next();return i(1),d.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,a){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const i=this.baseSpeed*this.speedMultiplier;this.waveSpeed=i;const d=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=i*Math.tan(d),this.playerX+=this.waveSpeed*t;let r=null;if(this.isAutoplay&&this.autoplayLog.length>0){const s=this.playerX;let n=null;for(let o=this.lastAutoplayIndex;o<this.autoplayLog.length;o++){const l=this.autoplayLog[o];if(l&&l.x>=s){n=l,this.lastAutoplayIndex=o;break}}if(n){this.isHolding=n.holding;const o=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(o){const p=(s-o.x)/(n.x-o.x);this.playerY=o.y+(n.y-o.y)*Math.max(0,Math.min(1,p)),r=o.time+(n.time-o.time)*Math.max(0,Math.min(1,p))}else this.playerY=n.y,r=n.time;const l=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=l.map(p=>({x:p.x,y:p.y}))}}else{this.aiPredictedPath=[];const s=this.isHolding?-1:1,n=this.isGravityInverted?-s:s;this.playerY+=this.waveAmplitude*n*t}if(this.playerY<this.minY+this.playerSize){this.playerY=this.minY+this.playerSize,this.die("천장에 충돌!"),this.spawnDeathParticles();return}if(this.playerY>this.maxY-this.playerSize){this.playerY=this.maxY-this.playerSize,this.die("바닥에 충돌!"),this.spawnDeathParticles();return}this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const e=r!==null?r:a;this.updateMovingObstacles(e),this.checkPortalCollisions(),this.checkCollisions(e),this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals)if(!t.activated&&!(t.x+t.width<this.playerX-50)){if(t.x>this.playerX+100)break;this.playerX+this.playerSize>t.x&&this.playerX-this.playerSize<t.x+t.width&&this.playerY+this.playerSize>t.y&&this.playerY-this.playerSize<t.y+t.height&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break}}spawnPortalParticles(t){const a=this.getPortalColor(t.type);for(let i=0;i<10;i++){const h=Math.PI*2*i/10,d=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(h)*d,vy:Math.sin(h)*d,life:.6+Math.random()*.3,color:a})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";default:return"?"}}updateParticles(t){for(let a=this.particles.length-1;a>=0;a--){const i=this.particles[a];i&&(i.x+=i.vx*t,i.y+=i.vy*t,i.vy+=150*t,i.life-=t,i.life<=0&&this.particles.splice(a,1))}}getObstacleYRangeAt(t,a,i){if(a<t.x||a>t.x+t.width)return null;let h=t.y,d=t.angle||0;if(i!==void 0&&t.movement){const r=this.getObstacleStateAt(t,i);h=r.y,d=r.angle}if(t.type==="block"){if(d){const r=d*Math.PI/180,e=t.x+t.width/2,s=h+t.height/2,n=Math.cos(r),o=Math.sin(r),l=t.width/2,p=t.height/2,f=[{dx:-l,dy:-p},{dx:l,dy:-p},{dx:l,dy:p},{dx:-l,dy:p}].map(q=>({x:e+q.dx*n-q.dy*o,y:s+q.dx*o+q.dy*n}));let w=1/0,M=-1/0,T=!1;for(let q=0;q<4;q++){const c=f[q],g=f[(q+1)%4];if(c.x<=a&&a<=g.x||g.x<=a&&a<=c.x){if(Math.abs(c.x-g.x)<.1)w=Math.min(w,c.y,g.y),M=Math.max(M,c.y,g.y);else{const m=(a-c.x)/(g.x-c.x),S=c.y+m*(g.y-c.y);w=Math.min(w,S),M=Math.max(M,S)}T=!0}}return T?{top:w,bottom:M}:null}return{top:h,bottom:h+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const r=h>330,e=t.x+t.width/2;let s;if(a<=e){const n=(a-t.x)/(e-t.x);s=r?h+t.height-n*t.height:h+n*t.height}else{const n=(a-e)/(t.x+t.width-e);s=r?h+(1-n)*0+n*t.height:h+t.height-(1-n)*0-n*t.height,s=r?h+n*t.height:h+t.height-n*t.height}return r?{top:s,bottom:h+t.height}:{top:h,bottom:s}}return{top:h,bottom:h+t.height}}checkCollisions(t){for(const a of this.obstacles)if(!(a.x+a.width<this.playerX-80)){if(a.x>this.playerX+100)break;if(this.checkObstacleCollision(a,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,a,i,h,d){let r=t.y,e=t.angle||0;if(d!==void 0&&t.movement){const l=this.getObstacleStateAt(t,d);r=l.y,e=l.angle}const s=e!==0,n=s?Math.max(t.width,t.height):0;if(a+h<=t.x-n||a-h>=t.x+t.width+n||i+h<=r-n||i-h>=r+t.height+n)return!1;const o=[{x:a-h,y:i-h},{x:a+h,y:i-h},{x:a-h,y:i+h},{x:a+h,y:i+h},{x:a,y:i}];if(s&&t.type==="block"){const l={...t,y:r,angle:e};for(const p of o)if(this.isPointInRotatedRect(p.x,p.y,l))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const l=t.x+t.width/2,p=r+t.height/2;let f=.9;t.type==="spike_ball"&&(f=.85),t.type==="mine"&&(f=.9),t.type==="orb"&&(f=.95);const w=t.width/2*f;for(const M of o){const T=M.x-l,q=M.y-p;if(T*T+q*q<w*w)return!0}return!1}if(t.type==="laser"){const l=t.height*.4,p=r+t.height/2;return a+h>t.x&&a-h<t.x+t.width&&i+h>p-l&&i-h<p+l}if(t.type==="v_laser"){const l=t.width*.4,p=t.x+t.width/2;return i+h>r&&i-h<r+t.height&&a+h>p-l&&a-h<p+l}if(t.type==="spike"||t.type==="mini_spike"){const l=r>300,p=t.x+t.width/2,f=7;if(l){for(const w of o)if(this.isPointInTriangle(w.x,w.y,t.x+f,r+t.height-f,p,r+f,t.x+t.width-f,r+t.height-f))return!0}else for(const w of o)if(this.isPointInTriangle(w.x,w.y,t.x+f,r+f,p,r+t.height-f,t.x+t.width-f,r+f))return!0;return!1}return a+h>t.x&&a-h<t.x+t.width&&i+h>r&&i-h<r+t.height}isPointInRotatedRect(t,a,i){const h=(i.angle||0)*Math.PI/180,d=i.x+i.width/2,r=i.y+i.height/2,e=t-d,s=a-r,n=Math.cos(-h),o=Math.sin(-h),l=e*n-s*o,p=e*o+s*n;return Math.abs(l)<=i.width/2&&Math.abs(p)<=i.height/2}removeRedundantObstacles(){const t=new Set,a=this.obstacles.length;for(let i=0;i<a;i++){const h=this.obstacles[i];if(!h.movement)for(let d=0;d<a;d++){if(i===d)continue;const r=this.obstacles[d];if(r.movement)continue;const e=r.angle?Math.max(r.width,r.height):0;if(!(r.x-e>h.x||r.x+r.width+e<h.x+h.width)&&this.isObstacleContained(h,r)){t.add(i);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((i,h)=>!t.has(h)))}isObstacleContained(t,a){if(a.type!=="block"&&a.type!=="spike"&&a.type!=="mini_spike")return!1;const i=this.getObstacleCorners(t);for(const h of i)if(!this.isPointInStaticObstacle(h.x,h.y,a))return!1;return!0}isPointInStaticObstacle(t,a,i){if(i.type==="block")return this.isPointInRotatedRect(t,a,i);if(i.type==="spike"||i.type==="mini_spike"){const h=i.y>300,d=i.x+i.width/2;return h?this.isPointInTriangle(t,a,i.x,i.y+i.height,d,i.y,i.x+i.width,i.y+i.height):this.isPointInTriangle(t,a,i.x,i.y,d,i.y+i.height,i.x+i.width,i.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const a=t.y>300,i=t.x+t.width/2;return a?[{x:t.x,y:t.y+t.height},{x:i,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:i,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const a=t.angle*Math.PI/180,i=t.x+t.width/2,h=t.y+t.height/2,d=Math.cos(a),r=Math.sin(a),e=t.width/2,s=t.height/2;return[{dx:-e,dy:-s},{dx:e,dy:-s},{dx:e,dy:s},{dx:-e,dy:s}].map(n=>({x:i+n.dx*d-n.dy*r,y:h+n.dx*r+n.dy*d}))}return[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,a,i,h,d,r,e,s){const n=Math.abs((i*(r-s)+d*(s-h)+e*(h-r))/2),o=Math.abs((t*(h-r)+i*(r-a)+d*(a-h))/2),l=Math.abs((t*(r-s)+d*(s-a)+e*(a-r))/2),p=Math.abs((t*(s-h)+e*(h-a)+i*(a-s))/2);return Math.abs(n-(o+l+p))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let a=0;a<15;a++){const i=Math.PI*2*a/15,h=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(i)*h,vy:Math.sin(i)*h,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,a){let i=t.y,h=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:d,speed:r,phase:e}=t.movement;i=t.initialY+Math.sin(a*r+e)*d}else if(t.movement.type==="rotate"){const{speed:d,phase:r}=t.movement;h=(a*d+r)*180/Math.PI%360}}return{y:i,angle:h}}updateMovingObstacles(t){for(const a of this.obstacles)if(a.movement){const i=this.getObstacleStateAt(a,t);a.y=i.y,a.movement.type==="rotate"&&(a.angle=i.angle)}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}export{tt as G};
