class et{calculateGap(t,l){const e=Math.max(60,450-t*13);return l?e*1.5:e}generateFromPath(t,l,e,r=[]){if(!t||t.length<2)return[];const p=[],s=50,i=this.calculateGap(l,!1),n=Math.floor(t[0].x/s)*s,o=t[t.length-1].x;if(isNaN(n)||isNaN(o)||o<=n)return[];let a=Math.floor((t[0].y+i/2)/s)*s,h=Math.floor((t[0].y-i/2)/s)*s,d=0,x=0;e.sort((u,c)=>u-c);let y=0,v=!1,f=i*(1/1.4);for(let u=n;u<o;u+=s){const c=u+s/2;for(;d<t.length-1&&t[d+1].x<c;)d++;const g=t[d];if(!g)continue;const k=d<t.length-1?t[d+1]:g,_=g.time;for(;y<r.length&&r[y].time<=_;)v=r[y].isMini,y++;v?f=i*1.3:f=i;const z=f/2,S=u+s;let P=d;for(;P<t.length-1&&t[P+1].x<S;)P++;const X=t[P].y+z;let Y=0;const L=X-a,A=10;if(v?L<-s*1.5?Y=-s*2:L<-A?Y=-s:L>s*1.5?Y=s*2:L>A&&(Y=s):L<-A?Y=-s:L>A&&(Y=s),Y<0){const M=Y===-s*2?"steep_triangle":"triangle",b=Math.abs(Y);a+=Y;const w=a;p.push({type:M,x:u,y:w,width:s,height:b,rotation:0}),this.fillBelow(p,u,w+b,s)}else if(Y>0){const M=Y===s*2?"steep_triangle":"triangle",b=Math.abs(Y),w=a;p.push({type:M,x:u,y:w,width:s,height:b,rotation:90}),this.fillBelow(p,u,w+b,s),a+=Y}else{const m=a;p.push({type:"block",x:u,y:m,width:s,height:s}),this.fillBelow(p,u,m+s,s)}const H=Y;if(H<0){const M=H===-s*2?"steep_triangle":"triangle",b=Math.abs(H);h+=H;const w=h;p.push({type:M,x:u,y:w,width:s,height:b,rotation:180}),this.fillAbove(p,u,w,s)}else if(H>0){const M=H===s*2?"steep_triangle":"triangle",b=Math.abs(H),w=h;p.push({type:M,x:u,y:w,width:s,height:b,rotation:-90}),this.fillAbove(p,u,w,s),h+=H}else{const m=h-s;p.push({type:"block",x:u,y:m,width:s,height:s}),this.fillAbove(p,u,m,s)}const O=Math.abs(Math.sin(u*.123+a*.456));if(Y===0&&f>100&&O<.2){a-g.y;const m=40;O<.1?g.y<a-m-20?p.push({type:"spike",x:u,y:a-m,width:s,height:m}):g.y<a-20-20&&p.push({type:"mini_spike",x:u+10,y:a-20,width:30,height:20}):g.y>h+m+20?p.push({type:"spike",x:u,y:h,width:s,height:m,rotation:180}):g.y>h+20+20&&p.push({type:"mini_spike",x:u+10,y:h,width:30,height:20,rotation:180})}if(O>.95&&f>200){const M=(a+h)/2;let b=M;g.y<M?b=M+(a-M)*.5:b=M-(M-h)*.5,Math.abs(b-g.y)>80&&p.push({type:"mine",x:u+10,y:b-30/2,width:30,height:30,isHitbox:!0})}for(;x<e.length&&e[x]<g.time;)x++;for(;x<e.length&&e[x]<=k.time;)e[x],p.push({type:"orb",x:u+25,y:(a+h)/2-40,width:80,height:80,isHitbox:!1}),x++}return p}fillBelow(t,l,e,r){const s=1e3-e;s>0&&t.push({type:"block",x:l,y:e,width:r,height:s,isHitbox:!0})}fillAbove(t,l,e,r){const i=e- -500;i>0&&t.push({type:"block",x:l,y:-500,width:r,height:i,isHitbox:!0})}}class it{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiPredictedPath=[];constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.reset(),this.reset()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,l=this.mapConfig.difficulty,e=this.basePlayerSize*4;let r=1;l<8?r=2.5-(l-1)/7*.7:l<16?r=1.3-(l-8)/8*.5:l<24?r=.8-(l-16)/8*.35:r=.45-(l-24)/7*.3;let p=1;l<8?p=4:l<16?p=1.5:l<24?p=1.2:p=1;const s=40;for(let i=0;i<10;i++){const n=80+i*12,o=Math.min(n,s),a=n-o,h=[];a>0&&h.push({dx:0,dy:t-a,w:50,h:a,type:"block"}),h.push({dx:0,dy:t-n,w:50,h:o,type:"spike"}),this.patterns.push({obstacles:h,requiredY:"top",width:60})}for(let i=0;i<10;i++){const n=80+i*12,o=Math.min(n,s),a=n-o,h=[];h.push({dx:0,dy:0,w:50,h:o,type:"spike"}),a>0&&h.push({dx:0,dy:o,w:50,h:a,type:"block"}),this.patterns.push({obstacles:h,requiredY:"bottom",width:60})}for(let i=0;i<10;i++){const n=120+i*15,o=t/2-n/2;this.patterns.push({obstacles:[{dx:0,dy:o,w:n,h:n,type:"block"}],requiredY:i%2===0?"top":"bottom",width:n+20,type:"square_block"})}for(let i=0;i<10;i++){const n=(160-i*8)*p,o=Math.max(e,n*r),a=(t-o)/2,h=a+o,d=t-h,x=Math.min(a,s),y=Math.min(d,s),v=[{dx:0,dy:Math.max(0,a-x),w:40,h:Math.max(0,x),type:"spike"},{dx:0,dy:h,w:40,h:Math.max(0,y),type:"spike"}];a>x&&v.push({dx:0,dy:0,w:40,h:a-x,type:"block"}),d>y&&v.push({dx:0,dy:h+y,w:40,h:d-y,type:"block"}),this.patterns.push({obstacles:v,requiredY:"middle",width:50})}for(let i=0;i<10;i++){const n=80+i*10,a=["top","middle","bottom"][i%3];let h=t/2-n/2;a==="top"&&(h=n/2+20),a==="bottom"&&(h=t-n-20),this.patterns.push({obstacles:[{dx:0,dy:h,w:n,h:n,type:"saw"}],requiredY:a==="top"?"bottom":a==="bottom"||i%2===0?"top":"bottom",width:n+30})}for(let i=0;i<10;i++){const n=2+Math.floor(i/3),o=[],a=50,h=Math.min(a,s),d=a-h;for(let x=0;x<n;x++)d>0&&o.push({dx:x*40,dy:t-d,w:35,h:d,type:"block"}),o.push({dx:x*40,dy:t-a,w:35,h,type:"spike"});this.patterns.push({obstacles:o,requiredY:"top",width:n*40+20})}for(let i=0;i<10;i++){const n=2+Math.floor(i/3),o=[],a=50,h=Math.min(a,s),d=a-h;for(let x=0;x<n;x++)o.push({dx:x*40,dy:0,w:35,h,type:"spike"}),d>0&&o.push({dx:x*40,dy:h,w:35,h:d,type:"block"});this.patterns.push({obstacles:o,requiredY:"bottom",width:n*40+20})}for(let i=0;i<10;i++){const n=[],o=100+i*12,a=Math.min(o,s),h=o-a;n.push({dx:0,dy:t-o,w:45,h:a,type:"spike"}),h>0&&n.push({dx:0,dy:t-h,w:45,h,type:"block"}),n.push({dx:60,dy:0,w:45,h:a,type:"spike"}),h>0&&n.push({dx:60,dy:a,w:45,h,type:"block"}),i>=5&&(n.push({dx:120,dy:t-o,w:45,h:a,type:"spike"}),h>0&&n.push({dx:120,dy:t-h,w:45,h,type:"block"})),this.patterns.push({obstacles:n,requiredY:"middle",width:i>=5?180:120})}for(let i=0;i<10;i++){const n=40+i*35,o=(100-i*4)*p,a=Math.max(e,o*r);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:n,type:"block"},{dx:0,dy:n+a,w:40,h:Math.max(0,t-n-a),type:"block"}],requiredY:n<t/3?"top":n>t*2/3-a?"bottom":"middle",width:50,type:"corridor"})}for(let i=0;i<10;i++){const n=[],a=Math.min(70,s),h=70-a;i%2===0?(n.push({dx:0,dy:t-70,w:50,h:a,type:"spike"}),h>0&&n.push({dx:0,dy:t-h,w:50,h,type:"block"}),n.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),n.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(n.push({dx:0,dy:0,w:50,h:a,type:"spike"}),h>0&&n.push({dx:0,dy:a,w:50,h,type:"block"}),n.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),n.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:n,requiredY:i%2===0?"top":"bottom",width:80})}for(let i=0;i<10;i++){const h=["top","middle","bottom"][i%3];let d=t/2-15/2;h==="top"&&(d=60),h==="bottom"&&(d=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:d,w:200,h:15,type:"laser"}],requiredY:h==="top"?"bottom":h==="bottom"||i%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let i=0;i<10;i++){const o=i%2===0?"saw":"spike_ball",a=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:a,w:60,h:60,type:o,movement:{type:"updown",range:100+i*10,speed:1+i*.25,phase:i*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let i=0;i<10;i++){const n=3+Math.floor(i/3),o=[];for(let a=0;a<n;a++){const h=50+a*120%(t-100);o.push({dx:a*80,dy:h,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:o,requiredY:"middle",width:n*80,type:"spike_ball_field"})}for(let i=0;i<10;i++){const a=100+i*100%(t-200),h=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h:a,type:"v_laser"},{dx:0,dy:a+h,w:15,h:t-(a+h),type:"v_laser"}],requiredY:a<t/3?"top":a>t*2/3-h?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let i=0;i<10;i++){const n=2+Math.floor(i/2),o=[];for(let a=0;a<n;a++){const h=100+Math.random()*(t-200),d=a*60;o.push({dx:d,dy:h,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:a}})}this.patterns.push({obstacles:o,requiredY:"middle",width:n*60+50,type:"mine_field"})}for(let i=0;i<10;i++){const o=t/2-60,a=[];a.push({dx:0,dy:o,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+i*.1,phase:0}}),this.patterns.push({obstacles:a,requiredY:i%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let i=0;i<10;i++){const n=[],o=t/2-25;n.push({dx:50,dy:o,w:50,h:50,type:"orb"}),n.push({dx:50,dy:0,w:50,h:60,type:"spike"}),n.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:n,requiredY:"middle",width:150})}for(let i=0;i<10;i++){const n=[],o=t/2-20;n.push({dx:0,dy:o,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),n.push({dx:0,dy:o,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:n,requiredY:"middle",width:300,type:"windmill"})}for(let i=0;i<10;i++){const n=[],o=3+i%3;for(let a=0;a<o;a++)n.push({dx:a*40,dy:100+a*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:n,requiredY:"middle",width:o*40,type:"mine_cluster"})}for(let i=0;i<10;i++){const n=[];for(let a=0;a<4;a++)n.push({dx:a*50,dy:50+a*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:n,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.speedMultiplier=1,this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){this.obstacles=t.engineObstacles.map(l=>({...l})),this.portals=t.enginePortals.map(l=>({...l,activated:!1})),this.autoplayLog=t.autoplayLog?[...t.autoplayLog]:[],this.totalLength=t.duration*this.baseSpeed+500,this.lastAutoplayIndex=0,console.log(`[loadMapData] Loaded ${this.obstacles.length} obstacles, ${this.portals.length} portals, ${this.autoplayLog.length} autoplay points`)}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,l,e,r,p=!0,s=0,i=120,n=2,o){this.bpm=i,this.measureLength=n;const a=r||t.length*777+Math.floor(e*100);this.obstacles=[],this.portals=[],this.trackDuration=e,this.totalLength=e*this.baseSpeed+2e3,this.autoplayLog=[];const h=new et,d=this.mapConfig.difficulty;console.log(`[MapGen] Procedural Generation with seed: ${a}, Difficulty: ${d}`);const x=this.seededRandom(a+s),y=this.generatePathBasedMap(t,l,x,o),v=h.generateFromPath(this.autoplayLog,d,t,y);for(const f of v)["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green"].includes(f.type)?this.portals.push({x:f.x,y:f.y,width:f.width||50,height:f.height||160,type:f.type,activated:!1}):this.obstacles.push({x:f.x,y:f.y,width:f.width||50,height:f.height||50,type:f.type,angle:f.rotation||0});this.obstacles.sort((f,u)=>f.x-u.x),this.portals.sort((f,u)=>f.x-u.x),console.log(`[MapGen] Generated ${this.obstacles.length} obstacles, ${this.portals.length} portals from path`)}generatePathBasedMap(t,l,e,r){const p=this.mapConfig.difficulty;this.maxY-this.minY;const s=1/60,n=60/this.bpm*4,o=[],a=t.length>0?Math.max(.5,t[0]):.5;for(let m=a;m<this.trackDuration;m+=n)o.push(m);console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${n.toFixed(3)}s, Total Measures: ${o.length}`);const h=[];let d="speed_1",x=!1,y=!1;const v=[{time:.5,speedType:"speed_1",isInverted:!1,isMini:!1}];if(p>=5){const m=e();m<.3?v[0].speedType="speed_0.5":m<.6&&(v[0].speedType="speed_2")}h.push(...v),d=v[0].speedType;for(const m of o){if(m<1)continue;const b=l?.find(W=>m>=W.startTime&&m<W.endTime)?.intensity||.5;let w;if(p<8)b<.4?w="speed_0.5":b<.7?w="speed_1":w="speed_2";else if(p<16)b<.6?w="speed_1":w="speed_2";else if(p<24)b<.3?w="speed_0.5":b<.65?w="speed_2":w="speed_3";else{const W=e();b>.8||W<.15?w="speed_3":b>.9||W<.25?w="speed_4":W<.45?w="speed_0.5":W<.55?w="speed_2":W<.7?w="speed_1":w=d}const R=p>=24?.9:p<8?.25:.5;let F=x;e()<R&&p>=3&&(F=e()>.5);let E=y;if(p>=2){const W=p>=24?.4:.2;e()<W&&(E=!y)}(w!==d||F!==x||E!==y)&&(h.push({time:m,speedType:w,isInverted:F,isMini:E}),d=w,x=F,y=E)}const f=[],u=[...t].filter(m=>m>=.3).sort((m,M)=>m-M);let c=!1;const g=.25;for(let m=0;m<u.length;m++){const M=u[m],w=(m+1<u.length?u[m+1]:M+1)-M;w<g?(f.push({time:M,action:c?"release":"click"}),c=!c):c?(f.push({time:M,action:"click"}),f.push({time:M+w*.5,action:"release"}),c=!1):(f.push({time:M,action:"click"}),f.push({time:M+w*.5,action:"release"}),c=!1)}f.sort((m,M)=>m.time-M.time);const k=[];for(const m of f){if(k.length>0){const M=k[k.length-1];m.time-M.time<.01&&k.pop()}k.push(m)}f.length=0,f.push(...k),f.sort((m,M)=>m.time-M.time);const _=[];for(const m of f){const M=_[_.length-1];(!M||Math.abs(M.time-m.time)>.03||M.action!==m.action)&&_.push(m)}f.length=0,f.push(..._),this.autoplayLog=[];let z=200,S=360,P=0,G=!1,X=!1,Y=1,L=!1,A=45,H=0,O=0;for(;P<this.trackDuration+1;){for(;O<h.length&&h[O].time<=P;){const R=h[O];Y=this.getSpeedMultiplierFromType(R.speedType),X=R.isInverted,L=R.isMini,A=this.getEffectiveAngle(L,Y),O++}for(;H<f.length&&f[H].time<=P;)G=f[H].action==="click",H++;const m=this.baseSpeed*Y,M=m*Math.tan(A*Math.PI/180);let b;X?b=G?1:-1:b=G?-1:1,S+=M*b*s;const w=70;S<this.minY+w&&(S=this.minY+w),S>this.maxY-w&&(S=this.maxY-w),z+=m*s,this.autoplayLog.push({x:z,y:S,holding:G,time:P}),P+=s}this.totalLength=z+500;for(const m of h){const M=this.autoplayLog.find(W=>Math.abs(W.time-m.time)<.02);if(!M)continue;const b=[],w=h[h.indexOf(m)-1],R=w?.speedType||"speed_1",F=w?.isInverted||!1,E=w?.isMini||!1;m.speedType!==R&&b.push(m.speedType),m.isInverted!==F&&b.push(m.isInverted?"gravity_yellow":"gravity_blue"),m.isMini!==E&&b.push(m.isMini?"mini_pink":"mini_green"),b.length>0&&this.generatePathAlignedPortals(M.x,M.y,b)}}generatePathAlignedPortals(t,l,e){e.forEach((i,n)=>{const o=t+n*110,a=l-160/2;this.portals.push({x:o,y:a,width:50,height:160,type:i,activated:!1});const h=a-this.minY-30;h>20&&this.obstacles.push({x:o-5,y:this.minY,width:60,height:h,type:"block",initialY:this.minY});const d=a+160+30,x=this.maxY-d;x>20&&this.obstacles.push({x:o-5,y:d,width:60,height:x,type:"block",initialY:d})})}isObstacleSafe(t,l,e,r,p=0){const s=this.basePlayerSize+p;for(const i of this.autoplayLog)if(i.x>=t-s&&i.x<=t+e+s&&i.y>=l-s&&i.y<=l+r+s)return!1;return!0}placeObstaclesForPath(t,l,e,r){const p=Math.max(.1,r/30),s=this.basePlayerSize;let i=1,n=!1;const o=[];this.portals.forEach(y=>{if(y.type==="mini_pink")o.push({x:y.x,isMini:!0,speed:i});else if(y.type==="mini_green")o.push({x:y.x,isMini:!1,speed:i});else if(y.type.startsWith("speed_")){const v=parseFloat(y.type.replace("speed_",""));o.push({x:y.x,isMini:n,speed:v})}}),o.sort((y,v)=>y.x-v.x);const a=y=>y<=.5?.4:y<=1?1:y<=2?1.5:2,h=()=>{const y=Math.max(s+5,50-p*35);return n?y*.5:y},d=800;let x=400;console.log(`[MapGen] Starting path obstacle placement - Diff: ${r}`);for(let y=500;y<this.totalLength-300;y+=100){const v=this.autoplayLog.find(S=>Math.abs(S.x-y)<50);if(!v)continue;const f=v.time,u=[...l].reverse().find(S=>S.time<=f);u&&(n=u.isMini,i=this.getSpeedMultiplierFromType(u.speedType));const c=v.y,g=h(),k=a(i);if(y-x<150*k)continue;if(n){this.placeTiltedBlock(y,c,g,60,e),x=y;continue}const _=Math.floor((y-500)/d)%4;_===0?(this.placeBlockWall(y,c,g,e),x=y):_===1?(this.placeTiltedBlock(y,c,g,45,e),x=y):_===2?(this.placeLaserWall(y,c,g,e),x=y):r>=10?(this.placeMovingObstacle(y,c,g,v.time,e),x=y):(this.placeBlockWall(y,c,g,e),x=y),t.find(S=>Math.abs(S.time*this.baseSpeed+200-y)<100)&&e()<.3+p*.3&&this.placeRapidBlocks(y,c,g,3,e)}}placeBlockWall(t,l,e,r){const p=50+Math.floor(r()*30),s=l-e-this.minY;s>30&&this.isObstacleSafe(t,this.minY,p,s,3)&&this.obstacles.push({x:t,y:this.minY,width:p,height:s,type:"block",initialY:this.minY});const i=l+e,n=this.maxY-i;n>30&&this.isObstacleSafe(t,i,p,n,3)&&this.obstacles.push({x:t,y:i,width:p,height:n,type:"block",initialY:i})}placeTiltedBlock(t,l,e,r,p){const s=100+Math.floor(p()*50),i=this.autoplayLog.find(d=>Math.abs(d.x-(t-100))<60),n=this.autoplayLog.find(d=>Math.abs(d.x-(t+100))<60);let o=!0;i&&n?o=n.y<i.y:i&&(o=l<i.y);const a=l-e-s;a>this.minY&&this.isObstacleSafe(t,a,s,s,3)&&this.obstacles.push({x:t,y:a,width:s,height:s,type:"slope",initialY:a,angle:o?r:-r});const h=l+e;if(h+s<this.maxY&&this.isObstacleSafe(t,h,s,s,3)&&this.obstacles.push({x:t,y:h,width:s,height:s,type:"slope",initialY:h,angle:o?-r:r}),p()<.3){const d=40+Math.floor(p()*30),x=t+s+30,y=l-d/2;this.isObstacleSafe(x,y,d,d,3)&&this.obstacles.push({x,y,width:d,height:d,type:"spike_ball",initialY:y})}}placeLaserWall(t,l,e,r){const s=l-e-this.minY-20;s>50&&this.obstacles.push({x:t+10,y:this.minY,width:30,height:s,type:"v_laser",initialY:this.minY});const i=l+e+20,n=this.maxY-i;n>50&&this.obstacles.push({x:t+10,y:i,width:30,height:n,type:"v_laser",initialY:i})}placeMovingObstacle(t,l,e,r,p){const s=40+Math.floor(p()*20),i=80+Math.floor(p()*60),n=1.5+p()*1.5,o=l-e-s-30;o>this.minY+i&&this.obstacles.push({x:t,y:o,width:s,height:s,type:"saw",initialY:o,moveY:{range:i,speed:n}});const a=l+e+30;a+s+i<this.maxY&&this.obstacles.push({x:t,y:a,width:s,height:s,type:"spike_ball",initialY:a,moveY:{range:i,speed:n}})}placeRapidBlocks(t,l,e,r,p){for(let n=0;n<r;n++){const o=t+n*60;if(n%2===0){const h=l-e-this.minY;h>20&&this.isObstacleSafe(o,this.minY,30,h,2)&&this.obstacles.push({x:o,y:this.minY,width:30,height:h,type:"block",initialY:this.minY})}else{const h=l+e,d=this.maxY-h;d>20&&this.isObstacleSafe(o,h,30,d,2)&&this.obstacles.push({x:o,y:h,width:30,height:d,type:"block",initialY:h})}}}getSmallObstacleType(t,l){const e=t();return l<8?e<.4?"spike":e<.7?"mini_spike":"orb":l<16?e<.25?"spike":e<.4?"saw":e<.55?"orb":e<.7?"mini_spike":e<.85?"spike_ball":"mine":l<24?e<.2?"spike":e<.35?"saw":e<.5?"spike_ball":e<.65?"mine":e<.8?"orb":"laser":e<.15?"spike":e<.25?"saw":e<.4?"spike_ball":e<.55?"mine":e<.7?"orb":e<.85?"laser":"v_laser"}getRandomObstacleType(t,l){if(l<8)return t()>.5?"block":"spike";if(l<16){const e=["block","spike","saw","mini_spike"];return e[Math.floor(t()*e.length)]}else if(l<24){const e=["block","spike","saw","laser","spike_ball"];return e[Math.floor(t()*e.length)]}else{const e=["block","spike","saw","laser","spike_ball","mine","orb","v_laser"];return e[Math.floor(t()*e.length)]}}getRandomDecorationType(t,l){if(l<16){const e=["mini_spike","orb"];return e[Math.floor(t()*e.length)]}else{const e=["mine","spike_ball","saw","orb"];return e[Math.floor(t()*e.length)]}}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,l){return t?l>=1.9?78:l>=1.7?72:60:45}getValidPatterns(t,l,e){const p={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let s=this.patterns.filter(i=>p.includes(i.requiredY));return e==="corridor"&&(s=s.filter(i=>i.type!=="corridor")),s}placePattern(t,l){const e=this.minY;for(const r of t.obstacles)this.obstacles.push({x:l+r.dx,y:e+r.dy,width:r.w,height:r.h,type:r.type,initialY:e+r.dy})}placePatternWithScale(t,l,e,r,p){const s=this.minY,i=this.maxY-this.minY;let n=1;e>1.2&&(n*=.85),e<.8&&(n*=1.15),r&&(n*=.75);for(const o of t.obstacles){let a=o.h*n,h=o.w*n,d=o.dy;if(o.dy<i/2)d=o.dy*n;else{const y=i-(o.dy+o.h);d=i-y*n-a}this.obstacles.push({x:l+o.dx*p,y:s+d,width:h,height:a,type:o.type,angle:o.angle,movement:o.movement?{...o.movement}:void 0,initialY:s+d})}}generatePortalWithType(t,l,e,r=[]){const n=this.maxY-this.minY,o=this.minY+80+e()*(n-160),a=[l,...r],h=a.length*50+(a.length-1)*40;a.forEach((v,f)=>{this.portals.push({x:t+f*90,y:o-100/2,width:50,height:100,type:v,activated:!1})});const d=this.basePlayerSize*2.2,x=o-100/2,y=o+100/2;x>this.minY+d&&this.obstacles.push({x:t-10,y:this.minY,width:h+20,height:x-this.minY-d,type:"block",initialY:this.minY}),y<this.maxY-d&&this.obstacles.push({x:t-10,y:y+d,width:h+20,height:this.maxY-(y+d),type:"block",initialY:y+d})}generatePortal(t,l){let e=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"];const r=this.mapConfig.difficulty;r<8?e=e.filter(i=>!["speed_2","speed_3","speed_4"].includes(i)):r<16?e=e.filter(i=>!["speed_3","speed_4"].includes(i)):r<24&&(e=e.filter(i=>i!=="speed_4"));const p=e.filter(i=>i==="gravity_blue"?this.portals.some(n=>n.type==="gravity_yellow"):!0),s=p[Math.floor(l()*p.length)]||"speed_1";this.generatePortalWithType(t,s,l)}*computeAutoplayLogGen(t,l){this.autoplayLog=[],this.validationFailureInfo=null;const e=1/30,r=[...this.obstacles].sort((c,g)=>c.x-g.x),p=[...this.portals].sort((c,g)=>c.x-g.x),s={x:t,y:l,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},i=new Set,n=c=>{const g=Math.floor(c.x/(this.baseSpeed*.033)),k=Math.floor(c.y/12);return`${g}_${k}_${c.g?1:0}_${Math.round(c.sm*10)}_${c.m?1:0}`},o=(c,g,k,_,z=0)=>{if(g<this.minY+k||g>this.maxY-k)return!0;for(let S=0;S<r.length;S++){const P=r[S];if(P.x+P.width<c-50)continue;if(P.x>c+100)break;const G=P.movement?2:0;if(this.checkObstacleCollision(P,c,g,k+z+G,_))return!0}return!1},a=(c,g,k)=>{let _=c.x,z=c.y,S=c.g,P=c.sm,G=c.wa,X=c.m,Y=c.pIdx,L=c.time;for(let A=0;A<k;A++){for(;Y<p.length&&_>=p[Y].x;){const b=p[Y];z>=b.y&&z<=b.y+b.height&&(b.type==="gravity_yellow"&&(S=!0),b.type==="gravity_blue"&&(S=!1),b.type.startsWith("speed_")&&(P=this.getSpeedMultiplierFromType(b.type)),b.type==="mini_pink"&&(X=!0),b.type==="mini_green"&&(X=!1),G=this.getEffectiveAngle(X,P)),Y++}const H=this.baseSpeed*P,O=H*Math.tan(G*Math.PI/180),m=X?this.miniPlayerSize:this.basePlayerSize;if(_+=H*e,L+=e,z+=O*(S?g?1:-1:g?-1:1)*e,o(_,z,m,L,3))return!1}return!0},h=[s];let d=t,x=0;const y=25e4;let v=null,f=t,u=l;for(;h.length>0;){x++;const c=h.pop();if(c.x>d&&(d=c.x),x%1e3===0&&(yield d/this.totalLength),c.x>=this.totalLength){v=c;break}const g=n(c);if(i.has(g))continue;i.add(g);let k=c.g,_=c.sm,z=c.m,S=c.wa,P=c.pIdx;for(;P<p.length&&c.x>=p[P].x;){const I=p[P];c.y>=I.y&&c.y<=I.y+I.height&&(I.type==="gravity_yellow"&&(k=!0),I.type==="gravity_blue"&&(k=!1),I.type.startsWith("speed_")&&(_=this.getSpeedMultiplierFromType(I.type)),I.type==="mini_pink"&&(z=!0),I.type==="mini_green"&&(z=!1),S=this.getEffectiveAngle(z,_)),P++}const G=this.baseSpeed*_,X=G*Math.tan(S*Math.PI/180),Y=z?this.miniPlayerSize:this.basePlayerSize,L=c.time+e,A=c.x+G*e,H=c.y+X*(k?1:-1)*e,O=c.y+X*(k?-1:1)*e;let m=o(A,H,Y,L,3),M=o(A,O,Y,L,3);const b=Y*.8;!m&&Math.abs(H-c.y)>b&&o((c.x+A)/2,(c.y+H)/2,Y,c.time+e/2,3)&&(m=!0),!M&&Math.abs(O-c.y)>b&&o((c.x+A)/2,(c.y+O)/2,Y,c.time+e/2,3)&&(M=!0),m&&M&&A>f&&(f=A,u=c.y);const w=c.h,R=45,F=.125/Math.pow(c.sm,.7);let W=c.time-c.lastSwitchTime<F;if(W){const I=c.y;if(Math.abs(I-360)>25){const j=c.g,$=w,N=j?$?1:-1:$?-1:1;(I>360&&N>0||I<360&&N<0)&&(W=!1)}}let C=!1;const V=!m&&a({...c,x:A,y:H,time:L,g:k,sm:_,m:z,wa:S,pIdx:P,lastSwitchTime:w?c.lastSwitchTime:L},!0,R),K=!M&&a({...c,x:A,y:O,time:L,g:k,sm:_,m:z,wa:S,pIdx:P,lastSwitchTime:w?L:c.lastSwitchTime},!1,R);if(w?V?C=!0:C=!1:K?C=!1:C=!0,V&&K){const I=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let T=0;T<r.length;T++){const B=r[T];if(B.x+B.width<A)continue;if(B.x>A)break;const q=this.getObstacleYRangeAt(B,A,L);q&&I.push(q)}I.sort((T,B)=>T.top-B.top);const D=[];if(I.length>0){let T={...I[0]};for(let B=1;B<I.length;B++){const q=I[B];q.top<=T.bottom?T.bottom=Math.max(T.bottom,q.bottom):(D.push(T),T={...q})}D.push(T)}const j=[];for(let T=0;T<D.length-1;T++)j.push({top:D[T].bottom,bottom:D[T+1].top});let $=j[0],N=1/0;for(const T of j){const B=(T.top+T.bottom)/2,q=Math.abs(c.y-B);if(c.y>=T.top&&c.y<=T.bottom){$=T;break}q<N&&(N=q,$=T)}const U=($.top+$.bottom)/2,J=Math.abs(H-U),Q=Math.abs(O-U);J<Q?C=!0:Q<J?C=!1:C=w}W&&(w&&V&&(C=!0),!w&&K&&(C=!1));const tt=C?[!0,!1]:[!1,!0];for(const I of tt)if(I?!m:!M){if(I!==w&&W&&(w?V:K))continue;const D=I!==w?L:c.lastSwitchTime;h.push({x:A,y:I?H:O,time:L,g:k,sm:_,m:z,wa:S,h:I,pIdx:P,lastSwitchTime:D,prev:c})}if(x>y)break}if(v){const c=[];let g=v;for(;g;)c.push({x:g.x,y:g.y,holding:g.h,time:g.time}),g=g.prev;return this.autoplayLog=c.reverse(),!0}else return this.validationFailureInfo={x:f,y:u,nearObstacles:r.filter(c=>c.x>f-400&&c.x<f+600)},!1}computeAutoplayLog(t=200,l=360){const e=this.computeAutoplayLogGen(t,l);let r=e.next();for(;!r.done;)r=e.next();return r.value}async computeAutoplayLogAsync(t,l,e){const r=this.computeAutoplayLogGen(t,l);let p=r.next(),s=performance.now();for(;!p.done;)typeof p.value=="number"&&performance.now()-s>16&&(e(p.value),await new Promise(n=>setTimeout(n,0)),s=performance.now()),p=r.next();return e(1),p.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,l){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const e=this.baseSpeed*this.speedMultiplier;this.waveSpeed=e;const p=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=e*Math.tan(p),this.playerX+=this.waveSpeed*t;let s=null;if(this.isAutoplay&&this.autoplayLog.length>0){const n=this.playerX;let o=null;for(let a=this.lastAutoplayIndex;a<this.autoplayLog.length;a++){const h=this.autoplayLog[a];if(h&&h.x>=n){o=h,this.lastAutoplayIndex=a;break}}if(o){this.isHolding=o.holding;const a=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(a){const d=(n-a.x)/(o.x-a.x);this.playerY=a.y+(o.y-a.y)*Math.max(0,Math.min(1,d)),s=a.time+(o.time-a.time)*Math.max(0,Math.min(1,d))}else this.playerY=o.y,s=o.time;const h=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=h.map(d=>({x:d.x,y:d.y}))}}else{this.aiPredictedPath=[];const n=this.isHolding?-1:1,o=this.isGravityInverted?-n:n;this.playerY+=this.waveAmplitude*o*t}if(this.playerY<this.minY+this.playerSize){this.playerY=this.minY+this.playerSize,this.die("천장에 충돌!"),this.spawnDeathParticles();return}if(this.playerY>this.maxY-this.playerSize){this.playerY=this.maxY-this.playerSize,this.die("바닥에 충돌!"),this.spawnDeathParticles();return}this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const i=s!==null?s:l;this.updateMovingObstacles(i),this.checkPortalCollisions(),this.checkCollisions(i),this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals)if(!t.activated&&!(t.x+t.width<this.playerX-50)){if(t.x>this.playerX+100)break;this.playerX+this.playerSize>t.x&&this.playerX-this.playerSize<t.x+t.width&&this.playerY+this.playerSize>t.y&&this.playerY-this.playerSize<t.y+t.height&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break}}spawnPortalParticles(t){const l=this.getPortalColor(t.type);for(let e=0;e<10;e++){const r=Math.PI*2*e/10,p=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(r)*p,vy:Math.sin(r)*p,life:.6+Math.random()*.3,color:l})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";default:return"?"}}updateParticles(t){for(let l=this.particles.length-1;l>=0;l--){const e=this.particles[l];e&&(e.x+=e.vx*t,e.y+=e.vy*t,e.vy+=150*t,e.life-=t,e.life<=0&&this.particles.splice(l,1))}}getObstacleYRangeAt(t,l,e){if(l<t.x||l>t.x+t.width)return null;let r=t.y,p=t.angle||0;if(e!==void 0&&t.movement){const s=this.getObstacleStateAt(t,e);r=s.y,p=s.angle}if(t.type==="block"){if(p){const s=p*Math.PI/180,i=t.x+t.width/2,n=r+t.height/2,o=Math.cos(s),a=Math.sin(s),h=t.width/2,d=t.height/2,x=[{dx:-h,dy:-d},{dx:h,dy:-d},{dx:h,dy:d},{dx:-h,dy:d}].map(u=>({x:i+u.dx*o-u.dy*a,y:n+u.dx*a+u.dy*o}));let y=1/0,v=-1/0,f=!1;for(let u=0;u<4;u++){const c=x[u],g=x[(u+1)%4];if(c.x<=l&&l<=g.x||g.x<=l&&l<=c.x){if(Math.abs(c.x-g.x)<.1)y=Math.min(y,c.y,g.y),v=Math.max(v,c.y,g.y);else{const k=(l-c.x)/(g.x-c.x),_=c.y+k*(g.y-c.y);y=Math.min(y,_),v=Math.max(v,_)}f=!0}}return f?{top:y,bottom:v}:null}return{top:r,bottom:r+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const s=r>330,i=t.x+t.width/2;let n;if(l<=i){const o=(l-t.x)/(i-t.x);n=s?r+t.height-o*t.height:r+o*t.height}else{const o=(l-i)/(t.x+t.width-i);n=s?r+(1-o)*0+o*t.height:r+t.height-(1-o)*0-o*t.height,n=s?r+o*t.height:r+t.height-o*t.height}return s?{top:n,bottom:r+t.height}:{top:r,bottom:n}}if(t.type==="slope"){const s=(l-t.x)/t.width;if(p>0){const i=r+t.height*(1-s);return{top:r,bottom:i}}else{const i=r+t.height*s;return{top:r,bottom:i}}}if(t.type==="triangle"||t.type==="steep_triangle"){const s=(l-t.x)/t.width;return{top:r+t.height*(1-s),bottom:r+t.height}}return{top:r,bottom:r+t.height}}checkCollisions(t){for(const l of this.obstacles)if(!(l.x+l.width<this.playerX-80)){if(l.x>this.playerX+100)break;if(this.checkObstacleCollision(l,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,l,e,r,p){let s=t.y,i=t.angle||0;if(p!==void 0&&t.movement){const f=this.getObstacleStateAt(t,p);s=f.y,i=f.angle}const n=10,o=Math.max(t.width,n),a=Math.max(t.height,n),h=t.x-(o-t.width)/2,d=s-(a-t.height)/2,x=i!==0,y=[{x:l-r,y:e-r},{x:l+r,y:e-r},{x:l-r,y:e+r},{x:l+r,y:e+r},{x:l,y:e}];if(x){const f=h+o/2,u=d+a/2,c=-i*Math.PI/180;y.forEach(g=>{const k=g.x-f,_=g.y-u;g.x=f+k*Math.cos(c)-_*Math.sin(c),g.y=u+k*Math.sin(c)+_*Math.cos(c)})}const v=y.some(f=>f.x>=h&&f.x<=h+o&&f.y>=d&&f.y<=d+a);if(!v&&t.type!=="slope"&&t.type!=="spike"&&t.type!=="mini_spike")return!1;if(t.type==="block")return v;if(t.type==="slope"){let f;t.angle>0?f=[{x:h,y:d+a},{x:h+o,y:d},{x:h,y:d}]:f=[{x:h+o,y:d+a},{x:h,y:d},{x:h+o,y:d}];for(const u of y)if(this.isPointInTriangle(u.x,u.y,f[0].x,f[0].y,f[1].x,f[1].y,f[2].x,f[2].y))return!0;return!1}if(t.type==="triangle"||t.type==="steep_triangle"){const f=[{x:h,y:d+a},{x:h+o,y:d+a},{x:h+o,y:d}];for(const u of y)if(this.isPointInTriangle(u.x,u.y,f[0].x,f[0].y,f[1].x,f[1].y,f[2].x,f[2].y))return!0;return!1}if(t.type==="spike"||t.type==="mini_spike"){const u=d>300?[{x:h,y:d+a},{x:h+o/2,y:d},{x:h+o,y:d+a}]:[{x:h,y:d},{x:h+o/2,y:d+a},{x:h+o,y:d}];for(const c of y)if(this.isPointInTriangle(c.x,c.y,u[0].x,u[0].y,u[1].x,u[1].y,u[2].x,u[2].y))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const f=h+o/2,u=d+a/2,c=o/2*.9;for(const g of y){const k=g.x-f,_=g.y-u;if(k*k+_*_<c*c)return!0}return!1}if(t.type==="laser"){const f=a*.4,u=d+a/2;return y.some(c=>c.x>=h&&c.x<=h+o&&c.y>=u-f&&c.y<=u+f)}if(t.type==="v_laser"){const f=o*.4,u=h+o/2;return y.some(c=>c.y>=d&&c.y<=d+a&&c.x>=u-f&&c.x<=u+f)}return!1}isPointInRotatedRect(t,l,e){const r=(e.angle||0)*Math.PI/180,p=e.x+e.width/2,s=e.y+e.height/2,i=t-p,n=l-s,o=Math.cos(-r),a=Math.sin(-r),h=i*o-n*a,d=i*a+n*o;return Math.abs(h)<=e.width/2&&Math.abs(d)<=e.height/2}removeRedundantObstacles(){const t=new Set,l=this.obstacles.length;for(let e=0;e<l;e++){const r=this.obstacles[e];if(!r.movement)for(let p=0;p<l;p++){if(e===p)continue;const s=this.obstacles[p];if(s.movement)continue;const i=s.angle?Math.max(s.width,s.height):0;if(!(s.x-i>r.x||s.x+s.width+i<r.x+r.width)&&this.isObstacleContained(r,s)){t.add(e);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((e,r)=>!t.has(r)))}isObstacleContained(t,l){if(l.type!=="block"&&l.type!=="spike"&&l.type!=="mini_spike")return!1;const e=this.getObstacleCorners(t);for(const r of e)if(!this.isPointInStaticObstacle(r.x,r.y,l))return!1;return!0}isPointInStaticObstacle(t,l,e){if(e.type==="block")return this.isPointInRotatedRect(t,l,e);if(e.type==="spike"||e.type==="mini_spike"){const r=e.y>300,p=e.x+e.width/2;return r?this.isPointInTriangle(t,l,e.x,e.y+e.height,p,e.y,e.x+e.width,e.y+e.height):this.isPointInTriangle(t,l,e.x,e.y,p,e.y+e.height,e.x+e.width,e.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const l=t.y>300,e=t.x+t.width/2;return l?[{x:t.x,y:t.y+t.height},{x:e,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:e,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const l=t.angle*Math.PI/180,e=t.x+t.width/2,r=t.y+t.height/2,p=Math.cos(l),s=Math.sin(l),i=t.width/2,n=t.height/2;return[{dx:-i,dy:-n},{dx:i,dy:-n},{dx:i,dy:n},{dx:-i,dy:n}].map(o=>({x:e+o.dx*p-o.dy*s,y:r+o.dx*s+o.dy*p}))}return t.type==="triangle"||t.type==="steep_triangle"?[{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height},{x:t.x+t.width,y:t.y}]:[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,l,e,r,p,s,i,n){const o=Math.abs((e*(s-n)+p*(n-r)+i*(r-s))/2),a=Math.abs((t*(r-s)+e*(s-l)+p*(l-r))/2),h=Math.abs((t*(s-n)+p*(n-l)+i*(l-s))/2),d=Math.abs((t*(n-r)+i*(r-l)+e*(l-n))/2);return Math.abs(o-(a+h+d))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let l=0;l<15;l++){const e=Math.PI*2*l/15,r=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(e)*r,vy:Math.sin(e)*r,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,l){let e=t.y,r=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:p,speed:s,phase:i}=t.movement;e=t.initialY+Math.sin(l*s+i)*p}else if(t.movement.type==="rotate"){const{speed:p,phase:s}=t.movement;r=(l*p+s)*180/Math.PI%360}}return{y:e,angle:r}}updateMovingObstacles(t){for(const l of this.obstacles)if(l.movement){const e=this.getObstacleStateAt(l,t);l.y=e.y,l.movement.type==="rotate"&&(l.angle=e.angle)}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}export{it as G};
