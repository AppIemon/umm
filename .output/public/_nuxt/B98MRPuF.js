class ct{calculateGap(t,n,e=1){let a;t<=7?a=580-(t-1)*20:t<=15?a=460-(t-8)*17.5:t<=23?a=320-(t-16)*17.5:a=180-(t-24)*15;const c=t>=24?120:160;return a=Math.max(c/e,a)*e,n?a*1.5:a}generateFromPath(t,n,e,a=[],c=1){if(!t||t.length<2)return[];const h=[],s=50,l=this.calculateGap(n,!1,c),o=Math.floor(t[0].x/s)*s,r=t[t.length-1].x;if(isNaN(o)||isNaN(r)||r<=o)return[];const p=["spike","piston_v","hammer","growing_spike","cannon","crusher_jaw"],d=["spike","falling_spike","hammer","swing_blade","piston_v","crusher_jaw"],g=["mine","rotor","spark_mine","laser_beam","planet","star"],u=Y=>{let T=[...Y],B=0;const R=()=>{for(let H=T.length-1;H>0;H--){const G=Math.floor(Math.random()*(H+1));[T[H],T[G]]=[T[G],T[H]]}B=0};return R(),{next:()=>{const H=T[B];return B++,B>=T.length&&R(),H}}},w=u(p),_=u(d),b=u(g);let k=Math.floor((t[0].y+l/2)/s)*s,f=Math.floor((t[0].y-l/2)/s)*s;const y=new Map;let m=0,S=0;e.sort((Y,T)=>Y-T);let M=0,A=!1,x=l*(1/1.4);for(let Y=o;Y<r;Y+=s){const T=Y+s/2;for(;m<t.length-1&&t[m+1].x<T;)m++;const B=t[m];if(!B)continue;const R=m<t.length-1?t[m+1]:B,H=B.time;for(;M<a.length&&a[M].time<=H;)A=a[M].isMini,M++;A?x=l*1.3:x=l;const G=x/2,E=Y+s;let O=m;for(;O<t.length-1&&t[O+1].x<E;)O++;const v=t[O],I=v.y+G,L=v.y-G;let C=0,X=0,z=1/0,P=-1/0;for(let q=m;q<=O;q++){const $=t[q].y;$<z&&(z=$),$>P&&(P=$)}const K=A?7.5:15,Q=5,at=P+K+Q,lt=z-K-Q,rt=10,D=10,N=I-k,U=s*5;Math.abs(N)>rt&&(C=Math.sign(N)*Math.min(U,Math.abs(N)),Math.abs(C)<s*1.5&&(C=Math.sign(C)*s));const Z=L-f;if(Math.abs(Z)>D&&(X=Math.sign(Z)*Math.min(U,Math.abs(Z)),Math.abs(X)<s*1.5&&(X=Math.sign(X)*s)),C<0&&k+C<at&&(C=at-k,C>0&&(C=0)),X>0&&f+X>lt&&(X=lt-f,X<0&&(X=0)),y.set(Y,{floorY:k,ceilY:f}),C<0){const $=C===-s*2?"steep_triangle":"triangle",V=Math.abs(C);k+=C;const j=k;h.push({type:$,x:Y,y:j,width:s,height:V,rotation:0}),this.fillBelow(h,Y,j+V,s)}else if(C>0){const $=C===s*2?"steep_triangle":"triangle",V=Math.abs(C),j=k;h.push({type:$,x:Y,y:j,width:s,height:V,rotation:90}),this.fillBelow(h,Y,j+V,s),k+=C}else{const q=k;h.push({type:"block",x:Y,y:q,width:s,height:s}),this.fillBelow(h,Y,q+s,s)}if(X<0){const $=X===-s*2?"steep_triangle":"triangle",V=Math.abs(X);f+=X;const j=f;h.push({type:$,x:Y,y:j,width:s,height:V,rotation:180}),this.fillAbove(h,Y,j,s)}else if(X>0){const $=X===s*2?"steep_triangle":"triangle",V=Math.abs(X),j=f;h.push({type:$,x:Y,y:j,width:s,height:V,rotation:-90}),this.fillAbove(h,Y,j,s),f+=X}else{const q=f-s;h.push({type:"block",x:Y,y:q,width:s,height:s}),this.fillAbove(h,Y,q,s)}const st=Math.abs(Math.sin(Y*.123+k*.456)),ht=.2+n/30*.35;let it=!1,nt=!1,F=0;n>=3&&(F=.3),n>=10&&(F=.5),n>=20&&(F=.7);const J=C===0,tt=X===0;if(x>120&&(J&&Math.random()<F&&(it=!0),tt&&Math.random()<F&&(!it||n>15)&&(nt=!0)),C===0&&X===0&&st<ht||it||nt){const q=.8+Math.random()*.4;let $=40;n<=5?$=25:n>20&&($=50);const V=$*q;let j=Y/s%2===0;if(it&&!nt?j=!0:nt&&!it?j=!1:it&&nt&&(j=Math.random()<.5),j){const et=w.next();B.y<k-V-20&&h.push({type:et==="spike"&&n<=8?"mini_spike":et,x:Y,y:k-V,width:s,height:V,movement:this.getRandomMovement(et,.4/c,c)})}else{const et=_.next();let ot=f;et==="falling_spike"&&B.y-f>250&&(ot=B.y-250),B.y>ot+V+20&&h.push({type:et==="spike"&&n<=8?"mini_spike":et,x:Y,y:ot,width:s,height:V,rotation:180,movement:this.getRandomMovement(et,.4/c,c)})}}if(st>.94&&x>220){const q=(n<=7?20:35)*(.9+Math.random()*.2),$=(k+f)/2;let V=B.y<$?$+(k-$)*.5:$-($-f)*.5;const j=b.next();let et,ot;if(j==="planet"||j==="star"){const pt=j==="planet"?2:3;ot={orbitSpeed:1+Math.random(),orbitDistance:q*.8,orbitCount:pt},et=Array(pt).fill(0).map(()=>({type:"moon",x:0,y:0,width:q*.4,height:q*.4,isHitbox:!0}))}h.push({type:j,x:Y+10,y:V-q/2,width:q,height:q,isHitbox:!0,rotation:j==="laser_beam"?90:0,children:et,customData:ot,movement:this.getRandomMovement(j,.6/c,c)})}for(;S<e.length&&e[S]<B.time;)S++;for(;S<e.length&&e[S]<=R.time;){const q=(k+f)/2-40;q>=f&&q+80<=k&&h.push({type:"orb",x:Y+25,y:q,width:80,height:80,isHitbox:!1}),S++}}const W=h.filter(Y=>{if(["block","triangle","steep_triangle"].includes(Y.type)||["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green","teleport_in","teleport_out"].includes(Y.type)||Y.type==="orb")return!0;const T=y.get(Math.floor(Y.x/s)*s);if(!T)return!0;const B=Y.y;return!(Y.y+(Y.height||0)<=T.ceilY-5||B>=T.floorY+5)});return this.consolidateBlocks(W)}consolidateBlocks(t){const n=t.filter(h=>h.type==="block"),e=t.filter(h=>h.type!=="block");if(n.length<2)return t;const a=[];n.sort((h,s)=>h.isHitbox!==s.isHitbox?h.isHitbox?1:-1:h.y!==s.y?h.y-s.y:h.height!==s.height?(h.height||0)-(s.height||0):h.x-s.x);let c=n[0];for(let h=1;h<n.length;h++){const s=n[h],l=Math.abs(c.x+(c.width||0)-s.x)<.1,o=c.y===s.y,r=c.height===s.height,p=c.isHitbox===s.isHitbox;l&&o&&r&&p?c.width=(c.width||0)+(s.width||0):(a.push(c),c=s)}return a.push(c),[...a,...e]}fillBelow(t,n,e,a){const h=1e3-e;h>0&&t.push({type:"block",x:n,y:e,width:a,height:h,isHitbox:!0})}fillAbove(t,n,e,a){const s=e- -500;s>0&&t.push({type:"block",x:n,y:-500,width:a,height:s,isHitbox:!0})}getRandomMovement(t,n,e=1){if(Math.random()>n)return;const a=["saw","mine","spike_ball","rotor","cannon","spark_mine","planet","star"].includes(t),c=!a||Math.random()<.3,h=1/e,s=1/e;return a&&!c?{type:"rotate",speed:(1+Math.random()*2)*s,range:360,phase:Math.random()*Math.PI*2}:{type:"updown",speed:(1.5+Math.random()*2.5)*s,range:(30+Math.random()*70)*h,phase:Math.random()*Math.PI*2}}}class yt{playerX=200;playerY=360;playerSize=12;basePlayerSize=12;miniPlayerSize=12;baseSpeed=350;waveSpeed=350;waveAmplitude=350;isHolding=!1;waveAngle=45;miniWaveAngle=60;getDynamicBaseSpeed(){const t=this.mapConfig.difficulty;return t<=2?260:t<=7?300:t<=12?330:350}isGravityInverted=!1;speedMultiplier=1;isMini=!1;minY=140;maxY=580;obstacles=[];portals=[];patterns=[];mapConfig={density:1,portalFrequency:.15,difficulty:5};cameraX=0;isPlaying=!1;isDead=!1;failReason="";startTime=0;showHitboxes=!1;score=0;progress=0;totalLength=0;validationFailureInfo=null;trackDuration=0;trail=[];particles=[];aiStateTimer=0;aiPredictedPath=[];beatTimes=[];boss={active:!1,x:0,y:0,health:100,maxHealth:100,state:"idle",attackTimer:0,projectiles:[]};lastStateEvents=[];lastBeatActions=[];lastMeasureIndex=-1;isMeasureHighlight=!1;onPortalActivation=null;constructor(t){t&&(this.mapConfig={...this.mapConfig,...t}),this.baseSpeed=this.getDynamicBaseSpeed(),this.reset()}initPatterns(){this.patterns=[];const t=this.maxY-this.minY,n=this.mapConfig.difficulty,e=this.basePlayerSize*4;let a=1;n<8?a=2.5-(n-1)/7*.7:n<16?a=1.3-(n-8)/8*.5:n<24?a=.8-(n-16)/8*.35:a=.45-(n-24)/7*.3;let c=1;n<8?c=4:n<16?c=1.5:n<24?c=1.2:c=1;const h=40;for(let s=0;s<10;s++){const l=80+s*12,o=Math.min(l,h),r=l-o,p=[];r>0&&p.push({dx:0,dy:t-r,w:50,h:r,type:"block"}),p.push({dx:0,dy:t-l,w:50,h:o,type:"spike"}),this.patterns.push({obstacles:p,requiredY:"top",width:60})}for(let s=0;s<10;s++){const l=80+s*12,o=Math.min(l,h),r=l-o,p=[];p.push({dx:0,dy:0,w:50,h:o,type:"spike"}),r>0&&p.push({dx:0,dy:o,w:50,h:r,type:"block"}),this.patterns.push({obstacles:p,requiredY:"bottom",width:60})}for(let s=0;s<10;s++){const l=120+s*15,o=t/2-l/2;this.patterns.push({obstacles:[{dx:0,dy:o,w:l,h:l,type:"block"}],requiredY:s%2===0?"top":"bottom",width:l+20,type:"square_block"})}for(let s=0;s<10;s++){const l=(160-s*8)*c,o=Math.max(e,l*a),r=(t-o)/2,p=r+o,d=t-p,g=Math.min(r,h),u=Math.min(d,h),w=[{dx:0,dy:Math.max(0,r-g),w:40,h:Math.max(0,g),type:"spike"},{dx:0,dy:p,w:40,h:Math.max(0,u),type:"spike"}];r>g&&w.push({dx:0,dy:0,w:40,h:r-g,type:"block"}),d>u&&w.push({dx:0,dy:p+u,w:40,h:d-u,type:"block"}),this.patterns.push({obstacles:w,requiredY:"middle",width:50})}for(let s=0;s<10;s++){const l=80+s*10,r=["top","middle","bottom"][s%3];let p=t/2-l/2;r==="top"&&(p=l/2+20),r==="bottom"&&(p=t-l-20),this.patterns.push({obstacles:[{dx:0,dy:p,w:l,h:l,type:"saw"}],requiredY:r==="top"?"bottom":r==="bottom"||s%2===0?"top":"bottom",width:l+30})}for(let s=0;s<10;s++){const l=2+Math.floor(s/3),o=[],r=50,p=Math.min(r,h),d=r-p;for(let g=0;g<l;g++)d>0&&o.push({dx:g*40,dy:t-d,w:35,h:d,type:"block"}),o.push({dx:g*40,dy:t-r,w:35,h:p,type:"spike"});this.patterns.push({obstacles:o,requiredY:"top",width:l*40+20})}for(let s=0;s<10;s++){const l=2+Math.floor(s/3),o=[],r=50,p=Math.min(r,h),d=r-p;for(let g=0;g<l;g++)o.push({dx:g*40,dy:0,w:35,h:p,type:"spike"}),d>0&&o.push({dx:g*40,dy:p,w:35,h:d,type:"block"});this.patterns.push({obstacles:o,requiredY:"bottom",width:l*40+20})}for(let s=0;s<10;s++){const l=[],o=100+s*12,r=Math.min(o,h),p=o-r;l.push({dx:0,dy:t-o,w:45,h:r,type:"spike"}),p>0&&l.push({dx:0,dy:t-p,w:45,h:p,type:"block"}),l.push({dx:60,dy:0,w:45,h:r,type:"spike"}),p>0&&l.push({dx:60,dy:r,w:45,h:p,type:"block"}),s>=5&&(l.push({dx:120,dy:t-o,w:45,h:r,type:"spike"}),p>0&&l.push({dx:120,dy:t-p,w:45,h:p,type:"block"})),this.patterns.push({obstacles:l,requiredY:"middle",width:s>=5?180:120})}for(let s=0;s<10;s++){const l=40+s*35,o=(100-s*4)*c,r=Math.max(e,o*a);this.patterns.push({obstacles:[{dx:0,dy:0,w:40,h:l,type:"block"},{dx:0,dy:l+r,w:40,h:Math.max(0,t-l-r),type:"block"}],requiredY:l<t/3?"top":l>t*2/3-r?"bottom":"middle",width:50,type:"corridor"})}for(let s=0;s<10;s++){const l=[],r=Math.min(70,h),p=70-r;s%2===0?(l.push({dx:0,dy:t-70,w:50,h:r,type:"spike"}),p>0&&l.push({dx:0,dy:t-p,w:50,h:p,type:"block"}),l.push({dx:-20,dy:0,w:15,h:20,type:"mini_spike"}),l.push({dx:55,dy:0,w:15,h:20,type:"mini_spike"})):(l.push({dx:0,dy:0,w:50,h:r,type:"spike"}),p>0&&l.push({dx:0,dy:r,w:50,h:p,type:"block"}),l.push({dx:-20,dy:t-20,w:15,h:20,type:"mini_spike"}),l.push({dx:55,dy:t-20,w:15,h:20,type:"mini_spike"})),this.patterns.push({obstacles:l,requiredY:s%2===0?"top":"bottom",width:80})}for(let s=0;s<10;s++){const p=["top","middle","bottom"][s%3];let d=t/2-15/2;p==="top"&&(d=60),p==="bottom"&&(d=t-60-15),this.patterns.push({obstacles:[{dx:0,dy:d,w:200,h:15,type:"laser"}],requiredY:p==="top"?"bottom":p==="bottom"||s%2===0?"top":"bottom",width:250,type:"laser_pattern"})}for(let s=0;s<10;s++){const o=s%2===0?"saw":"spike_ball",r=t/2-60/2;this.patterns.push({obstacles:[{dx:0,dy:r,w:60,h:60,type:o,movement:{type:"updown",range:100+s*10,speed:1+s*.25,phase:s*Math.PI/4}}],requiredY:"middle",width:100,type:"moving_hazard"})}for(let s=0;s<10;s++){const l=3+Math.floor(s/3),o=[];for(let r=0;r<l;r++){const p=50+r*120%(t-100);o.push({dx:r*80,dy:p,w:40,h:40,type:"spike_ball"})}this.patterns.push({obstacles:o,requiredY:"middle",width:l*80,type:"spike_ball_field"})}for(let s=0;s<10;s++){const r=100+s*100%(t-200),p=150;this.patterns.push({obstacles:[{dx:0,dy:0,w:15,h:r,type:"v_laser"},{dx:0,dy:r+p,w:15,h:t-(r+p),type:"v_laser"}],requiredY:r<t/3?"top":r>t*2/3-p?"bottom":"middle",width:100,type:"vertical_laser_pattern"})}for(let s=0;s<10;s++){const l=2+Math.floor(s/2),o=[];for(let r=0;r<l;r++){const p=100+Math.random()*(t-200),d=r*60;o.push({dx:d,dy:p,w:30,h:30,type:"mine",movement:{type:"updown",range:30,speed:2+Math.random(),phase:r}})}this.patterns.push({obstacles:o,requiredY:"middle",width:l*60+50,type:"mine_field"})}for(let s=0;s<10;s++){const o=t/2-60,r=[];r.push({dx:0,dy:o,w:200,h:30,type:"block",angle:0,movement:{type:"rotate",range:360,speed:1.5+s*.1,phase:0}}),this.patterns.push({obstacles:r,requiredY:s%2===0?"top":"bottom",width:250,type:"spinning_bar"})}for(let s=0;s<10;s++){const l=[],o=t/2-25;l.push({dx:50,dy:o,w:50,h:50,type:"orb"}),l.push({dx:50,dy:0,w:50,h:60,type:"spike"}),l.push({dx:50,dy:t-60,w:50,h:60,type:"spike"}),this.patterns.push({obstacles:l,requiredY:"middle",width:150})}for(let s=0;s<10;s++){const l=[],o=t/2-20;l.push({dx:0,dy:o,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:0}}),l.push({dx:0,dy:o,w:240,h:40,type:"block",movement:{type:"rotate",range:360,speed:2,phase:Math.PI/2}}),this.patterns.push({obstacles:l,requiredY:"middle",width:300,type:"windmill"})}for(let s=0;s<10;s++){const l=[],o=3+s%3;for(let r=0;r<o;r++)l.push({dx:r*40,dy:100+r*80%(t-200),w:25,h:25,type:"mine"});this.patterns.push({obstacles:l,requiredY:"middle",width:o*40,type:"mine_cluster"})}for(let s=0;s<10;s++){const l=[];for(let r=0;r<4;r++)l.push({dx:r*50,dy:50+r*150%(t-100),w:30,h:30,type:"orb"});this.patterns.push({obstacles:l,requiredY:"middle",width:200,type:"orb_field"})}}reset(){this.playerX=200,this.playerY=360,this.cameraX=0,this.isHolding=!1,this.isPlaying=!1,this.isDead=!1,this.failReason="",this.score=0,this.progress=0,this.trail=[],this.particles=[],this.obstacles=[],this.portals=[],this.isGravityInverted=!1,this.baseSpeed=this.getDynamicBaseSpeed(),this.waveSpeed=this.baseSpeed*this.speedMultiplier,this.waveAmplitude=this.baseSpeed,this.showHitboxes=!1,this.isMini=!1,this.waveAngle=45,this.playerSize=this.basePlayerSize,this.aiStateTimer=0,this.aiPredictedPath=[],this.lastAutoplayIndex=0}setMapConfig(t){this.mapConfig={...this.mapConfig,...t}}loadMapData(t){if(!t)return;const n=e=>!e||!Array.isArray(e)?[]:e.map(a=>({...a,width:a.width??50,height:a.height??50,angle:a.angle??0,initialY:a.initialY??a.y,movement:a.movement??{type:"none",range:0,speed:0,phase:0},children:a.children?n(a.children):[]}));if(this.obstacles=n(t.engineObstacles||[]),this.portals=n(t.enginePortals||[]).map(e=>({...e,activated:!1})),t.autoplayLog&&Array.isArray(t.autoplayLog)&&t.autoplayLog.length>0&&typeof t.autoplayLog[0]=="number"){const e=[];for(let a=0;a<t.autoplayLog.length;a+=4)e.push({x:t.autoplayLog[a],y:t.autoplayLog[a+1],holding:t.autoplayLog[a+2]===1,time:t.autoplayLog[a+3]});this.autoplayLog=e}else this.autoplayLog=t.autoplayLog?[...t.autoplayLog]:[];this.totalLength=(t.duration||60)*this.getDynamicBaseSpeed()+500,this.lastAutoplayIndex=0,console.log(`[loadMapData] Restored ${this.obstacles.length} obstacles, ${this.portals.length} portals, ${this.autoplayLog.length} points.`)}isAutoplay=!1;autoplayLog=[];lastAutoplayIndex=0;patternGapMultiplier=1;bpm=120;measureLength=2;generateMap(t,n,e,a,c=!0,h=0,s=120,l=2,o,r){this.bpm=s,this.measureLength=l;const p=a||t.length*777+Math.floor(e*100),d=[...this.autoplayLog];this.obstacles=[],this.portals=[],this.beatTimes=t||[],this.trackDuration=e,this.totalLength=e*this.baseSpeed+2e3,this.autoplayLog=[];const g=new ct,u=this.mapConfig.difficulty,w=1+Math.min(.5,h*.05),_=Math.max(.1,1-h*.1);console.log(`[MapGen] Seed: ${p}, Attempt: ${h}, Safety: ${w.toFixed(2)}, Hazard: ${_.toFixed(2)}`);const b=this.seededRandom(p+h);let k=null;if(r){const M=d.find(A=>A.time>=r.time);M&&(k={time:r.time,x:M.x,y:M.y,stateEvents:r.stateEvents,beatActions:r.beatActions})}const f=this.generatePathBasedMap(t,n,b,o,k);this.lastStateEvents=f;let y=0;if(k){y=k.x;const M=r.obstacles.filter(x=>x.x+x.width<=y),A=r.portals.filter(x=>x.x+x.width<=y);this.obstacles=[...M,...this.obstacles],this.portals=[...A,...this.portals]}let m=this.autoplayLog;y>0&&(m=this.autoplayLog.filter(M=>M.x>=y));const S=g.generateFromPath(m,u,t,f,w);for(const M of S)if(["gravity_yellow","gravity_blue","speed_0.25","speed_0.5","speed_1","speed_2","speed_3","speed_4","mini_pink","mini_green"].includes(M.type))this.portals.push({x:M.x,y:this.minY,width:M.width||50,height:this.maxY-this.minY,type:M.type,activated:!1});else{if(!["block","triangle","steep_triangle"].includes(M.type)&&b()>_)continue;this.obstacles.push({x:M.x,y:M.y,width:M.width||50,height:M.height||50,type:M.type,angle:M.rotation||0,movement:M.movement,initialY:M.y,children:M.children,customData:M.customData})}this.obstacles.sort((M,A)=>M.x-A.x),this.portals.sort((M,A)=>M.x-A.x),console.log(`[MapGen] Generated ${this.obstacles.length} obstacles, ${this.portals.length} portals total`)}generatePathBasedMap(t,n,e,a,c){const h=this.mapConfig.difficulty;this.maxY-this.minY;const s=1/60,o=60/this.bpm*4,r=[],p=t.length>0?Math.max(.5,t[0]):.5;for(let v=p;v<this.trackDuration;v+=o)r.push(v);const d=c?.time||0;console.log(`[MapGen] BPM: ${this.bpm}, Measure Duration: ${o.toFixed(3)}s, Total Measures: ${r.length}`);const g=[];let u="speed_1",w=!1,_=!1;const b=[{time:.5,speedType:"speed_1",isInverted:!1,isMini:!1}],k=b[0];if(h>=5&&k){const v=e();v<.3?k.speedType="speed_0.5":v<.6&&(k.speedType="speed_2")}if(g.push(...b),b[0]&&(u=b[0].speedType),c){const v=c.stateEvents.filter(I=>I.time<d);if(g.length=0,g.push(...v),g.length>0){const I=g[g.length-1];I&&(u=I.speedType,w=I.isInverted,_=I.isMini)}}for(const v of r){if(v<1||v<d)continue;n?.find(P=>v>=P.startTime&&v<P.endTime)?.intensity;let L;if(h<8){const P=e();P<.8?L="speed_1":P<.9?L="speed_0.5":L="speed_2"}else if(h<16){const P=e();P<.1?L="speed_0.5":P<.6?L="speed_1":L="speed_2"}else if(h<24){const P=e();P<.15?L="speed_0.5":P<.4?L="speed_1":P<.8?L="speed_2":L="speed_3"}else{const P=e();P<.1?L="speed_0.25":P<.25?L="speed_0.5":P<.4?L="speed_1":P<.5?L="speed_2":P<.8?L="speed_3":L="speed_4"}const C=h>=24?.9:h<8?.25:.5;let X=w;e()<C&&h>=3&&(X=e()>.5);let z=_;if(h>=5)if(_)e()<.6&&(z=!1);else{const P=h>=24?.08:.04;e()<P&&(z=!0)}else z=!1;(L!==u||X!==w||z!==_)&&(g.push({time:v,speedType:L,isInverted:X,isMini:z}),u=L,w=X,_=z)}const f=[];c&&f.push(...c.beatActions.filter(v=>v.time<d));const y=[...t].filter(v=>v>=.3&&v>=d).sort((v,I)=>v-I);let m=!1;c&&c.beatActions.length>0&&c.beatActions[c.beatActions.length-1].action==="click"&&(m=!0);const S=.25;for(let v=0;v<y.length;v++){const I=y[v],C=(v+1<y.length?y[v+1]:I+1)-I;if(C<S)f.push({time:I,action:m?"release":"click"}),m=!m;else if(m){const z=(e()-.5)*.3,P=Math.max(.3,Math.min(.8,.5+z));f.push({time:I,action:"click"}),f.push({time:I+C*P,action:"release"}),m=!1}else{const z=(e()-.5)*.3,P=Math.max(.3,Math.min(.8,.5+z));f.push({time:I,action:"click"}),f.push({time:I+C*P,action:"release"}),m=!1}}f.sort((v,I)=>v.time-I.time);const M=[];for(const v of f){if(M.length>0){const I=M[M.length-1];v.time-I.time<.01&&M.pop()}M.push(v)}f.length=0,f.push(...M),f.sort((v,I)=>v.time-I.time);const A=[];for(const v of f){const I=A[A.length-1];(!I||Math.abs(I.time-v.time)>.03||I.action!==v.action)&&A.push(v)}f.length=0,f.push(...A),this.autoplayLog=[];let x=200,W=360,Y=0,T=!1,B=!1,R=1,H=!1,G=45,E=0,O=0;for(c&&c.time>0&&(Y=c.time,x=c.x||200,W=c.y||360);O<g.length&&g[O].time<=Y;){const v=g[O];R=this.getSpeedMultiplierFromType(v.speedType),B=v.isInverted,H=v.isMini,G=this.getEffectiveAngle(H,R),O++}for(;E<f.length&&f[E].time<=Y;)T=f[E].action==="click",E++;for(c&&c.time>0;Y<this.trackDuration+1;){const v=this.baseSpeed*R,I=v*Math.tan(G*Math.PI/180);let L;B?L=T?1:-1:L=T?-1:1,W+=I*L*s;const C=70;W<this.minY+C&&(W=this.minY+C),W>this.maxY-C&&(W=this.maxY-C),x+=v*s,this.autoplayLog.push({x,y:W,holding:T,time:Y}),Y+=s}this.lastBeatActions=f,this.totalLength=x+500;for(const v of g){const I=this.autoplayLog.find(K=>Math.abs(K.time-v.time)<.02);if(!I)continue;const L=[],C=g[g.indexOf(v)-1],X=C?.speedType||"speed_1",z=C?.isInverted||!1,P=C?.isMini||!1;v.speedType!==X&&L.push(v.speedType),v.isInverted!==z&&L.push(v.isInverted?"gravity_yellow":"gravity_blue"),v.isMini!==P&&L.push(v.isMini?"mini_pink":"mini_green"),L.length>0&&this.generatePathAlignedPortals(I.x,I.y,L)}return g}generatePathAlignedPortals(t,n,e){const l=this.mapConfig.difficulty>=24?40:20;e.forEach((o,r)=>{const p=t+r*144,d=n-240/2;if(this.portals.push({x:p,y:this.minY,width:64,height:this.maxY-this.minY,type:o,activated:!1}),this.mapConfig.difficulty<=2)return;const g=d-this.minY-l;g>20&&this.obstacles.push({x:p-5,y:this.minY,width:74,height:g,type:"block",initialY:this.minY});const u=d+240+l,w=this.maxY-u;w>20&&this.obstacles.push({x:p-5,y:u,width:74,height:w,type:"block",initialY:u})})}isObstacleSafe(t,n,e,a,c=0){const h=this.basePlayerSize+c,s=t-h,l=t+e+h;let o=0,r=this.autoplayLog.length;for(;o<r;){const d=o+r>>>1;this.autoplayLog[d].x<s?o=d+1:r=d}const p=o;for(let d=p;d<this.autoplayLog.length;d++){const g=this.autoplayLog[d];if(g.x>l)break;if(g.y>=n-h&&g.y<=n+a+h)return!1}return!0}placeObstaclesForPath(t,n,e,a){const c=Math.max(.1,a/30),h=this.basePlayerSize;let s=1,l=!1;const o=[];this.portals.forEach(u=>{if(u.type==="mini_pink")o.push({x:u.x,isMini:!0,speed:s});else if(u.type==="mini_green")o.push({x:u.x,isMini:!1,speed:s});else if(u.type.startsWith("speed_")){const w=parseFloat(u.type.replace("speed_",""));o.push({x:u.x,isMini:l,speed:w})}}),o.sort((u,w)=>u.x-w.x);const r=u=>u<=.5?.4:u<=1?1:u<=2?1.5:2,p=()=>{const u=Math.max(h+5,50-c*35);return l?u*.5:u},d=800;let g=400;console.log(`[MapGen] Starting path obstacle placement - Diff: ${a}`);for(let u=500;u<this.totalLength-300;u+=100){const w=this.autoplayLog.find(M=>Math.abs(M.x-u)<50);if(!w)continue;const _=w.time,b=[...n].reverse().find(M=>M.time<=_);b&&(l=b.isMini,s=this.getSpeedMultiplierFromType(b.speedType));const k=w.y,f=p(),y=r(s);if(u-g<150*y)continue;if(l){this.placeTiltedBlock(u,k,f,60,e),g=u;continue}const m=Math.floor((u-500)/d)%4;m===0?(this.placeBlockWall(u,k,f,e),g=u):m===1?(this.placeTiltedBlock(u,k,f,45,e),g=u):m===2?(this.placeLaserWall(u,k,f,e),g=u):a>=10?(this.placeMovingObstacle(u,k,f,w.time,e),g=u):(this.placeBlockWall(u,k,f,e),g=u),t.find(M=>Math.abs(M.time*this.baseSpeed+200-u)<100)&&e()<.3+c*.3&&this.placeRapidBlocks(u,k,f,3,e)}}placeBlockWall(t,n,e,a){const c=50+Math.floor(a()*30),h=n-e-this.minY;h>30&&this.isObstacleSafe(t,this.minY,c,h,3)&&this.obstacles.push({x:t,y:this.minY,width:c,height:h,type:"block",initialY:this.minY});const s=n+e,l=this.maxY-s;l>30&&this.isObstacleSafe(t,s,c,l,3)&&this.obstacles.push({x:t,y:s,width:c,height:l,type:"block",initialY:s})}placeTiltedBlock(t,n,e,a,c){const h=100+Math.floor(c()*50),s=this.autoplayLog.find(d=>Math.abs(d.x-(t-100))<60),l=this.autoplayLog.find(d=>Math.abs(d.x-(t+100))<60);let o=!0;s&&l?o=l.y<s.y:s&&(o=n<s.y);const r=n-e-h;r>this.minY&&this.isObstacleSafe(t,r,h,h,3)&&this.obstacles.push({x:t,y:r,width:h,height:h,type:"slope",initialY:r,angle:o?a:-a});const p=n+e;if(p+h<this.maxY&&this.isObstacleSafe(t,p,h,h,3)&&this.obstacles.push({x:t,y:p,width:h,height:h,type:"slope",initialY:p,angle:o?-a:a}),c()<.3){const d=40+Math.floor(c()*30),g=t+h+30,u=n-d/2;this.isObstacleSafe(g,u,d,d,3)&&this.obstacles.push({x:g,y:u,width:d,height:d,type:"spike_ball",initialY:u})}}placeLaserWall(t,n,e,a){const h=n-e-this.minY-20;h>50&&this.obstacles.push({x:t+10,y:this.minY,width:30,height:h,type:"v_laser",initialY:this.minY});const s=n+e+20,l=this.maxY-s;l>50&&this.obstacles.push({x:t+10,y:s,width:30,height:l,type:"v_laser",initialY:s})}placeMovingObstacle(t,n,e,a,c){const h=40+Math.floor(c()*20),s=80+Math.floor(c()*60),l=1.5+c()*1.5,o=n-e-h-30;o>this.minY+s&&this.obstacles.push({x:t,y:o,width:h,height:h,type:"saw",initialY:o,moveY:{range:s,speed:l}});const r=n+e+30;r+h+s<this.maxY&&this.obstacles.push({x:t,y:r,width:h,height:h,type:"spike_ball",initialY:r,moveY:{range:s,speed:l}})}placeRapidBlocks(t,n,e,a,c){for(let l=0;l<a;l++){const o=t+l*60;if(l%2===0){const p=n-e-this.minY;p>20&&this.isObstacleSafe(o,this.minY,30,p,2)&&this.obstacles.push({x:o,y:this.minY,width:30,height:p,type:"block",initialY:this.minY})}else{const p=n+e,d=this.maxY-p;d>20&&this.isObstacleSafe(o,p,30,d,2)&&this.obstacles.push({x:o,y:p,width:30,height:d,type:"block",initialY:p})}}}getSmallObstacleType(t,n){const e=t();return n<8?e<.4?"spike":e<.7?"mini_spike":"orb":n<16?e<.25?"spike":e<.4?"saw":e<.55?"orb":e<.7?"mini_spike":e<.85?"spike_ball":"mine":n<24?e<.2?"spike":e<.35?"saw":e<.5?"spike_ball":e<.65?"mine":e<.8?"orb":"laser":e<.15?"spike":e<.25?"saw":e<.4?"spike_ball":e<.55?"mine":e<.7?"orb":e<.85?"laser":"v_laser"}getRandomObstacleType(t,n){if(n<8)return t()>.5?"block":"spike";if(n<16){const e=["block","spike","saw","mini_spike"];return e[Math.floor(t()*e.length)]}else if(n<24){const e=["block","spike","saw","laser","spike_ball"];return e[Math.floor(t()*e.length)]}else{const e=["block","spike","saw","laser","spike_ball","mine","orb","v_laser"];return e[Math.floor(t()*e.length)]}}getRandomDecorationType(t,n){if(n<16){const e=["mini_spike","orb"];return e[Math.floor(t()*e.length)]}else{const e=["mine","spike_ball","saw","orb"];return e[Math.floor(t()*e.length)]}}getSpeedMultiplierFromType(t){return t==="speed_0.25"?Math.sqrt(.25):t==="speed_0.5"?Math.sqrt(.5):t==="speed_1"?1:t==="speed_2"?Math.sqrt(2):t==="speed_3"?Math.sqrt(3):t==="speed_4"?Math.sqrt(4):1}getEffectiveAngle(t,n){return t?n>=1.9?78:n>=1.7?72:60:45}getValidPatterns(t,n,e){const c={top:["top","middle"],middle:["top","middle","bottom"],bottom:["middle","bottom"]}[t]||["middle"];let h=this.patterns.filter(s=>c.includes(s.requiredY));return e==="corridor"&&(h=h.filter(s=>s.type!=="corridor")),h}placePattern(t,n){const e=this.minY;for(const a of t.obstacles)this.obstacles.push({x:n+a.dx,y:e+a.dy,width:a.w,height:a.h,type:a.type,initialY:e+a.dy})}placePatternWithScale(t,n,e,a,c){const h=this.minY,s=this.maxY-this.minY;let l=1;e>1.2&&(l*=.85),e<.8&&(l*=1.15),a&&(l*=.75);for(const o of t.obstacles){let r=o.h*l,p=o.w*l,d=o.dy;if(o.dy<s/2)d=o.dy*l;else{const u=s-(o.dy+o.h);d=s-u*l-r}this.obstacles.push({x:n+o.dx*c,y:h+d,width:p,height:r,type:o.type,angle:o.angle,movement:o.movement?{...o.movement}:void 0,initialY:h+d})}}generatePortalWithType(t,n,e,a=[]){const l=this.maxY-this.minY,o=this.minY+80+e()*(l-160),r=[n,...a],p=r.length*50+(r.length-1)*40;r.forEach((w,_)=>{this.portals.push({x:t+_*90,y:o-100/2,width:50,height:100,type:w,activated:!1})});const d=this.basePlayerSize*2.2,g=o-100/2,u=o+100/2;g>this.minY+d&&this.obstacles.push({x:t-10,y:this.minY,width:p+20,height:g-this.minY-d,type:"block",initialY:this.minY}),u<this.maxY-d&&this.obstacles.push({x:t-10,y:u+d,width:p+20,height:this.maxY-(u+d),type:"block",initialY:u+d})}generatePortal(t,n){let e=["gravity_yellow","gravity_blue","speed_0.5","speed_1","speed_2","speed_3","speed_4"];const a=this.mapConfig.difficulty;a<8?e=e.filter(s=>!["speed_2","speed_3","speed_4"].includes(s)):a<16?e=e.filter(s=>!["speed_3","speed_4"].includes(s)):a<24&&(e=e.filter(s=>s!=="speed_4"));const c=e.filter(s=>s==="gravity_blue"?this.portals.some(l=>l.type==="gravity_yellow"):!0),h=c[Math.floor(n()*c.length)]||"speed_1";this.generatePortalWithType(t,h,n)}*computeAutoplayLogGen(t,n){this.autoplayLog=[],this.validationFailureInfo=null;const e=1/30,a=[...this.obstacles].sort((f,y)=>f.x-y.x),c=[...this.portals].sort((f,y)=>f.x-y.x),h=f=>{let y=0,m=a.length;for(;y<m;){const S=y+m>>>1;a[S].x<f?y=S+1:m=S}return y},s={x:t,y:n,time:0,g:this.isGravityInverted,sm:this.speedMultiplier,m:this.isMini,wa:this.waveAngle,h:!1,pIdx:0,lastSwitchTime:-1,prev:null},l=new Set,o=f=>{const y=Math.floor(f.x/5),m=Math.floor(f.y/2);return`${y}_${m}_${f.g?1:0}_${Math.round(f.sm*10)}_${f.m?1:0}`},r=(f,y,m,S,M,A=0)=>{const x=h(f-1e3);for(let W=x;W<a.length;W++){const Y=a[W];if(Y.x+Y.width<f-50)continue;if(Y.x>f+100)break;const T=Y.movement?2:0;if(this.checkObstacleCollision(Y,f,y,m+A+T,S,M))return!0}return!1},p=(f,y,m)=>{let S=f.x,M=f.y,A=f.g,x=f.sm,W=f.wa,Y=f.m,T=f.pIdx,B=f.time;for(let R=0;R<m;R++){for(;T<c.length&&S>=c[T].x;){const v=c[T];M>=v.y&&M<=v.y+v.height&&(v.type==="gravity_yellow"&&(A=!0),v.type==="gravity_blue"&&(A=!1),v.type.startsWith("speed_")&&(x=this.getSpeedMultiplierFromType(v.type)),v.type==="mini_pink"&&(Y=!0),v.type==="mini_green"&&(Y=!1),W=this.getEffectiveAngle(Y,x)),T++}const H=this.baseSpeed*x,G=H*Math.tan(W*Math.PI/180),E=Y?this.miniPlayerSize:this.basePlayerSize;if(S+=H*e,B+=e,M+=G*(A?y?1:-1:y?-1:1)*e,M<this.minY+E&&(M=this.minY+E),M>this.maxY-E&&(M=this.maxY-E),r(S,M,E,B,x,.1))return!1}return!0},d=[s];let g=t,u=0;const w=1e6;let _=null,b=t,k=n;for(;d.length>0;){u++;const f=d.pop();if(f.x>g&&(g=f.x),u%1e3===0&&(yield g/this.totalLength),f.x>=this.totalLength){_=f;break}const y=o(f);if(l.has(y))continue;l.add(y);let m=f.g,S=f.sm,M=f.m,A=f.wa,x=f.pIdx;for(;x<c.length&&f.x>=c[x].x;){const D=c[x];if(f.y>=D.y&&f.y<=D.y+D.height){if(D.type==="gravity_yellow"&&(m=!0),D.type==="gravity_blue"&&(m=!1),D.type.startsWith("speed_")&&(S=this.getSpeedMultiplierFromType(D.type)),D.type==="mini_pink"&&(M=!0),D.type==="mini_green"&&(M=!1),D.type==="teleport_in"){const N=this.portals.find(U=>U.type==="teleport_out"&&(D.linkId?U.linkId===D.linkId:U.x>D.x));if(N){f.x=N.x+N.width+20,f.y=N.y+N.height/2,x=c.findIndex(U=>U.x>=f.x),x===-1&&(x=c.length);break}}A=this.getEffectiveAngle(M,S)}x++}const W=this.baseSpeed*S,Y=W*Math.tan(A*Math.PI/180),T=M?this.miniPlayerSize:this.basePlayerSize,B=f.time+e,R=f.x+W*e;let H=f.y+Y*(m?1:-1)*e,G=f.y+Y*(m?-1:1)*e;H<this.minY+T&&(H=this.minY+T),H>this.maxY-T&&(H=this.maxY-T),G<this.minY+T&&(G=this.minY+T),G>this.maxY-T&&(G=this.maxY-T);let E=r(R,H,T,B,S,.1),O=r(R,G,T,B,S,.1);const v=T*.8;!E&&Math.abs(H-f.y)>v&&r((f.x+R)/2,(f.y+H)/2,T,f.time+e/2,S,.1)&&(E=!0),!O&&Math.abs(G-f.y)>v&&r((f.x+R)/2,(f.y+G)/2,T,f.time+e/2,S,.1)&&(O=!0),E&&O&&R>b&&(b=R,k=f.y);const I=f.h,L=60,C=.05/Math.pow(f.sm,.7);let z=f.time-f.lastSwitchTime<C;if(z){const D=f.y;if(Math.abs(D-360)>25){const U=f.g,Z=I,st=U?Z?1:-1:Z?-1:1;(D>360&&st>0||D<360&&st<0)&&(z=!1)}}let P=!1;const K=!E&&p({...f,x:R,y:H,time:B,g:m,sm:S,m:M,wa:A,pIdx:x,lastSwitchTime:I?f.lastSwitchTime:B},!0,L),Q=!O&&p({...f,x:R,y:G,time:B,g:m,sm:S,m:M,wa:A,pIdx:x,lastSwitchTime:I?B:f.lastSwitchTime},!1,L);if(I?K?P=!0:P=!1:Q?P=!1:P=!0,K&&Q){const D=[{top:-1/0,bottom:this.minY},{top:this.maxY,bottom:1/0}];for(let F=h(R-1e3);F<a.length;F++){const J=a[F];if(J.x+J.width<R)continue;if(J.x>R)break;const tt=this.getObstacleYRangeAt(J,R,B);tt&&D.push(tt)}D.sort((F,J)=>F.top-J.top);const N=[];if(D.length>0){let F={...D[0]};for(let J=1;J<D.length;J++){const tt=D[J];tt.top<=F.bottom?F.bottom=Math.max(F.bottom,tt.bottom):(N.push(F),F={...tt})}N.push(F)}const U=[];for(let F=0;F<N.length-1;F++)U.push({top:N[F].bottom,bottom:N[F+1].top});let Z=U[0],st=1/0;for(const F of U){const J=(F.top+F.bottom)/2,tt=Math.abs(f.y-J);if(f.y>=F.top&&f.y<=F.bottom){Z=F;break}tt<st&&(st=tt,Z=F)}const ht=(Z.top+Z.bottom)/2,it=Math.abs(H-ht),nt=Math.abs(G-ht);it<nt?P=!0:nt<it?P=!1:P=I}const at=R+400;let lt=!1;for(let D=h(R);D<a.length;D++){const N=a[D];if(N.x>at)break;if(N.type==="falling_spike"){lt=!0;break}}lt&&(P=!m),z&&(I&&K&&(P=!0),!I&&Q&&(P=!1));const rt=P?[!0,!1]:[!1,!0];for(const D of rt)if(D?!E:!O){if(D!==I&&z&&(I?K:Q))continue;const N=D!==I?B:f.lastSwitchTime;d.push({x:R,y:D?H:G,time:B,g:m,sm:S,m:M,wa:A,h:D,pIdx:x,lastSwitchTime:N,prev:f})}if(u>w)break}if(_){const f=[];let y=_;for(;y;)f.push({x:y.x,y:y.y,holding:y.h,time:y.time}),y=y.prev;return this.autoplayLog=f.reverse(),!0}else return this.validationFailureInfo={x:b,y:k,nearObstacles:a.filter(f=>f.x>b-400&&f.x<b+600)},!1}computeAutoplayLog(t=200,n=360){const e=this.computeAutoplayLogGen(t,n);let a=e.next();for(;!a.done;)a=e.next();return a.value}async computeAutoplayLogAsync(t,n,e){const a=this.computeAutoplayLogGen(t,n);let c=a.next(),h=performance.now();for(;!c.done;)typeof c.value=="number"&&performance.now()-h>16&&(e(c.value),await new Promise(l=>setTimeout(l,0)),h=performance.now()),c=a.next();return e(1),c.value}validateMap(){return this.computeAutoplayLog(200,360)}seededRandom(t){return()=>(t=(t*9301+49297)%233280,t/233280)}update(t,n){if(this.isDead||!this.isPlaying)return;t>.1&&(t=.1),t<0&&(t=0);const e=this.baseSpeed*this.speedMultiplier;this.waveSpeed=e;const c=this.getEffectiveAngle(this.isMini,this.speedMultiplier)*Math.PI/180;this.waveAmplitude=e*Math.tan(c),this.playerX+=this.waveSpeed*t;let h=null;if(this.isAutoplay&&this.autoplayLog.length>0){const l=this.playerX;let o=null;for(let r=this.lastAutoplayIndex;r<this.autoplayLog.length;r++){const p=this.autoplayLog[r];if(p&&p.x>=l){o=p,this.lastAutoplayIndex=r;break}}if(o){this.isHolding=o.holding;const r=this.lastAutoplayIndex>0?this.autoplayLog[this.lastAutoplayIndex-1]:null;if(r){const d=(l-r.x)/(o.x-r.x);this.playerY=r.y+(o.y-r.y)*Math.max(0,Math.min(1,d)),h=r.time+(o.time-r.time)*Math.max(0,Math.min(1,d))}else this.playerY=o.y,h=o.time;const p=this.autoplayLog.slice(this.lastAutoplayIndex,this.lastAutoplayIndex+300);this.aiPredictedPath=p.map(d=>({x:d.x,y:d.y}))}}else{this.aiPredictedPath=[];const l=this.isHolding?-1:1,o=this.isGravityInverted?-l:l;this.playerY+=this.waveAmplitude*o*t}this.playerY<this.minY+this.playerSize&&(this.playerY=this.minY+this.playerSize),this.playerY>this.maxY-this.playerSize&&(this.playerY=this.maxY-this.playerSize),this.cameraX=this.playerX-280,this.progress=Math.min(100,this.playerX/this.totalLength*100),this.score=Math.floor(this.progress*10),this.trail.push({x:this.playerX,y:this.playerY,time:Date.now()}),this.trail.length>80&&this.trail.shift(),this.updateParticles(t);const s=h!==null?h:n;if(this.updateMovingObstacles(t,s),this.updateBoss(t,s),this.checkPortalCollisions(),this.checkCollisions(s),this.beatTimes.length>0){const l=this.beatTimes.findIndex(o=>o>=n);l!==-1&&l!==this.lastMeasureIndex&&Math.abs(this.beatTimes[l]-n)<.1&&(this.isMeasureHighlight=!0,this.lastMeasureIndex=l,setTimeout(()=>this.isMeasureHighlight=!1,150))}this.playerX>=this.totalLength&&(this.isPlaying=!1)}checkPortalCollisions(){for(const t of this.portals){if(t.activated||t.x+t.width<this.playerX-50)continue;if(t.x>this.playerX+100)break;const n=this.playerSize,e=[{x:this.playerX-n,y:this.playerY-n},{x:this.playerX+n,y:this.playerY-n},{x:this.playerX-n,y:this.playerY+n},{x:this.playerX+n,y:this.playerY+n},{x:this.playerX,y:this.playerY}];if(t.angle&&t.angle!==0){const h=t.x+t.width/2,s=t.y+t.height/2,l=-t.angle*Math.PI/180;e.forEach(o=>{const r=o.x-h,p=o.y-s;o.x=h+r*Math.cos(l)-p*Math.sin(l),o.y=s+r*Math.sin(l)+p*Math.cos(l)})}e.some(h=>h&&h.x>=t.x&&h.x<=t.x+t.width&&h.y>=t.y&&h.y<=t.y+t.height)&&(t.activated=!0,this.activatePortal(t.type),this.spawnPortalParticles(t),this.onPortalActivation&&this.onPortalActivation(t.type))}}activatePortal(t){switch(t){case"gravity_yellow":this.isGravityInverted=!0;break;case"gravity_blue":this.isGravityInverted=!1;break;case"speed_0.25":case"speed_0.5":case"speed_1":case"speed_2":case"speed_3":case"speed_4":this.speedMultiplier=this.getSpeedMultiplierFromType(t);break;case"mini_pink":this.isMini=!0,this.playerSize=this.miniPlayerSize,this.waveAngle=this.miniWaveAngle;break;case"mini_green":this.isMini=!1,this.playerSize=this.basePlayerSize,this.waveAngle=45;break;case"teleport_in":const n=this.portals.find(e=>e.type==="teleport_in"&&e.activated&&Math.abs(e.x-this.playerX)<100);if(n){let e=null;n.linkId?e=this.portals.find(a=>a.type==="teleport_out"&&a.linkId===n.linkId):e=this.portals.find(a=>a.type==="teleport_out"&&a.x>this.playerX),e&&(this.playerX=e.x+e.width+20,this.playerY=e.y+e.height/2,this.cameraX=this.playerX-280,this.trail=[],this.spawnPortalParticles(e))}break}}updateBoss(t,n){if(this.boss.active){this.boss.attackTimer+=t,this.boss.x=this.cameraX+1e3,this.boss.y=360+Math.sin(n*.5)*100;for(let e=this.boss.projectiles.length-1;e>=0;e--){const a=this.boss.projectiles[e];a.x+=a.vx*t,a.y+=a.vy*t,Math.hypot(a.x-this.playerX,a.y-this.playerY)<20+this.playerSize&&this.die("보스 공격에 당했습니다!"),a.x<this.cameraX-100&&this.boss.projectiles.splice(e,1)}this.boss.attackTimer>3&&(this.boss.projectiles.push({x:this.boss.x,y:this.boss.y,vx:-600,vy:(this.playerY-this.boss.y)*2,type:"missile"}),this.boss.attackTimer=0)}}spawnPortalParticles(t){const n=this.getPortalColor(t.type);for(let e=0;e<10;e++){const a=Math.PI*2*e/10,c=50+Math.random()*60;this.particles.push({x:t.x+t.width/2,y:t.y+t.height/2,vx:Math.cos(a)*c,vy:Math.sin(a)*c,life:.6+Math.random()*.3,color:n})}}getPortalColor(t){switch(t){case"gravity_yellow":return"#ffff00";case"gravity_blue":return"#4488ff";case"speed_0.25":return"#aa5500";case"speed_0.5":return"#ff8800";case"speed_1":return"#4488ff";case"speed_2":return"#44ff44";case"speed_3":return"#ff44ff";case"speed_4":return"#ff4444";case"mini_pink":return"#ff66cc";case"mini_green":return"#66ff66";case"teleport_in":return"#00ffff";case"teleport_out":return"#ff00ff";default:return"#ffffff"}}getPortalSymbol(t){switch(t){case"gravity_yellow":return"⟲";case"gravity_blue":return"⟳";case"speed_0.25":return"<<";case"speed_0.5":return"<";case"speed_1":return">";case"speed_2":return">>";case"speed_3":return">>>";case"speed_4":return">>>>";case"mini_pink":return"◆";case"mini_green":return"◇";case"teleport_in":return"IN";case"teleport_out":return"OUT";default:return"?"}}updateParticles(t){for(let n=this.particles.length-1;n>=0;n--){const e=this.particles[n];e&&(e.x+=e.vx*t,e.y+=e.vy*t,e.vy+=150*t,e.life-=t,e.life<=0&&this.particles.splice(n,1))}}getObstacleYRangeAt(t,n,e){if(n<t.x||n>t.x+t.width)return null;let a=t.y,c=t.angle||0;if(e!==void 0&&t.movement){const h=this.getObstacleStateAt(t,e);a=h.y,c=h.angle}if(t.type==="block"){if(c){const h=c*Math.PI/180,s=t.x+t.width/2,l=a+t.height/2,o=Math.cos(h),r=Math.sin(h),p=t.width/2,d=t.height/2,g=[{dx:-p,dy:-d},{dx:p,dy:-d},{dx:p,dy:d},{dx:-p,dy:d}].map(b=>({x:s+b.dx*o-b.dy*r,y:l+b.dx*r+b.dy*o}));let u=1/0,w=-1/0,_=!1;for(let b=0;b<4;b++){const k=g[b],f=g[(b+1)%4];if(k.x<=n&&n<=f.x||f.x<=n&&n<=k.x){if(Math.abs(k.x-f.x)<.1)u=Math.min(u,k.y,f.y),w=Math.max(w,k.y,f.y);else{const y=(n-k.x)/(f.x-k.x),m=k.y+y*(f.y-k.y);u=Math.min(u,m),w=Math.max(w,m)}_=!0}}return _?{top:u,bottom:w}:null}return{top:a,bottom:a+t.height}}if(t.type==="spike"||t.type==="mini_spike"){const h=a>330,s=t.x+t.width/2;let l;if(n<=s){const o=(n-t.x)/(s-t.x);l=h?a+t.height-o*t.height:a+o*t.height}else{const o=(n-s)/(t.x+t.width-s);l=h?a+(1-o)*0+o*t.height:a+t.height-(1-o)*0-o*t.height,l=h?a+o*t.height:a+t.height-o*t.height}return h?{top:l,bottom:a+t.height}:{top:a,bottom:l}}if(t.type==="slope"){const h=(n-t.x)/t.width;if(c>0){const s=a+t.height*(1-h);return{top:a,bottom:s}}else{const s=a+t.height*h;return{top:a,bottom:s}}}if(t.type==="triangle"||t.type==="steep_triangle"){const h=(n-t.x)/t.width;return{top:a+t.height*(1-h),bottom:a+t.height}}return{top:a,bottom:a+t.height}}checkCollisions(t){for(const n of this.obstacles)if(!(n.x+n.width<this.playerX-80)){if(n.x>this.playerX+100)break;if(this.checkObstacleCollision(n,this.playerX,this.playerY,this.playerSize,t)){this.die("장애물과 충돌!"),this.spawnDeathParticles();return}}}checkObstacleCollision(t,n,e,a,c,h){let s=t.y,l=t.angle||0;if(c!==void 0&&t.movement){const y=this.getObstacleStateAt(t,c);s=y.y,l=y.angle}let o=t.width,r=t.height;if(t.type==="mine"&&t.customData?.pulseSpeed){const y=c||performance.now()/1e3,m=t.customData.pulseSpeed||2,S=t.customData.pulseAmount||.2,M=1+Math.sin(y*m)*S;o*=M,r*=M}const p=10;o=Math.max(o,p),r=Math.max(r,p);const d=0,g=0;let u=d;(t.type==="planet"||t.type==="star")&&(u=g),o=Math.max(10,o-u),r=Math.max(10,r-u);const w=t.x-(o-t.width)/2,_=s-(r-t.height)/2,b=l!==0,k=[{x:n-a,y:e-a},{x:n+a,y:e-a},{x:n-a,y:e+a},{x:n+a,y:e+a},{x:n,y:e}];if(t.type==="falling_spike"&&c!==void 0){const y=t.x-150;if(n>y){const m=this.baseSpeed*(h!==void 0?h:this.speedMultiplier||1),M=Math.max(0,n-y)/m,A=.5*2500*M*M;if(s=(t.initialY!==void 0?t.initialY:t.y)+A,s>this.maxY+100)return!1}else s=t.initialY!==void 0?t.initialY:t.y}if(t.type==="planet"||t.type==="star"){const y=c||performance.now()/1e3,m=t.x+t.width/2,S=s+t.height/2,M=o/2,A=r/2,x=n-m,W=e-S;if(x*x/((M-2)*(M-2))+W*W/((A-2)*(A-2))<1)return!0;if(t.children&&t.children.length>0){const T=t.children,B=t.customData?.orbitSpeed??1;for(let R=0;R<T.length;R++){const H=T[R];if(!H)continue;const G=y*B+R*(Math.PI*2/T.length),E=t.customData?.orbitDistance??t.width*.85,O=m+Math.cos(G)*E,v=S+Math.sin(G)*E,I=H.width?H.width/2:14;if((k[4]?.x-O)**2+(k[4]?.y-v)**2<(I+a-2)**2)return!0;if(H.type==="planet"){const C=H.customData?.orbitCount??2,X=H.customData?.orbitSpeed??2,z=H.customData?.orbitDistance??H.width*.8;for(let P=0;P<C;P++){const K=y*X+P*(Math.PI*2/C),Q=O+Math.cos(K)*z,at=v+Math.sin(K)*z;if((k[4]?.x-Q)**2+(k[4]?.y-at)**2<(8+a-2)**2)return!0}}}}else{const T=t.customData?.orbitCount??(t.type==="star"?0:2);if(!(T===0&&t.type==="star")){const B=t.customData?.orbitSpeed??1,R=t.customData?.orbitDistance??t.width*.8;for(let H=0;H<T;H++){const G=y*B+H*(Math.PI*2/T),E=m+Math.cos(G)*R,O=S+Math.sin(G)*R,v=t.type==="star"?20:10;if((k[4].x-E)**2+(k[4].y-O)**2<(v+a-2)**2)return!0;if(t.type==="star"&&t.customData?.nestedOrbit){const X=B*2.5;for(let z=0;z<2;z++){const P=y*X+z*(Math.PI*2/2),K=E+Math.cos(P)*25,Q=O+Math.sin(P)*25;if((k[4].x-K)**2+(k[4].y-Q)**2<(8+a-2)**2)return!0}}}}}return!1}if(b){const y=w+o/2,m=_+r/2,S=-l*Math.PI/180;k.forEach(M=>{const A=M.x-y,x=M.y-m;M.x=y+A*Math.cos(S)-x*Math.sin(S),M.y=m+A*Math.sin(S)+x*Math.cos(S)})}const f=k.some(y=>y.x>=w&&y.x<=w+o&&y.y>=_&&y.y<=_+r);if(!f&&t.type!=="slope"&&t.type!=="spike"&&t.type!=="mini_spike")return!1;if(t.type==="block")return f;if(t.type==="slope"){let y;t.angle>0?y=[{x:w,y:_+r},{x:w+o,y:_},{x:w,y:_}]:y=[{x:w+o,y:_+r},{x:w,y:_},{x:w+o,y:_}];for(const m of k)if(this.isPointInTriangle(m.x,m.y,y[0].x,y[0].y,y[1].x,y[1].y,y[2].x,y[2].y))return!0;return!1}if(t.type==="triangle"||t.type==="steep_triangle"){const y=[{x:w,y:_+r},{x:w+o,y:_+r},{x:w+o,y:_}];for(const m of k)if(this.isPointInTriangle(m.x,m.y,y[0].x,y[0].y,y[1].x,y[1].y,y[2].x,y[2].y))return!0;return!1}if(t.type==="spike"||t.type==="mini_spike"){const m=_>300?[{x:w,y:_+r},{x:w+o/2,y:_},{x:w+o,y:_+r}]:[{x:w,y:_},{x:w+o/2,y:_+r},{x:w+o,y:_}];for(const S of k)if(m[0]&&m[1]&&m[2]&&this.isPointInTriangle(S.x,S.y,m[0].x,m[0].y,m[1].x,m[1].y,m[2].x,m[2].y))return!0;return!1}if(t.type==="saw"||t.type==="spike_ball"||t.type==="mine"||t.type==="orb"){const y=w+o/2,m=_+r/2,S=o/2*.9,M=r/2*.9;for(const A of k){const x=A.x-y,W=A.y-m;if(x*x/(S*S)+W*W/(M*M)<1)return!0}return!1}if(t.type==="laser"){const y=r*.4,m=_+r/2;return k.some(S=>S.x>=w&&S.x<=w+o&&S.y>=m-y&&S.y<=m+y)}if(t.type==="v_laser"||t.type==="laser_beam"){const y=o*.4,m=w+o/2;return k.some(S=>S.y>=_&&S.y<=_+r&&S.x>=m-y&&S.x<=m+y)}if(t.type==="hammer"){const y=w+o/2,m=_+r/2;return k.some(S=>(S.x-y)**2+(S.y-m)**2<(o/2)**2)}if(t.type==="falling_spike"){const y=[{x:w,y:_},{x:w+o/2,y:_+r},{x:w+o,y:_}];for(const m of k)if(y[0]&&y[1]&&y[2]&&this.isPointInTriangle(m.x,m.y,y[0].x,y[0].y,y[1].x,y[1].y,y[2].x,y[2].y))return!0;return!1}if(["rotor","cannon","spark_mine","crusher_jaw","swing_blade"].includes(t.type)){const y=w+o/2,m=_+r/2,S=o/2*.8,M=r/2*.8;for(const A of k){const x=A.x-y,W=A.y-m;if(x*x/(S*S)+W*W/(M*M)<1)return!0}return!1}if(t.type==="piston_v")return f;if(t.type==="growing_spike"){const y=[{x:w,y:_+r},{x:w+o/2,y:_},{x:w+o,y:_+r}];for(const m of k)if(y[0]&&y[1]&&y[2]&&this.isPointInTriangle(m.x,m.y,y[0].x,y[0].y,y[1].x,y[1].y,y[2].x,y[2].y))return!0;return!1}return!1}isPointInRotatedRect(t,n,e){const a=(e.angle||0)*Math.PI/180,c=e.x+e.width/2,h=e.y+e.height/2,s=t-c,l=n-h,o=Math.cos(-a),r=Math.sin(-a),p=s*o-l*r,d=s*r+l*o;return Math.abs(p)<=e.width/2&&Math.abs(d)<=e.height/2}removeRedundantObstacles(){const t=new Set,n=this.obstacles.length;for(let e=0;e<n;e++){const a=this.obstacles[e];if(!a.movement)for(let c=0;c<n;c++){if(e===c)continue;const h=this.obstacles[c];if(h.movement)continue;const s=h.angle?Math.max(h.width,h.height):0;if(!(h.x-s>a.x||h.x+h.width+s<a.x+a.width)&&this.isObstacleContained(a,h)){t.add(e);break}}}t.size>0&&(console.log(`[MapGen] Removing ${t.size} redundant obstacles.`),this.obstacles=this.obstacles.filter((e,a)=>!t.has(a)))}isObstacleContained(t,n){if(n.type!=="block"&&n.type!=="spike"&&n.type!=="mini_spike")return!1;const e=this.getObstacleCorners(t);for(const a of e)if(!this.isPointInStaticObstacle(a.x,a.y,n))return!1;return!0}isPointInStaticObstacle(t,n,e){if(e.type==="block")return this.isPointInRotatedRect(t,n,e);if(e.type==="spike"||e.type==="mini_spike"){const a=e.y>300,c=e.x+e.width/2;return a?this.isPointInTriangle(t,n,e.x,e.y+e.height,c,e.y,e.x+e.width,e.y+e.height):this.isPointInTriangle(t,n,e.x,e.y,c,e.y+e.height,e.x+e.width,e.y)}return!1}getObstacleCorners(t){if(t.type==="spike"||t.type==="mini_spike"){const n=t.y>300,e=t.x+t.width/2;return n?[{x:t.x,y:t.y+t.height},{x:e,y:t.y},{x:t.x+t.width,y:t.y+t.height}]:[{x:t.x,y:t.y},{x:e,y:t.y+t.height},{x:t.x+t.width,y:t.y}]}if(t.angle){const n=t.angle*Math.PI/180,e=t.x+t.width/2,a=t.y+t.height/2,c=Math.cos(n),h=Math.sin(n),s=t.width/2,l=t.height/2;return[{dx:-s,dy:-l},{dx:s,dy:-l},{dx:s,dy:l},{dx:-s,dy:l}].map(o=>({x:e+o.dx*c-o.dy*h,y:a+o.dx*h+o.dy*c}))}return t.type==="triangle"||t.type==="steep_triangle"?[{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height},{x:t.x+t.width,y:t.y}]:[{x:t.x,y:t.y},{x:t.x+t.width,y:t.y},{x:t.x,y:t.y+t.height},{x:t.x+t.width,y:t.y+t.height}]}isPointInTriangle(t,n,e,a,c,h,s,l){const o=Math.abs((e*(h-l)+c*(l-a)+s*(a-h))/2),r=Math.abs((t*(a-h)+e*(h-n)+c*(n-a))/2),p=Math.abs((t*(h-l)+c*(l-n)+s*(n-h))/2),d=Math.abs((t*(l-a)+s*(a-n)+e*(n-l))/2);return Math.abs(o-(r+p+d))<.1}spawnDeathParticles(){const t=["#ff4444","#ff8844","#ffaa00","#ffffff"];for(let n=0;n<15;n++){const e=Math.PI*2*n/15,a=100+Math.random()*150;this.particles.push({x:this.playerX,y:this.playerY,vx:Math.cos(e)*a,vy:Math.sin(e)*a,life:.8+Math.random()*.4,color:t[Math.floor(Math.random()*t.length)]||"#ffffff"})}}getObstacleStateAt(t,n){let e=t.y,a=t.angle||0;if(t.movement){if(t.movement.type==="updown"&&t.initialY!==void 0){const{range:c,speed:h,phase:s}=t.movement;e=t.initialY+Math.sin(n*h+s)*c}else if(t.movement.type==="rotate"){const{speed:c,phase:h}=t.movement;a=(n*c+h)*180/Math.PI%360}}else["saw","rotor","spike_ball"].includes(t.type)?a=n*3*180/Math.PI%360:["hammer","swing_blade"].includes(t.type)?a=Math.sin(n*3)*60:["piston_v","crusher_jaw"].includes(t.type)&&t.initialY!==void 0&&(e=t.initialY+Math.sin(n*2)*50);return{y:e,angle:a}}updateMovingObstacles(t,n){for(const e of this.obstacles){const a=["saw","rotor","spike_ball","hammer","swing_blade","piston_v","crusher_jaw"].includes(e.type);if(e.movement||a){const c=this.getObstacleStateAt(e,n);(a||e.movement?.type==="updown")&&e.initialY===void 0&&(e.initialY=e.y),e.y=c.y,e.angle=c.angle}if(e.type==="falling_spike")if(e.customData||(e.customData={}),e.customData.isFalling===void 0&&(e.customData.isFalling=!1,e.customData.vy=0,e.initialY===void 0&&(e.initialY=e.y)),e.customData.isFalling)e.customData.vy=(e.customData.vy||0)+2500*t,e.y+=e.customData.vy*t;else{const h=e.x-this.playerX;h<150&&h>-50&&(e.customData.isFalling=!0,e.customData.vy=0),e.initialY!==void 0&&(e.y=e.initialY)}}}die(t){this.isDead=!0,this.failReason=t,this.isPlaying=!1,this.showHitboxes=!0,this.isAutoplay=!1}setHolding(t){this.isHolding=t}getProgress(){return Math.floor(this.progress)}getState(){return{playerX:this.playerX,playerY:this.playerY,velocity:this.isHolding?-this.waveAmplitude:this.waveAmplitude,isHolding:this.isHolding,progress:this.progress,isGravityInverted:this.isGravityInverted,speedMultiplier:this.speedMultiplier,isMini:this.isMini,waveAngle:this.waveAngle}}}function ft(i,t,n,e,a,c=!1,h){const s=n+t.width/2,l=e+t.height/2,o=h??t.angle,r=o&&o!==0;if(r&&(i.save(),i.translate(s,l),i.rotate(o*Math.PI/180),i.translate(-s,-l)),t.type==="invisible_wall"){c&&(i.strokeStyle="rgba(255, 255, 255, 0.5)",i.lineWidth=1,i.setLineDash([5,5]),i.strokeRect(n,e,t.width,t.height),i.setLineDash([]),i.fillStyle="rgba(255, 255, 255, 0.1)",i.fillText("INVISIBLE",n,e+15)),r&&i.restore();return}else if(t.type==="fake_block"){i.fillStyle="rgba(255, 255, 255, 0.2)",i.fillRect(n,e,t.width,t.height),i.strokeStyle="#fff",i.strokeRect(n,e,t.width,t.height),c&&(i.fillStyle="#fff",i.font="10px Arial",i.fillText("FAKE",n+5,e+15)),r&&i.restore();return}if(t.type==="spike"||t.type==="mini_spike"){const p=t.type==="mini_spike";i.fillStyle=p?"#ff6666":"#ff4444",i.shadowBlur=p?8:12,i.shadowColor="#ff4444",i.beginPath(),e>300?(i.moveTo(n,e+t.height),i.lineTo(n+t.width/2,e),i.lineTo(n+t.width,e+t.height)):(i.moveTo(n,e),i.lineTo(n+t.width/2,e+t.height),i.lineTo(n+t.width,e)),i.closePath(),i.fill()}else if(t.type==="block")i.fillStyle="#444",i.shadowBlur=5,i.shadowColor="#666",i.fillRect(n,e,t.width,t.height),i.fillStyle="#555",i.fillRect(n+2,e+2,t.width-4,t.height-4);else if(t.type==="triangle"||t.type==="steep_triangle"){const p=t.type==="steep_triangle";i.fillStyle=p?"#222":"#333",i.shadowBlur=5,i.shadowColor="#555",i.beginPath(),i.moveTo(n,e+t.height),i.lineTo(n+t.width,e+t.height),i.lineTo(n+t.width,e),i.closePath(),i.fill(),i.fillStyle=p?"#444":"#555";const d=4;i.beginPath(),i.moveTo(n+d*2,e+t.height-d),i.lineTo(n+t.width-d,e+t.height-d),i.lineTo(n+t.width-d,e+d*2),i.fill()}else if(t.type==="saw"){const p=t.width/2,d=t.height/2;i.save(),i.translate(s,l),i.fillStyle="#ffaa00",i.shadowBlur=20,i.shadowColor="#ffaa00",i.beginPath(),i.ellipse(0,0,p,d,0,0,Math.PI*2),i.fill(),i.fillStyle="#ff6600";const g=10,u=a*8;for(let w=0;w<g;w++){const _=Math.PI*2*w/g+u,b=Math.cos(_)*p*.75,k=Math.sin(_)*d*.75;i.beginPath(),i.ellipse(b,k,p*.15,d*.15,0,0,Math.PI*2),i.fill()}i.fillStyle="#cc8800",i.beginPath(),i.ellipse(0,0,p*.25,d*.25,0,0,Math.PI*2),i.fill(),i.restore()}else if(t.type==="spike_ball"){const p=t.width/2,d=t.height/2;i.save(),i.translate(s,l),i.fillStyle="#666",i.shadowBlur=15,i.shadowColor="#444";const g=8,u=a*3;i.fillStyle="#444";for(let _=0;_<g;_++){const b=Math.PI*2*_/g+u;i.beginPath();const k=Math.cos(b)*p*1.2,f=Math.sin(b)*d*1.2;i.moveTo(Math.cos(b-.2)*p*.8,Math.sin(b-.2)*d*.8),i.lineTo(k,f),i.lineTo(Math.cos(b+.2)*p*.8,Math.sin(b+.2)*d*.8),i.fill()}const w=i.createRadialGradient(-p*.3,-d*.3,p*.1,0,0,p);w.addColorStop(0,"#888"),w.addColorStop(1,"#222"),i.fillStyle=w,i.beginPath(),i.ellipse(0,0,p*.8,d*.8,0,0,Math.PI*2),i.fill(),i.restore()}else if(t.type==="laser"){const p=e+t.height/2,d=Math.sin(a*15)*5+10;i.strokeStyle="#ff3333",i.lineWidth=2,i.shadowBlur=Math.max(0,d),i.shadowColor="#ff0000",i.beginPath(),i.moveTo(n,p),i.lineTo(n+t.width,p),i.stroke(),i.strokeStyle="#ffffff",i.lineWidth=1,i.shadowBlur=0,i.beginPath(),i.moveTo(n,p),i.lineTo(n+t.width,p),i.stroke(),i.fillStyle="#777",i.fillRect(n,e,8,t.height),i.fillRect(n+t.width-8,e,8,t.height)}else if(t.type==="v_laser"){const p=n+t.width/2,d=Math.sin(a*15)*5+10;i.strokeStyle="#ff3333",i.lineWidth=2,i.shadowBlur=Math.max(0,d),i.shadowColor="#ff0000",i.beginPath(),i.moveTo(p,e),i.lineTo(p,e+t.height),i.stroke(),i.strokeStyle="#ffffff",i.lineWidth=1,i.shadowBlur=0,i.beginPath(),i.moveTo(p,e),i.lineTo(p,e+t.height),i.stroke(),i.fillStyle="#777",i.fillRect(n,e,t.width,8),i.fillRect(n,e+t.height-8,t.width,8)}else if(t.type==="slope")i.fillStyle="#222",i.beginPath(),(t.angle||0)>0?(i.moveTo(n,e+t.height),i.lineTo(n+t.width,e),i.lineTo(n,e)):(i.moveTo(n+t.width,e+t.height),i.lineTo(n,e),i.lineTo(n+t.width,e)),i.closePath(),i.fill(),i.strokeStyle="rgba(100,200,255,0.3)",i.lineWidth=3,i.stroke();else if(t.type==="mine"){const p=t.width/2,d=Math.sin(a*10)*.1+.9;i.fillStyle="#ff3333",i.shadowBlur=10,i.shadowColor="#ff0000",i.beginPath();for(let g=0;g<6;g++){const u=Math.PI/3*g+a*2,w=s+Math.cos(u)*p*d,_=l+Math.sin(u)*p*d;g===0?i.moveTo(w,_):i.lineTo(w,_)}i.closePath(),i.fill(),i.fillStyle="#550000",i.beginPath(),i.arc(s,l,p*.4,0,Math.PI*2),i.fill()}else if(t.type==="orb"){const p=t.width/2,d=t.height/2,g=Math.sin(a*5)*.1+1,u=i.createRadialGradient(s,l,p*.1,s,l,p*g);u.addColorStop(0,"#ffffff"),u.addColorStop(.4,"#aa44ff"),u.addColorStop(.8,"#4400cc"),u.addColorStop(1,"rgba(68, 0, 204, 0)"),i.fillStyle=u,i.globalCompositeOperation="lighter",i.beginPath(),i.ellipse(s,l,p*g,d*g,0,0,Math.PI*2),i.fill(),i.globalCompositeOperation="source-over"}else if(t.type==="hammer"){i.save(),i.translate(s,l);const p=Math.sin(a*3)*.5;i.rotate(p),i.fillStyle="#666",i.fillRect(-5,-t.height/2,10,t.height*.7),i.fillStyle="#888",i.shadowBlur=10,i.shadowColor="#fff",i.fillRect(-t.width/2,t.height*.2-t.height/2,t.width,t.height*.3),i.strokeStyle="#fff",i.lineWidth=2,i.strokeRect(-t.width/2,t.height*.2-t.height/2,t.width,t.height*.3),i.restore()}else if(["rotor","spark_mine"].includes(t.type)){i.save(),i.translate(s,l);const p=t.type==="spark_mine"?2:8,d=a*p;i.rotate(d);const g=t.width/2;if(t.type==="rotor"){i.fillStyle="#ff3333",i.shadowBlur=15,i.shadowColor="#ff0000";for(let u=0;u<3;u++)i.rotate(Math.PI*2/3),i.beginPath(),i.moveTo(0,0),i.lineTo(-5,-t.height/2),i.lineTo(5,-t.height/2),i.fill();i.fillStyle="#fff",i.beginPath(),i.arc(0,0,8,0,Math.PI*2),i.fill()}else if(t.type==="spark_mine"){i.fillStyle="#ffaa00",i.beginPath();const u=12;for(let w=0;w<u*2;w++){const _=w%2===0?g:g*.4,b=Math.PI*w/u;i.lineTo(Math.cos(b)*_,Math.sin(b)*_)}i.fill()}i.restore()}else if(t.type==="laser_beam"){const p=e+t.height/2,d=Math.sin(a*20)*2+3;i.strokeStyle="#00ffff",i.lineWidth=t.height+d,i.shadowColor="#00ffff",i.shadowBlur=20,i.beginPath(),i.moveTo(n,p),i.lineTo(n+t.width,p),i.stroke(),i.shadowBlur=0,i.strokeStyle="#fff",i.lineWidth=t.height*.3,i.stroke()}else if(t.type==="piston_v")i.fillStyle="#555",i.fillRect(n,e,t.width,t.height),i.fillStyle="#888",i.fillRect(n+t.width*.3,e,t.width*.4,t.height),i.fillStyle="#333",e<360?i.fillRect(n,e+t.height-20,t.width,20):i.fillRect(n,e,t.width,20);else if(t.type==="cannon")i.fillStyle="#444",i.beginPath(),i.arc(n+t.width/2,e+t.height/2,t.width/2,0,Math.PI*2),i.fill(),i.fillStyle="#000",i.beginPath(),i.arc(n+t.width/2,e+t.height/2,t.width/3,0,Math.PI*2),i.fill();else if(["falling_spike","growing_spike"].includes(t.type)){i.fillStyle="#ff4444",i.beginPath();const p=n+t.width/2;t.type==="falling_spike"?(i.moveTo(n,e),i.lineTo(n+t.width,e),i.lineTo(p,e+t.height)):(i.moveTo(n,e+t.height),i.lineTo(n+t.width,e+t.height),i.lineTo(p,e)),i.fill()}else if(t.type==="crusher_jaw"){const p=n+t.width/2,d=e+t.height/2,g=5;i.fillStyle="#ff4444",i.beginPath(),i.moveTo(n+g,e),i.lineTo(n+t.width-g,e),i.lineTo(p,d-5),i.fill(),i.beginPath(),i.moveTo(n+g,e+t.height),i.lineTo(n+t.width-g,e+t.height),i.lineTo(p,d+5),i.fill(),i.fillStyle="#ffaaaa",i.beginPath(),i.moveTo(n+t.width*.3,e),i.lineTo(n+t.width*.35,e+t.height*.3),i.lineTo(n+t.width*.4,e),i.fill(),i.beginPath(),i.moveTo(n+t.width*.6,e+t.height),i.lineTo(n+t.width*.65,e+t.height*.7),i.lineTo(n+t.width*.7,e+t.height),i.fill()}else if(t.type==="swing_blade"){const p=n+t.width/2,d=e;i.save(),i.translate(p,d);const g=Math.sin(a*2)*.8;i.rotate(g),i.strokeStyle="#eee",i.lineWidth=2,i.beginPath(),i.moveTo(0,0),i.lineTo(0,t.height),i.stroke(),i.fillStyle="#ccc",i.beginPath(),i.ellipse(0,t.height,t.width/2,t.height/2,0,0,Math.PI*2),i.fill(),i.restore()}else if(t.type==="planet"||t.type==="star"){const p=t.type==="star",d=t.width/2;if(p){const g=1+Math.sin(a*5)*.05,u=i.createRadialGradient(s,l,d*.2,s,l,d*g);u.addColorStop(0,"#ffff88"),u.addColorStop(.5,"#ffaa00"),u.addColorStop(1,"rgba(255, 68, 0, 0)"),i.fillStyle=u,i.beginPath(),i.arc(s,l,d*1.2*g,0,Math.PI*2),i.fill(),i.fillStyle="#fff",i.beginPath(),i.arc(s,l,d*.6,0,Math.PI*2),i.fill()}else{const g=i.createRadialGradient(s,l-d*.3,d*.1,s,l,d);g.addColorStop(0,"#4488ff"),g.addColorStop(1,"#002266"),i.fillStyle=g,i.beginPath(),i.arc(s,l,d,0,Math.PI*2),i.fill()}if(t.children&&t.children.length>0){const g=t.customData?.orbitSpeed??1;for(let u=0;u<t.children.length;u++){const w=t.children[u];if(!w)continue;const _=a*g+u*(Math.PI*2/t.children.length),b=t.customData?.orbitDistance??t.width*.85,k=s+Math.cos(_)*b,f=l+Math.sin(_)*b,y=k-w.width/2,m=f-w.height/2;ft(i,w,y,m,a,c)}}}r&&i.restore()}export{yt as G,ft as d};
